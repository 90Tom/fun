<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Kočičí Dobrodružství! Turbo Deluxe++ Extreme!</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #2d2d2d;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        #gameContainer {
           position: relative;
           width: 900px;
           height: 700px;
           border: 5px solid #4a5b6d;
           background-color: #ffffff;
           box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
           transition: transform 0.05s ease-out, background 0.8s ease;
           overflow: hidden;
           image-rendering: pixelated;
           border-radius: 10px;
        }
        #gameCanvas {
           display: block;
           width: 100%;
           height: 100%;
        }
        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .overlayText {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); font-size: 48px;
            font-weight: bold; color: #ffffff; text-align: center;
            padding: 50px 60px; border-radius: 30px; display: none;
            text-shadow: 6px 6px 10px rgba(0,0,0,0.75); z-index: 10;
            box-shadow: inset 0 0 30px rgba(0,0,0,0.4), 0 8px 22px rgba(0,0,0,0.3);
        }
        #gameOver { background: linear-gradient(140deg, #d32f2f, #b71c1c); }
        #gameOver small { font-size: 0.5em; }

        #levelTransitionDisplay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            font-size: 60px; font-weight: bold; color: #fff; text-align: center;
            background: radial-gradient(circle, rgba(50, 70, 90, 0.96), rgba(25, 35, 45, 0.99));
            display: none;
            z-index: 11;
            opacity: 0;
            transition: opacity 0.6s ease-in-out;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
        }
         #levelTransitionDisplay .level-title {
             font-size: 0.8em;
             margin-bottom: 15px;
             opacity: 0.9;
             font-weight: normal;
         }
         #levelTransitionDisplay .level-name {
             font-size: 1.15em;
             font-weight: bold;
         }
        #levelTransitionDisplay.visible {
            display: flex !important;
            opacity: 1;
        }

        #hud {
            display: flex; justify-content: space-between; align-items: center;
            width: 900px; margin-top: 18px; padding: 12px 35px;
            box-sizing: border-box; font-size: 26px;
            font-weight: bold; color: #1c2833;
            background: rgba(245, 245, 245, 0.9);
            border-radius: 18px;
            box-shadow: 0 5px 12px rgba(0,0,0,0.25);
            text-shadow: 1px 1px 2px rgba(255,255,255,0.7);
            border: 1px solid rgba(44, 62, 80, 0.15);
            z-index: 20;
            position: relative;
        }
        .hud-item {
            display: flex; align-items: center;
            gap: 14px;
        }
        .hud-item i { font-style: normal; font-size: 30px; vertical-align: middle;}

        #healthBarContainer {
            position: relative;
            width: 190px; height: 28px; background-color: #cacfd2;
            border-radius: 14px; border: 1px solid #95a5a6; overflow: hidden;
            box-shadow: inset 0 3px 5px rgba(0,0,0,0.25);
        }
        #healthBar {
            width: 100%; height: 100%; background: linear-gradient(to bottom, #58d68d, #28b463);
            border-radius: 13px 0 0 13px;
            transition: width 0.25s ease-in-out, background 0.35s ease;
        }
        #healthBar.low { background: linear-gradient(to bottom, #f1948a, #e74c3c); }
        #healthBar.medium { background: linear-gradient(to bottom, #f8c471, #f39c12); }
        .health-flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            opacity: 0;
            transition: opacity 0.1s ease-out;
            pointer-events: none;
            z-index: 1;
        }
        .health-flash.active { opacity: 1; transition: opacity 0.05s ease-in; }


         #dashCooldownContainer {
            width: 130px; height: 18px; background-color: #cacfd2;
            border-radius: 9px; border: 1px solid #95a5a6; overflow: hidden;
            box-shadow: inset 0 2px 3px rgba(0,0,0,0.2);
            transition: background-color 0.2s ease, border-color 0.2s ease;
         }
         #dashCooldownBar {
             width: 0%; height: 100%; background-color: #5dade2;
             border-radius: 8px 0 0 8px;
             transition: width 0.05s linear;
         }
         #dashCooldownContainer.ready {
             background-color: #aed6f1;
             border-color: #3498db;
             animation: dashReadyPulse 1.3s infinite ease-in-out;
         }
         #dashCooldownBar.ready {
              width: 100% !important;
              background-color: #85c1e9;
         }
         @keyframes dashReadyPulse {
             0%, 100% { transform: scale(1.0); box-shadow: inset 0 2px 3px rgba(0,0,0,0.2), 0 0 6px rgba(52, 152, 219, 0.6); }
             50% { transform: scale(1.04); box-shadow: inset 0 2px 3px rgba(0,0,0,0.2), 0 0 14px rgba(52, 152, 219, 0.9); }
         }


        #upgradeInfo {
            position: absolute; bottom: 25px; left: 50%; transform: translateX(-50%);
            background-color: rgba(35,45,55,.95); color: #f0f0f0; padding: 14px 22px;
            border-radius: 14px; font-size: 19px; font-weight: 700; display: none; z-index: 5;
            text-align: center; min-width: 280px; box-shadow: 0 5px 10px rgba(0,0,0,0.4);
            transition: background-color 0.2s ease, opacity 0.3s ease;
            border: 1px solid rgba(236, 240, 241, 0.25);
        }
        #upgradeInfo.low-time {
            animation: lowTimePulse 0.7s infinite alternate ease-in-out;
        }
        #upgradeInfo .name{margin-bottom:10px; font-size: 20px;}
        #upgradeInfo .durationBarContainer{width:100%;height:16px;background-color:#7f8c8d;border-radius:8px;overflow:hidden; border: 1px solid #566573;}
        #upgradeInfo .durationBar{width:100%;height:100%;background-color:#f1c40f;border-radius:7px 0 0 7px;transition:width .1s linear, background-color 0.2s ease;}

         @keyframes lowTimePulse {
             from { opacity: 1; background-color: rgba(200, 60, 50, 0.92); }
             to { opacity: 0.7; background-color: rgba(230, 90, 80, 0.95); }
         }

        #comboDisplay {
             position: absolute; top: 25px; left: 50%; transform: translateX(-50%);
             font-size: 38px; font-weight: 800; color: #e74c3c;
             text-shadow: 4px 4px 6px rgba(0,0,0,.5); display: none; z-index: 6;
             background: linear-gradient(to bottom, rgba(255,255,255,.92), rgba(240, 240, 240, .9));
             padding: 12px 30px; border-radius: 20px;
             border: 3px solid rgba(231, 76, 60, 0.7);
         }
         @keyframes comboPulse {
             0% { transform: translateX(-50%) scale(0.7); opacity: 0.6; }
             50% { transform: translateX(-50%) scale(1.3); opacity: 1; }
             100% { transform: translateX(-50%) scale(1); opacity: 1; }
         }
         #comboDisplay.visible {
             display: block;
             animation: comboPulse 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
         }

         #damageFlashOverlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 20, 20, 0.4);
            opacity: 0;
            z-index: 15;
            pointer-events: none;
            transition: opacity 0.12s ease-out;
            backdrop-filter: saturate(2.5) brightness(1.1);
         }
         #damageFlashOverlay.active {
             opacity: 1;
             transition: opacity 0.06s ease-in;
         }

         #bossHealthBarContainer {
            position: absolute;
            top: 15px; left: 50%; transform: translateX(-50%);
            width: 60%; height: 35px; background-color: rgba(50,50,50,0.6);
            border-radius: 17px; border: 3px solid #111; overflow: hidden;
            box-shadow: 0 8px 15px rgba(0,0,0,0.4), inset 0 0 10px rgba(0,0,0,0.5);
            z-index: 7;
            display: none;
         }
        #bossHealthBar {
            width: 100%; height: 100%;
            background: linear-gradient(to right, #b71c1c, #f44336, #ff7043);
            border-radius: 14px 0 0 14px;
            transition: width 0.35s ease-out, background 0.5s ease;
            box-shadow: inset 0 -4px 8px rgba(255,255,255,0.2), inset 0 4px 6px rgba(0,0,0,0.3);
         }
         #bossHealthBar.phase2 { background: linear-gradient(to right, #d84315, #ff7043, #ffab40); }
         #bossHealthBar.phase3 { background: linear-gradient(to right, #e65100, #ffab40, #ffd180); }
        #bossHealthFlash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 180, 0.85);
            opacity: 0;
            transition: opacity 0.15s ease-out;
            pointer-events: none;
            z-index: 1;
        }
        #bossHealthFlash.active { opacity: 1; transition: opacity 0.08s ease-in; }
        #bossName {
             position: absolute; top: 0px; left: 50%; transform: translateX(-50%) translateY(-110%);
             font-size: 18px; font-weight: bold; color: #fff;
             text-shadow: 2px 2px 4px #000; display: none; z-index: 8;
             background: rgba(0,0,0,0.5); padding: 3px 10px; border-radius: 5px;
         }

        #winScreenOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; flex-direction: column; justify-content: flex-start; align-items: center;
            background: linear-gradient(to bottom, #3a5a8b 0%, #6e8ab4 30%, #f0a880 60%, #ff8f71 80%, #D9534F 100%);
            z-index: 50; color: #fff; font-family: 'Comic Sans MS', cursive, sans-serif;
            text-align: center; opacity: 0; transition: opacity 2.5s ease-in;
            pointer-events: none; padding-bottom: 0; box-sizing: border-box;
            overflow: hidden;
        }
        #winScreenOverlay.visible { display: flex; opacity: 1; pointer-events: auto;}

        .win-sun {
            position: absolute;
            top: 25%; left: 50%;
            width: 300px; height: 300px;
            background: radial-gradient(circle, rgba(255,255,220,0.95) 0%, rgba(255,230,140,0.8) 50%, rgba(255,200,100,0.3) 70%, rgba(255,180,80,0) 85%);
            border-radius: 50%;
            transform: translateX(-50%) translateY(-50%);
            z-index: 47;
            filter: blur(12px);
            animation: sunPulse 12s infinite alternate ease-in-out;
        }
        @keyframes sunPulse {
            from { transform: translateX(-50%) translateY(-50%) scale(0.92); opacity: 0.75; filter: blur(14px) brightness(0.95); }
            to { transform: translateX(-50%) translateY(-50%) scale(1.08); opacity: 1; filter: blur(10px) brightness(1.05); }
        }
        .sun-ray {
             position: absolute; top: 25%; left: 50%;
             width: 8px; height: 400px;
             background: linear-gradient(to bottom, rgba(255, 245, 200, 0.4) 0%, rgba(255, 230, 150, 0.1) 60%, transparent 100%);
             transform-origin: top center;
             animation: rayShine 10s infinite ease-in-out;
             z-index: 46;
        }
        .sun-ray.one { transform: translateX(-50%) translateY(-50%) rotate(-25deg) scaleY(1.1); animation-delay: -2s; }
        .sun-ray.two { transform: translateX(-50%) translateY(-50%) rotate(10deg); animation-delay: -4s; }
        .sun-ray.three { transform: translateX(-50%) translateY(-50%) rotate(35deg) scaleY(0.9); animation-delay: -6s; }
        @keyframes rayShine {
            0%, 100% { opacity: 0.2; transform: scaleY(0.9) rotate(var(--angle-start, -25deg)); }
            50% { opacity: 0.5; transform: scaleY(1.1) rotate(var(--angle-end, 10deg)); }
        }

        .win-mountains {
            position: absolute; bottom: 20%; left: 0; width: 100%; height: 22%;
            background: linear-gradient(to top, rgba(60,40,30,0.95), rgba(80,50,40,0.75));
            clip-path: polygon(0 100%, 0 70%, 10% 45%, 25% 60%, 40% 30%, 55% 55%, 70% 25%, 85% 65%, 100% 40%, 100% 100%);
            z-index: 48;
            filter: brightness(0.9);
        }
         .win-mountains.far {
             bottom: 22%; height: 20%;
             background: linear-gradient(to top, rgba(80, 60, 50, 0.7), rgba(100, 70, 60, 0.5));
             clip-path: polygon(0 100%, 0 80%, 15% 60%, 30% 75%, 50% 50%, 65% 70%, 80% 55%, 90% 75%, 100% 60%, 100% 100%);
             z-index: 47; filter: blur(1px) brightness(0.95);
             opacity: 0.8;
         }


        .win-ocean {
             position: absolute; bottom: 10%; left: 0; width: 100%; height: 15%;
             background: linear-gradient(to top, #2a4a6f, #4c7a9f);
             z-index: 49;
             overflow: hidden;
             border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        .win-wave {
             position: absolute; bottom: 75%; left: -10%; width: 120%; height: 40px;
             background: rgba(135, 206, 250, 0.25);
             border-radius: 50%;
             animation: waveMove 8s infinite linear;
             opacity: 0.6;
             filter: blur(1px);
        }
        .win-wave.two { animation-delay: -4s; animation-duration: 9s; bottom: 65%; opacity: 0.4;}
        .win-wave.three { animation-delay: -2s; animation-duration: 7s; bottom: 85%; opacity: 0.3;}
        @keyframes waveMove {
             0% { transform: translateX(0%) scaleY(1); }
             50% { transform: translateX(-3%) scaleY(0.85); }
             100% { transform: translateX(0%) scaleY(1); }
        }

        .win-porch {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 12%;
            background: linear-gradient(to bottom, #a05a2c, #8b4513 70%, #6b3a1a);
            z-index: 51;
            border-top: 5px solid #5a2d0f;
            box-shadow: inset 0 5px 10px rgba(0,0,0,0.4);
        }
        .win-porch::before {
            content: ''; position: absolute; top: -10px; left: 0; width: 100%; height: 10px;
            background: repeating-linear-gradient(90deg, #5a2d0f, #5a2d0f 80px, #7b4a1f 80px, #7b4a1f 86px);
        }

        .win-cloud {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            filter: blur(8px);
            opacity: 0.7;
            z-index: 46;
            animation: cloudDrift 30s linear infinite alternate;
        }
        .win-cloud.cloud1 { top: 15%; left: 10%; width: 180px; height: 70px; animation-duration: 45s; }
        .win-cloud.cloud2 { top: 22%; left: 70%; width: 120px; height: 50px; animation-duration: 55s; }
        .win-cloud.cloud3 { top: 10%; left: 40%; width: 150px; height: 60px; animation-duration: 65s; opacity: 0.6; filter: blur(10px);}
        .win-cloud::before, .win-cloud::after {
            content: ''; position: absolute; background-color: rgba(255, 255, 255, 0.75); border-radius: 50%;
        }
        .win-cloud.cloud1::before { width: 80px; height: 80px; top: -30px; left: 20px; }
        .win-cloud.cloud1::after { width: 90px; height: 70px; top: -15px; right: 15px; }
        .win-cloud.cloud2::before { width: 50px; height: 50px; top: -20px; left: 10px; }
        .win-cloud.cloud2::after { width: 60px; height: 40px; top: -10px; right: 5px; }
        .win-cloud.cloud3::before { width: 70px; height: 70px; top: -25px; left: 15px; }
        .win-cloud.cloud3::after { width: 80px; height: 60px; top: -12px; right: 10px; }

        @keyframes cloudDrift {
            from { transform: translateX(-15%); }
            to { transform: translateX(15%); }
        }

        #winScreenContent {
            padding: 25px 35px; background: rgba(40, 20, 10, 0.75); border-radius: 25px;
            max-width: 550px; pointer-events: auto; z-index: 55;
            position: absolute; top: 10%; left: 50%; transform: translateX(-50%);
            box-shadow: 0 10px 25px rgba(0,0,0,0.5), inset 0 0 15px rgba(255,230,200,0.1);
            border: 3px solid rgba(255, 235, 215, 0.3);
            backdrop-filter: blur(3px);
        }
        #winTitle {
            font-size: 52px; font-weight: bold; margin-bottom: 12px;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.85); color: #fff8ee;
        }
        #winMessage {
            font-size: 20px; margin-bottom: 18px; line-height: 1.5; color: #fff0e0;
        }
        #completionTime { font-size: 24px; margin-bottom: 18px; color: #ffebcd; font-weight: bold;}
        #credits { font-size: 15px; line-height: 1.4; margin-bottom: 22px; color: #f5deb3; }
        #restartPrompt { font-size: 22px; font-weight: bold; animation: pulse 1.5s infinite; color: #fffafa; text-shadow: 2px 2px 4px rgba(0,0,0,0.6); }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.85; }
        }

        .win-character {
            position: absolute; z-index: 53;
            filter: drop-shadow(4px 6px 5px rgba(0,0,0,0.45));
            transition: transform 0.3s ease-out;
            transform-origin: bottom center;
        }
        .win-character:hover { transform: scale(1.1) translateY(-10px) !important; }
        .win-cat { width: 95px; height: auto; left: calc(50% - 48px); bottom: 2%; z-index: 54; }
        .win-bird { width: 40px; height: auto; }
        .win-bird1 { left: calc(50% - 110px); bottom: 4%; }
        .win-bird2 { left: calc(50% + 70px); bottom: 3%; }
        .win-bird3 { left: calc(50% - 160px); bottom: 1%; }
        .win-bird4 { left: calc(50% + 120px); bottom: 0%; }

        .win-cherry-tree {
            position: absolute; bottom: 10%; width: 180px; height: 280px;
            z-index: 52; pointer-events: none;
            filter: drop-shadow(5px 0px 10px rgba(0,0,0,0.3));
        }
        .win-cherry-tree::before {
            content: ''; position: absolute; bottom: 0; left: 50%; transform: translateX(-50%);
            width: 35px; height: 180px; background: linear-gradient(to right, #60381f, #804d24 40%, #a06739 80%);
            border-radius: 15px 15px 0 0; box-shadow: inset 0 0 12px rgba(0,0,0,0.5), 2px 0 4px rgba(0,0,0,0.2);
        }
        .win-cherry-tree::after {
            content: ''; position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            width: 180px; height: 180px;
            background: radial-gradient(circle, rgba(255, 192, 203, 0.85) 30%, rgba(255, 182, 193, 0.75) 60%, rgba(255, 160, 173, 0.6) 85%);
            border-radius: 50%; filter: blur(4px); opacity: 0.9;
        }
         .win-cherry-tree .foliage {
             position: absolute; border-radius: 50%;
             background: radial-gradient(circle, rgba(255, 205, 215, 0.95), rgba(255, 185, 195, 0.85));
             animation: gentleSwayFoliage 11s infinite ease-in-out alternate;
             box-shadow: inset 0 0 10px rgba(0,0,0,0.1), 0 3px 5px rgba(0,0,0,0.2);
         }
         .win-cherry-tree .foliage1 { top: 10px; left: 20%; width: 110px; height: 110px; animation-delay: -2.5s; }
         .win-cherry-tree .foliage2 { top: 45px; left: 0%; width: 130px; height: 130px; animation-delay: -5s; }
         .win-cherry-tree .foliage3 { top: 30px; left: 50%; width: 100px; height: 100px; animation-delay: -7.5s; }

        .win-cherry-tree.left { left: 8%; transform: scaleX(-1); }
        .win-cherry-tree.right { right: 8%; }

        @keyframes gentleSwayFoliage {
            from { transform: rotate(-2.0deg) translateX(-3px); }
            to { transform: rotate(2.0deg) translateX(3px); }
        }

        .cherry-blossom {
            position: absolute; width: 12px; height: 9px;
            background-color: #ffe0e5;
            border-radius: 12px 0 12px 0 / 10px 0 10px 0;
            opacity: 0.85; animation: fall 12s linear infinite;
            pointer-events: none; z-index: 56;
            filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.15));
         }
         @keyframes fall {
             0% { transform: translateY(-15vh) rotate(0deg) scale(1.1); opacity: 0.9; }
             100% { transform: translateY(115vh) rotate(720deg) scale(0.6) translateX(calc(var(--drift, 0) * 1px)); opacity: 0; }
         }

        #fadeOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: black; opacity: 0; pointer-events: none; z-index: 49;
        }

    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas" width="900" height="700"></canvas>
    <div id="fadeOverlay"></div>
    <div id="gameOver" class="overlayText">PROHRÁLI JSTE!<br>Zdraví na nule.<br><small>Stiskněte CTRL+R pro restart</small></div>
    <div id="levelTransitionDisplay">
        <div class="level-title">Další Úroveň</div>
        <div class="level-name" id="transitionLevelInfo">Připrav se...</div>
    </div>
    <div id="upgradeInfo">
        <div class="name">Název Vylepšení</div>
        <div class="durationBarContainer"><div class="durationBar"></div></div>
    </div>
     <div id="comboDisplay">Kombo x2!</div>
     <div id="damageFlashOverlay"></div>
     <div id="bossHealthBarContainer">
         <div id="bossName">OBŘÍ PES</div>
         <div id="bossHealthBar"></div>
         <div id="bossHealthFlash"></div>
     </div>
     <div id="winScreenOverlay">
         <div class="win-sun"></div>
         <div class="sun-ray one" style="--angle-start: -25deg; --angle-end: 5deg;"></div>
         <div class="sun-ray two" style="--angle-start: 10deg; --angle-end: 20deg;"></div>
         <div class="sun-ray three" style="--angle-start: 35deg; --angle-end: -5deg;"></div>
         <div class="win-cloud cloud1"></div>
         <div class="win-cloud cloud2"></div>
         <div class="win-cloud cloud3"></div>
         <div class="win-mountains far"></div>
         <div class="win-mountains"></div>
         <div class="win-ocean">
             <div class="win-wave"></div>
             <div class="win-wave two"></div>
             <div class="win-wave three"></div>
         </div>
         <div class="win-porch"></div>
         <div class="win-cherry-tree left">
             <div class="foliage foliage1"></div>
             <div class="foliage foliage2"></div>
             <div class="foliage foliage3"></div>
         </div>
         <div class="win-cherry-tree right">
             <div class="foliage foliage1"></div>
             <div class="foliage foliage2"></div>
             <div class="foliage foliage3"></div>
         </div>
         <img src="kocka.png" alt="Cat" class="win-character win-cat">
         <img src="ptak.png" alt="Bird 1" class="win-character win-bird win-bird1">
         <img src="ptak.png" alt="Bird 2" class="win-character win-bird win-bird2">
         <img src="ptak.png" alt="Bird 3" class="win-character win-bird win-bird3">
         <img src="ptak.png" alt="Bird 4" class="win-character win-bird win-bird4">
         <div id="winScreenContent">
            <div id="winTitle">VÍTĚZSTVÍ!</div>
            <div id="winMessage">
                Porazili jste Psy! Ptáci jsou nyní vaši přátelé!
            </div>
            <div id="completionTime">Čas: 00:00</div>
            <div id="credits">
                Vyrobil Tomáš Macháček pomocí AI<br>
                Speciální poděkování a inspirace Mgr. Ondřej Kořínek ❤️
            </div>
            <div id="restartPrompt">Stiskněte CTRL+R pro novou hru</div>
         </div>
     </div>
</div>
<div id="hud">
    <div class="hud-item"><i title="Skóre">🏆</i><span id="score">Skóre: 0</span></div>
     <div class="hud-item">
        <i title="Zdraví">❤️</i>
        <div id="healthBarContainer">
             <div id="healthBar"></div>
             <div class="health-flash"></div>
        </div>
        <i title="Sprint">⚡</i>
        <div id="dashCooldownContainer" title="Sprint Cooldown"><div id="dashCooldownBar"></div></div>
     </div>
    <div class="hud-item"><i title="Úroveň">📈</i><span id="levelDisplay">Úroveň: 1</span></div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('gameContainer');
    const scoreDisplay = document.getElementById('score');
    const levelDisplay = document.getElementById('levelDisplay');
    const gameOverDisplay = document.getElementById('gameOver');
    const healthBarElement = document.getElementById('healthBar');
    const healthBarContainer = document.getElementById('healthBarContainer');
    const healthFlashElement = healthBarContainer.querySelector('.health-flash');
    const upgradeInfoDisplay = document.getElementById('upgradeInfo');
    const upgradeNameElement = upgradeInfoDisplay.querySelector('.name');
    const upgradeDurationBarElement = upgradeInfoDisplay.querySelector('.durationBar');
    const comboDisplay = document.getElementById('comboDisplay');
    const levelTransitionDisplay = document.getElementById('levelTransitionDisplay');
    const transitionLevelInfo = document.getElementById('transitionLevelInfo');
    const dashCooldownBar = document.getElementById('dashCooldownBar');
    const dashCooldownContainer = document.getElementById('dashCooldownContainer');
    const damageFlashOverlay = document.getElementById('damageFlashOverlay');
    const bossHealthBarContainer = document.getElementById('bossHealthBarContainer');
    const bossHealthBarElement = document.getElementById('bossHealthBar');
    const bossHealthFlashElement = document.getElementById('bossHealthFlash');
    const bossNameElement = document.getElementById('bossName');
    const winScreenOverlay = document.getElementById('winScreenOverlay');
    const completionTimeDisplay = document.getElementById('completionTime');
    const fadeOverlay = document.getElementById('fadeOverlay');


    const catImg = new Image(); catImg.src = 'kocka.png';
    const birdImg = new Image(); birdImg.src = 'ptak.png';
    const dogImg = new Image(); dogImg.src = 'pes.png';
    const goldenBirdImg = new Image(); goldenBirdImg.src = 'zlaty_ptak.png';
    const bossImg = new Image(); bossImg.src = 'pes.png';

    [catImg, birdImg, dogImg, goldenBirdImg, bossImg].forEach(img => {
        img.onerror = () => { console.error(`Nepodařilo se načíst obrázek: ${img.src}`); };
    });

    const WIN_LEVEL = 11;
    const SCORE_PER_LEVEL = 4;
    const NEW_DOG_LEVEL_INTERVAL = 2;
    const MAX_DOGS = 10;
    const PICKUP_SPAWN_TIME_FRAMES = 27 * 60;
    const MAX_PICKUPS = 3;
    const CAT_BASE_SPEED = 3.95;
    const CAT_DAMAGE_TAKEN = 17;
    const CAT_INVINCIBILITY_DURATION_FRAMES = 1.65 * 60;
    const PICKUP_SIZE = 30;
    const WALL_BUFFER = 8;
    const OBSTACLE_BUFFER = 4;
    const SAFE_SPAWN_DISTANCE_CAT = 185;
    const SAFE_SPAWN_DISTANCE_BIRD = 85;
    const SPAWN_ATTEMPT_LIMIT = 85;
    const GOLDEN_BIRD_CHANCE = 0.08;
    const GOLDEN_BIRD_SCORE = 3;
    const GOLDEN_BIRD_BOOST_DURATION = 4.3 * 60;
    const DOG_ENRAGE_DURATION = 3.9 * 60;
    const DOG_ENRAGE_RANGE = 285;
    const DOG_ENRAGE_SPEED_MULTIPLIER = 1.53;
    const COMBO_TIMEOUT_FRAMES = 2.7 * 60;
    const COMBO_BONUS_THRESHOLD = 3;
    const COMBO_MAX_BONUS_POINTS = 2;
    const LINE_OF_SIGHT_CHECK_INTERVAL = 11;
    const RELOCATE_OFFSET = 16.5;
    const RELOCATE_ATTEMPTS = 21;
    const RELOCATE_FINAL_PUSH = 12.5;
    const DOG_SEPARATION_DISTANCE = 57;
    const DOG_SEPARATION_FORCE = 0.76;
    const LEVEL_TRANSITION_DURATION = 2.7 * 60;
    const DASH_DURATION = 0.41 * 60;
    const DASH_COOLDOWN = 2.25 * 60;
    const DASH_SPEED_MULTIPLIER = 2.05;
    const DOG_STUN_DURATION = 5.9 * 60;
    const DOG_WALL_HIT_DAZE_DURATION = 0.78 * 60;
    const DOG_DAZE_SLOW_FACTOR = 0.39;
    const DOG_WANDER_TIMER_MAX = 4.9 * 60;
    const DOG_WANDER_RADIUS = 152;
    const DOG_DETECTION_RANGE = 355;
    const DOG_LOS_LOST_PERSISTENCE = 1.35 * 60;
    const LOW_TIME_WARNING = 1.75 * 60;
    const GAME_SPEED_MULTIPLIER = 0.75;

    const BOSS_MAX_HEALTH = 28;
    const BOSS_BIRD_DAMAGE = 1;
    const BOSS_GOLDEN_BIRD_DAMAGE_MULTIPLIER = 3;
    const BOSS_ARENA_BIRD_SPAWN_INTERVAL = 6.8 * 60;
    const BOSS_ARENA_GOLDEN_BIRD_CHANCE = 0.15;
    const BOSS_PROJECTILE_DAMAGE = 15;
    const BOSS_STOMP_DAMAGE = 22;
    const BOSS_STOMP_WAVE_SPEED = 5.5 * GAME_SPEED_MULTIPLIER;
    const BOSS_BARK_PUSH_FORCE = 18;
    const BOSS_BARK_WAVE_SPEED = 6.0 * GAME_SPEED_MULTIPLIER;
    const BOSS_BARK_PARTICLE_SPEED = 7.5 * GAME_SPEED_MULTIPLIER;
    const BOSS_CONTACT_DAMAGE = 12;


    const PickupType = { HEALTH: 'health', SPEED_BOOST: 'speed_boost', INVINCIBILITY: 'invincibility', DOG_SLOW: 'dog_slow', DOG_STUN: 'dog_stun' };
    const DogAiType = { CHASER: 'chaser', AMBUSHER: 'ambusher', SKITTISH: 'skittish' };
    const BirdType = { NORMAL: 'normal', GOLDEN: 'golden' };
    const DogState = { IDLE_WANDER: 'wander', CHASING: 'chasing', FLEEING: 'fleeing', AMBUSHING: 'ambushing', STUNNED: 'stunned', DAZED: 'dazed', DETOURING: 'detouring' };
    const BossState = { IDLE: 'idle', CHARGE_WINDUP: 'charge_windup', CHARGING: 'charging', STOMP_WINDUP: 'stomp_windup', STOMPING: 'stomping', SPIT_WINDUP: 'spit_windup', SPITTING: 'spitting', BARK_WINDUP: 'bark_windup', BARKING: 'barking', VULNERABLE: 'vulnerable', HIT_REACTION: 'hit_reaction', DEFEATED: 'defeated', PHASE_TRANSITION: 'phase_transition' };
    const ObstacleType = {
        RECT: 'rect', TREE: 'tree', BENCH: 'bench', LAMP: 'lamp', BUSH: 'bush', HOUSE: 'house',
        ROCK: 'rock', LAVA_ROCK: 'lava_rock', SNOW_DRIFT: 'snow_drift',
        ICE_SPIKE: 'ice_spike', PIPE: 'pipe', CRATE: 'crate', BARREL: 'barrel',
        JUNGLE_VINE: 'jungle_vine', PRISON_BARS: 'prison_bars', FURNITURE: 'furniture',
        CRYSTAL: 'crystal', MUSHROOM: 'mushroom', RUINS: 'ruins',
        VOLCANO: 'volcano', FOSSIL: 'fossil', SCRAP_METAL: 'scrap_metal', ICE_WALL: 'ice_wall', BONES: 'bones', CACTUS: 'cactus', FALLEN_LOG: 'fallen_log',
        GRASS: 'grass', PUDDLE: 'puddle', LAVA_POOL: 'lava_pool', PEBBLES: 'pebbles', GRAVEL: 'gravel', MOSS: 'moss', ASH: 'ash', SMALL_CRYSTALS: 'small_crystals', GLOW_WORMS: 'glow_worms', SAND: 'sand', SNOW_PATCH: 'snow_patch',
        ARENA_PILLAR: 'arena_pillar', ARENA_WALL: 'arena_wall'
    };

    const PICKUP_DURATIONS = { [PickupType.SPEED_BOOST]: 5.1 * 60, [PickupType.INVINCIBILITY]: 6.1 * 60, [PickupType.DOG_SLOW]: 7.1 * 60, };
    const PICKUP_WEIGHTS = { [PickupType.HEALTH]: 37, [PickupType.SPEED_BOOST]: 27, [PickupType.DOG_SLOW]: 17, [PickupType.DOG_STUN]: 11, [PickupType.INVINCIBILITY]: 8 };
    const totalPickupWeight = Object.values(PICKUP_WEIGHTS).reduce((sum, weight) => sum + weight, 0);

    let cat, bird, dogs, obstacles = [], nonCollidingDecor = [], particles, pickups, score, level, gameOver, gameWon, gamePaused, keys = {};
    let frameCount = 0, lastTime = 0, pickupSpawnTimer = 0;
    let corners = [];
    let screenShakeIntensity = 0, screenShakeDuration = 0;
    let comboCounter = 0, comboTimer = 0;
    let isLevelTransitioning = false; let transitionTimer = 0;
    let ambientParticleTimer = 0;
    let lastCatMoveDx = 0, lastCatMoveDy = 0;
    let currentBiome = null;
    let boss = null;
    let projectiles = [];
    let startTime = 0, elapsedTime = 0;
    let arenaBirdSpawnTimer = 0;
    let bossAttackWave = { active: false, type: null, radius: 0, angle: 0, spread: 0, timer: 0, speed: 0, startRadius: 0 };
    let fadingToWinScreen = false; let winFadeTimer = 0; const WIN_FADE_DURATION = 90;
    let isGodModeActive = false;


    function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
    function distance(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }
    function getRandomElement(arr) { if (!arr || arr.length === 0) return null; return arr[Math.floor(Math.random() * arr.length)]; }
    function clamp(value, min, max) { return Math.max(min, Math.min(value, max)); }
    function getRandomColor(hueStart, hueEnd, saturation, lightness, alpha = 1) { const hue = getRandomInt(hueStart, hueEnd); return `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`; }
    function checkRectCollision(r1, r2) { return r1.x < r2.x + r2.width && r1.x + r1.width > r2.x && r1.y < r2.y + r2.height && r1.y + r1.height > r2.y; }
    function formatTime(ms) { const totalSeconds = Math.floor(ms / 1000); const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; }

     const biomes = [
        { name: "Prostorná Louka", levelRange: [1, 1], bgColor: ['#d4f7d4', '#c2f0c2', '#b0e8b0', '#c2f0c2', '#d4f7d4'], obstacleTypes: [ObstacleType.BUSH, ObstacleType.TREE, ObstacleType.BENCH, ObstacleType.ROCK], decorTypes: [ObstacleType.GRASS, ObstacleType.PEBBLES], propColors: { bush: [70, 130, 50, 35], treeLeaf: [80, 140, 60, 45], treeTrunk: [20, 40, 50, 35], bench: [30, 50, 40, 50], rock: [0, 0, 55, 70], pebbles: [0,0,70,85,0.6], grass: [90, 120, 65, 55] }, ambientParticleType: 'leaf', maxDogs: 6, dogBaseSpeedMult: 1.0, pickupSpawnTimeFactor: 1.0 },
        { name: "Hustý Les", levelRange: [2, 2], bgColor: ['#a0d9a0', '#8cc98c', '#78b978', '#8cc98c', '#a0d9a0'], obstacleTypes: [ObstacleType.TREE, ObstacleType.BUSH, ObstacleType.ROCK, ObstacleType.MUSHROOM, ObstacleType.FALLEN_LOG], decorTypes: [ObstacleType.GRASS, ObstacleType.MOSS, ObstacleType.PEBBLES], propColors: { bush: [70, 120, 45, 30], treeLeaf: [80, 130, 55, 35], treeTrunk: [20, 40, 55, 30], rock: [0, 0, 15, 45], moss: [80,140,40,50,0.7], mushroomCap: [0, 30, 70, 55], mushroomStem: [0, 0, 85, 90], fallenLog: [30, 45, 35, 25], pebbles: [10, 30, 50, 60, 0.5], grass: [95, 125, 50, 45] }, ambientParticleType: 'spore', maxDogs: 7, dogBaseSpeedMult: 1.05, pickupSpawnTimeFactor: 1.0 },
        { name: "Rušné Město", levelRange: [3, 3], bgColor: ['#d1d1d1', '#c2c2c2', '#b3b3b3', '#c2c2c2', '#d1d1d1'], obstacleTypes: [ObstacleType.HOUSE, ObstacleType.BENCH, ObstacleType.LAMP, ObstacleType.CRATE, ObstacleType.PIPE, ObstacleType.SCRAP_METAL, ObstacleType.BARREL], decorTypes: [ObstacleType.GRAVEL, ObstacleType.PUDDLE], propColors: { houseWall: [20, 50, 40, 65], houseRoof: [0, 30, 50, 40], bench: [30, 50, 40, 50], lamp: [200, 240, 15, 30], crate: [30, 45, 50, 45], pipe: [0, 0, 20, 40], gravel: [0,0,50,60,0.7], scrap: [190, 220, 20, 40], barrel: [20, 40, 45, 40], puddle: [180, 210, 30, 50] }, ambientParticleType: 'dust', maxDogs: 7, dogBaseSpeedMult: 1.1, pickupSpawnTimeFactor: 1.0 },
        { name: "Spálená Poušť", levelRange: [4, 4], bgColor: ['#f7e8c3', '#f5ddaa', '#f2d191', '#f5ddaa', '#f7e8c3'], obstacleTypes: [ObstacleType.ROCK, ObstacleType.CACTUS, ObstacleType.BONES, ObstacleType.RUINS, ObstacleType.FOSSIL], decorTypes: [ObstacleType.SAND, ObstacleType.PEBBLES], propColors: { rock: [25, 45, 30, 60], cactus: [80, 140, 50, 40], bones: [30, 40, 80, 90], ruins: [30, 40, 40, 50], sand: [40, 50, 75, 85, 0.5], pebbles: [30, 40, 60, 70, 0.6], fossil: [35, 50, 60, 70] }, ambientParticleType: 'sand', maxDogs: 8, dogBaseSpeedMult: 1.15, pickupSpawnTimeFactor: 1.1 },
        { name: "Divoká Džungle", levelRange: [5, 5], bgColor: ['#77dd77', '#5cb85c', '#4cae4c', '#5cb85c', '#77dd77'], obstacleTypes: [ObstacleType.TREE, ObstacleType.BUSH, ObstacleType.JUNGLE_VINE, ObstacleType.ROCK, ObstacleType.RUINS, ObstacleType.FALLEN_LOG], decorTypes: [ObstacleType.GRASS, ObstacleType.MOSS, ObstacleType.PUDDLE], propColors: { treeLeaf: [90, 150, 70, 40], treeTrunk: [25, 45, 60, 30], bush: [80, 140, 65, 35], rock: [90, 120, 25, 40], vine: [90, 130, 60, 30], moss: [80,140,40,50,0.7], ruins: [80, 100, 30, 40], grass: [100, 130, 60, 50], puddle: [160, 190, 40, 55], fallenLog: [25, 40, 40, 30] }, ambientParticleType: 'leaf_heavy', maxDogs: 8, dogBaseSpeedMult: 1.2, pickupSpawnTimeFactor: 0.95 },
        { name: "Ledová Planina", levelRange: [6, 6], bgColor: ['#e8f4f8', '#d6ebf2', '#c4e1ec', '#d6ebf2', '#e8f4f8'], obstacleTypes: [ObstacleType.SNOW_DRIFT, ObstacleType.ICE_SPIKE, ObstacleType.ROCK, ObstacleType.ICE_WALL, ObstacleType.FOSSIL], decorTypes: [ObstacleType.SNOW_PATCH, ObstacleType.PEBBLES], propColors: { snow: [190, 220, 80, 95], ice: [180, 210, 70, 85], rock: [200, 230, 30, 55], iceWall: [180, 210, 65, 80], fossil: [200, 230, 50, 60], snowPatch: [190, 220, 85, 98, 0.6], pebbles: [190, 220, 60, 75, 0.5] }, ambientParticleType: 'snow', maxDogs: 9, dogBaseSpeedMult: 1.25, pickupSpawnTimeFactor: 1.0 },
        { name: "Krystalová Jeskyně", levelRange: [7, 7], bgColor: ['#4b0082', '#5a2d82', '#6a4092', '#5a2d82', '#4b0082'], obstacleTypes: [ObstacleType.ROCK, ObstacleType.CRYSTAL, ObstacleType.MUSHROOM, ObstacleType.PIPE], decorTypes: [ObstacleType.PEBBLES, ObstacleType.SMALL_CRYSTALS, ObstacleType.GLOW_WORMS, ObstacleType.PUDDLE], propColors: { rock: [240, 280, 15, 30], crystal: [240, 300, 70, 75], mushroomCap: [260, 320, 60, 50], mushroomStem: [0, 0, 70, 80], pebbles: [240, 280, 40, 50, 0.6], smallCrystal: [240, 300, 75, 85, 0.7], glowWorm: [60, 80, 80, 90, 0.9], pipe: [230, 260, 25, 35], puddle: [240, 280, 35, 50] }, ambientParticleType: 'crystal_dust', maxDogs: 8, dogBaseSpeedMult: 1.25, pickupSpawnTimeFactor: 0.9 },
        { name: "Studené Vězení", levelRange: [8, 8], bgColor: ['#7d8c8c', '#6f7d7d', '#616e6e', '#6f7d7d', '#7d8c8c'], obstacleTypes: [ObstacleType.PRISON_BARS, ObstacleType.PIPE, ObstacleType.BENCH, ObstacleType.CRATE, ObstacleType.SCRAP_METAL, ObstacleType.FURNITURE], decorTypes: [ObstacleType.PUDDLE, ObstacleType.GRAVEL, ObstacleType.PEBBLES], propColors: { bars: [0, 0, 10, 30], pipe: [0, 0, 15, 35], bench: [0, 0, 20, 40], crate: [30, 45, 40, 40], puddle: [180, 210, 30, 50], gravel: [0,0,45,55,0.6], scrap: [190, 220, 25, 45], furniture: [0, 0, 30, 45], pebbles: [0, 0, 40, 50, 0.6] }, ambientParticleType: 'dust_heavy', maxDogs: 9, dogBaseSpeedMult: 1.30, pickupSpawnTimeFactor: 1.0 },
        { name: "Pekelná Sopka", levelRange: [9, 9], bgColor: ['#5c3a3a', '#4a2e2e', '#382323', '#4a2e2e', '#5c3a3a'], obstacleTypes: [ObstacleType.LAVA_ROCK, ObstacleType.ROCK, ObstacleType.VOLCANO, ObstacleType.BONES, ObstacleType.PIPE], decorTypes: [ObstacleType.LAVA_POOL, ObstacleType.ASH, ObstacleType.GRAVEL], propColors: { lavaRock: [0, 20, 60, 35], rock: [0, 0, 10, 25], volcano: [0, 15, 20, 30], bones: [10, 30, 40, 50], lavaPool: [25, 50, 60, 55], ash: [0,0,15,25,0.7], pipe: [10, 30, 20, 30], gravel: [0, 10, 30, 40, 0.6] }, ambientParticleType: 'ember', maxDogs: 10, dogBaseSpeedMult: 1.30, pickupSpawnTimeFactor: 1.1 },
        { name: "Tajemné Podzemí", levelRange: [10, 10], bgColor: ['#6b6b6b', '#5a5a5a', '#494949', '#5a5a5a', '#6b6b6b'], obstacleTypes: [ObstacleType.ROCK, ObstacleType.PIPE, ObstacleType.BARREL, ObstacleType.FOSSIL, ObstacleType.MUSHROOM, ObstacleType.CRYSTAL], decorTypes: [ObstacleType.PUDDLE, ObstacleType.GRAVEL, ObstacleType.GLOW_WORMS, ObstacleType.SMALL_CRYSTALS], propColors: { rock: [0, 0, 15, 35], pipe: [0, 0, 20, 40], barrel: [20, 40, 45, 40], fossil: [30, 50, 55, 65], puddle: [180, 210, 30, 50], gravel: [0,0,40,50,0.6], mushroomCap: [200, 240, 40, 35], mushroomStem: [0, 0, 60, 70], glowWorm: [90, 120, 70, 80, 0.8], crystal: [180, 240, 50, 60], smallCrystal: [180, 240, 60, 70, 0.6] }, ambientParticleType: 'mote_dense', maxDogs: 10, dogBaseSpeedMult: 1.35, pickupSpawnTimeFactor: 1.0 },
        { name: "Aréna Bosse", levelRange: [11, 11], isBossLevel: true, bgColor: ['#441111', '#330000', '#220000', '#330000', '#441111'], obstacleTypes: [ObstacleType.ARENA_PILLAR, ObstacleType.ARENA_WALL], decorTypes: [ObstacleType.ASH, ObstacleType.LAVA_POOL, ObstacleType.GRAVEL, ObstacleType.BONES], propColors: { pillar: [0, 0, 15, 25], wall: [0, 0, 10, 20], lavaPool: [25, 50, 60, 55], ash: [0,0,10,20,0.7], gravel: [0, 0, 15, 25, 0.5], bones: [10, 25, 30, 40] }, ambientParticleType: 'shadow_flicker', maxDogs: 0, dogBaseSpeedMult: 1.0, pickupSpawnTimeFactor: 999 }
    ];

    function getBiomeForLevel(level) {
        const biome = biomes.find(b => level >= b.levelRange[0] && level <= b.levelRange[1]);
        if (biome) return biome;

        const baseBiomeIndex = (level - 1) % (biomes.length - 1);
        let adjustedBiome = { ...biomes[baseBiomeIndex] };
        adjustedBiome.levelRange = [level, level];
        adjustedBiome.dogBaseSpeedMult = Math.min(1.8, 1.0 + (level * 0.035));
        adjustedBiome.pickupSpawnTimeFactor = Math.max(0.75, 1.0 - (level * 0.008));
        adjustedBiome.maxDogs = Math.min(MAX_DOGS, 6 + Math.floor(level / 3));
        adjustedBiome.name = `${adjustedBiome.name} Mk ${Math.floor((level-1)/(biomes.length -1)) + 1}`
        console.log(`Level ${level} falling back to adjusted biome: ${adjustedBiome.name} based on index ${baseBiomeIndex}`);
        return adjustedBiome;
    }

    function checkWallCollision(x, y, w, h) { if (x < WALL_BUFFER || x + w > canvas.width - WALL_BUFFER || y < WALL_BUFFER || y + h > canvas.height - WALL_BUFFER) { return { boundary: true, x: x < WALL_BUFFER ? 0 : canvas.width, y: y < WALL_BUFFER ? 0 : canvas.height, width: 1, height: 1, baseColor:'#a89a8e' }; } for (const o of obstacles) { if (checkRectCollision( { x: x, y: y, width: w, height: h }, { x: o.x - OBSTACLE_BUFFER, y: o.y - OBSTACLE_BUFFER, width: o.width + OBSTACLE_BUFFER * 2, height: o.height + OBSTACLE_BUFFER * 2 }) ) { return o; } } return null; }
    function hasLineOfSight(sx, sy, tx, ty, checkWidth = 1) { const dx = tx - sx, dy = ty - sy; const dist = Math.sqrt(dx * dx + dy * dy); if (dist === 0) return true; const stepX = dx / dist, stepY = dy / dist; const numSteps = Math.ceil(dist/5);
        for (let i = 1; i < numSteps; i++) { const checkX = sx + stepX * i*5; const checkY = sy + stepY * i*5; if (checkWallCollision(checkX - checkWidth / 2, checkY - checkWidth / 2, checkWidth, checkWidth)) { return false; } } return true; }
    function relocateIfStuck(entity, forceRelocate = false){ let attempts=0; const entW = entity.width || PICKUP_SIZE; const entH = entity.height || PICKUP_SIZE; let collidedWith = checkWallCollision(entity.x, entity.y, entW, entH); let entityName = entity.type || entity.constructor?.name || 'entity'; if (!collidedWith && !forceRelocate) { entity.x=clamp(entity.x,WALL_BUFFER,canvas.width - entW - WALL_BUFFER); entity.y=clamp(entity.y,WALL_BUFFER,canvas.height - entH - WALL_BUFFER); return; } while(collidedWith && attempts < RELOCATE_ATTEMPTS){ attempts++; let moved=false; const offsets=[{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0},{dx:-1,dy:-1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:1,dy:1},{dx:0,dy:-2},{dx:0,dy:2},{dx:-2,dy:0},{dx:2,dy:0}, {dx:-2, dy:-2}, {dx:2, dy:-2}, {dx:-2, dy:2}, {dx:2, dy:2}]; for(const offset of offsets){ const tryX=entity.x+offset.dx*RELOCATE_OFFSET*(1+attempts/5); const tryY=entity.y+offset.dy*RELOCATE_OFFSET*(1+attempts/5); if(!checkWallCollision(tryX, tryY, entW, entH)){ entity.x=clamp(tryX,WALL_BUFFER,canvas.width - entW - WALL_BUFFER); entity.y=clamp(tryY,WALL_BUFFER,canvas.height - entH - WALL_BUFFER); collidedWith=null; moved=true; break; } } if (!moved) { collidedWith = checkWallCollision(entity.x, entity.y, entW, entH); } else { collidedWith = null; } } collidedWith = checkWallCollision(entity.x, entity.y, entW, entH); if(collidedWith){ console.warn(`Relocate still stuck for ${entityName} after ${attempts} attempts! Applying final push.`); let pushX = entity.x + entW/2 - (collidedWith.x + collidedWith.width/2); let pushY = entity.y + entH/2 - (collidedWith.y + collidedWith.height/2); let pushMag = Math.sqrt(pushX*pushX + pushY*pushY) || 1; let finalPushX = entity.x + (pushX / pushMag) * RELOCATE_FINAL_PUSH; let finalPushY = entity.y + (pushY / pushMag) * RELOCATE_FINAL_PUSH; if (!checkWallCollision(finalPushX, finalPushY, entW, entH)) { entity.x = clamp(finalPushX, WALL_BUFFER, canvas.width - entW - WALL_BUFFER); entity.y = clamp(finalPushY, WALL_BUFFER, canvas.height - entH - WALL_BUFFER); } else { console.error(`CRITICAL: Relocate FAIL for ${entityName} even after final push! Forcing corner spawn.`); const safePos = findSafeSpawnLocation(entW, entH, 0, [cat, boss, ...dogs, ...pickups, ...obstacles]); if (safePos) { entity.x = safePos.x; entity.y = safePos.y; } else { entity.x = WALL_BUFFER + 15 + Math.random()*10; entity.y = WALL_BUFFER + 15 + Math.random()*10; console.error("No safe spot found AT ALL!"); } } } else { entity.x=clamp(entity.x, WALL_BUFFER, canvas.width - entW - WALL_BUFFER); entity.y=clamp(entity.y, WALL_BUFFER, canvas.height - entH - WALL_BUFFER); } }
    function findSafeSpawnLocation(width, height, minDistFromCat = 0, avoidEntities = []) { let x, y, attempts = 0, valid = false; const halfW = width / 2, halfH = height / 2; while (!valid && attempts < SPAWN_ATTEMPT_LIMIT) { attempts++; x = getRandomInt(WALL_BUFFER, canvas.width - width - WALL_BUFFER); y = getRandomInt(WALL_BUFFER, canvas.height - height - WALL_BUFFER); if (checkWallCollision(x, y, width, height)) continue; if (minDistFromCat > 0 && cat && distance(x + halfW, y + halfH, cat.x + cat.width / 2, cat.y + cat.height / 2) < minDistFromCat) continue; let tooClose = false; const allAvoid = [...obstacles, ...avoidEntities.filter(e => e && e !== cat)]; for (const entity of allAvoid) { if (!entity) continue; const entityX = entity.x ?? 0; const entityY = entity.y ?? 0; const entityW = entity.width || PICKUP_SIZE; const entityH = entity.height || PICKUP_SIZE; const entityHalfW = entityW / 2; const entityHalfH = entityH / 2; const requiredDist = halfW + entityHalfW + 12;
                if (distance(x + halfW, y + halfH, entityX + entityHalfW, entityY + entityHalfH) < requiredDist) { tooClose = true; break; } } if (tooClose) continue; valid = true; } if (valid) { return { x: x, y: y }; } else { console.warn(`Failed to find safe spawn for ${width}x${height} after ${attempts} attempts. Trying corner.`); const corner = getRandomElement(corners) || { x: WALL_BUFFER + 1, y: WALL_BUFFER + 1 }; x = clamp(corner.x + (Math.random() - 0.5) * 45, WALL_BUFFER, canvas.width - width - WALL_BUFFER); y = clamp(corner.y + (Math.random() - 0.5) * 45, WALL_BUFFER, canvas.height - height - WALL_BUFFER); if (checkWallCollision(x, y, width, height)) { x = WALL_BUFFER + 10; y = WALL_BUFFER + 10; if(checkWallCollision(x,y,width,height)) { x= canvas.width-width-WALL_BUFFER-10; y = WALL_BUFFER + 10; } if(checkWallCollision(x,y,width,height)) { x= WALL_BUFFER + 10; y = canvas.height-height-WALL_BUFFER-10; } if(checkWallCollision(x,y,width,height)) { x= canvas.width-width-WALL_BUFFER-10; y = canvas.height-height-WALL_BUFFER-10; } if(checkWallCollision(x,y,width,height)) { console.error("CRITICAL: All corners blocked for spawning!"); return null; } } return { x: x, y: y }; } }

    function createRectangleShape(x, y, width, height, color, rotation = 0) { return { type: 'rect', x, y, width, height, color, rotation }; }
    function createCircleShape(x, y, radius, color) { return { type: 'circle', x, y, radius, color }; }
    function createPolygonShape(points, color) { return { type: 'poly', points, color }; }
    function generateTreeShapes(width, height, colors) { const shapes = []; const trunkWidth = width * (0.2 + Math.random() * 0.15); const trunkHeight = height * (0.5 + Math.random() * 0.2); const trunkX = (width - trunkWidth) / 2; const trunkColorParams = colors.treeTrunk || [20, 40, 50, 35]; const trunkColor = getRandomColor(...trunkColorParams); const darkTrunkColor = `hsl(${trunkColorParams[0]}, ${trunkColorParams[1]}%, ${trunkColorParams[3] - 15}%)`; shapes.push(createRectangleShape(trunkX, height - trunkHeight, trunkWidth, trunkHeight, darkTrunkColor)); shapes.push(createRectangleShape(trunkX + trunkWidth*0.1, height - trunkHeight, trunkWidth*0.8, trunkHeight, trunkColor)); const leavesY = 0; const leavesHeight = height - trunkHeight * 0.8; const leafColorParams = colors.treeLeaf || [80, 140, 60, 45]; const numLeafClusters = getRandomInt(8, 12); for (let i = 0; i < numLeafClusters; i++) { const clusterRadius = (width / 1.8) * (0.25 + Math.random() * 0.5); const clusterX = width * (0.05 + Math.random() * 0.9); const clusterY = leavesY + leavesHeight * (0.05 + Math.random() * 0.9); const leafColor = getRandomColor(leafColorParams[0], leafColorParams[1], leafColorParams[2], getRandomInt(leafColorParams[3] - 8, leafColorParams[3] + 8)); shapes.push(createCircleShape(clusterX, clusterY, clusterRadius, leafColor)); } shapes.push(createRectangleShape(trunkX + trunkWidth*0.1, height - trunkHeight*0.9, trunkWidth*0.8, 5, `rgba(255,255,255,0.1)`)); shapes.push(createRectangleShape(trunkX + trunkWidth*0.1, height - 5, trunkWidth*0.8, 5, `rgba(0,0,0,0.15)`)); return shapes; }
    function generateBenchShapes(width, height, colors) { const shapes = []; const legWidth = width * 0.1; const legHeight = height * 0.5; const plankHeight = height * 0.1; const numPlanks = 3; const backPlanks = Math.random() < 0.75 ? 2 : 0; const totalSeatHeight = plankHeight * numPlanks + plankHeight * (numPlanks - 1) * 0.1; const benchColorParams = colors.bench || [30, 50, 40, 50]; const benchColor = getRandomColor(...benchColorParams); const darkBenchColor = `hsl(${benchColorParams[0]}, ${benchColorParams[1]}%, ${benchColorParams[3] - 18}%)`; shapes.push(createRectangleShape(legWidth * 0.5, height - legHeight, legWidth, legHeight, darkBenchColor)); shapes.push(createRectangleShape(width - legWidth * 1.5, height - legHeight, legWidth, legHeight, darkBenchColor)); let currentY = height - legHeight; for (let i = 0; i < numPlanks; i++) { shapes.push(createRectangleShape(0, currentY, width, plankHeight, darkBenchColor)); shapes.push(createRectangleShape(width * 0.03, currentY + 2, width * 0.94, plankHeight - 4, benchColor)); currentY -= plankHeight * 1.1; } if (backPlanks > 0) { const backSupportHeight = legHeight + totalSeatHeight * 0.5; const supportY = height - legHeight - backSupportHeight; shapes.push(createRectangleShape(legWidth * 0.5, supportY, legWidth, backSupportHeight, darkBenchColor)); shapes.push(createRectangleShape(width - legWidth * 1.5, supportY, legWidth, backSupportHeight, darkBenchColor)); currentY = supportY + plankHeight; for (let i = 0; i < backPlanks; i++) { shapes.push(createRectangleShape(0, currentY, width, plankHeight, darkBenchColor)); shapes.push(createRectangleShape(width * 0.03, currentY + 2, width * 0.94, plankHeight - 4, benchColor)); currentY += plankHeight * 1.1; } } return shapes; }
    function generateLampShapes(width, height, colors) { const shapes = []; const poleWidth = width * 0.12; const poleHeight = height * 0.85; const baseRadius = width * 0.25; const baseHeight = height * 0.06; const lightHousingRadius = width * 0.28; const armLength = width * 0.45; const lampColorParams = colors.lamp || [200, 240, 15, 30]; const lampColor = getRandomColor(...lampColorParams); const darkLampColor = `hsl(${lampColorParams[0]}, ${lampColorParams[1]}%, ${lampColorParams[3] - 12}%)`; const bulbColor = '#fff5cc'; const poleX = (width - poleWidth) / 2; const poleTopY = height - baseHeight - poleHeight; shapes.push(createCircleShape(width/2, height - baseHeight/2, baseRadius, darkLampColor)); shapes.push(createCircleShape(width/2, height - baseHeight*1.5, baseRadius*0.8, lampColor)); shapes.push(createRectangleShape(poleX, poleTopY, poleWidth, poleHeight, darkLampColor)); shapes.push(createRectangleShape(poleX + poleWidth * 0.1, poleTopY, poleWidth * 0.8, poleHeight, lampColor)); shapes.push(createRectangleShape(poleX - poleWidth*0.2, poleTopY + poleHeight*0.7, poleWidth*1.4, poleHeight*0.03, darkLampColor)); shapes.push(createRectangleShape(poleX - poleWidth*0.2, poleTopY + poleHeight*0.2, poleWidth*1.4, poleHeight*0.03, darkLampColor)); const armAngle = -20; const armStartX = poleX + poleWidth / 2; const armStartY = poleTopY; shapes.push(createRectangleShape(armStartX - poleWidth*0.4, armStartY, armLength, poleWidth*0.8, darkLampColor, armAngle)); shapes.push(createRectangleShape(armStartX - poleWidth*0.4 + 2, armStartY + 1, armLength*0.9 - 4, poleWidth*0.6 - 2, lampColor, armAngle)); const armEndX = armStartX + armLength * Math.cos(armAngle * Math.PI / 180); const armEndY = armStartY + armLength * Math.sin(armAngle * Math.PI / 180); const housingY = armEndY - lightHousingRadius*0.4; shapes.push(createCircleShape(armEndX, housingY, lightHousingRadius, darkLampColor)); shapes.push(createCircleShape(armEndX, housingY, lightHousingRadius*0.8, lampColor)); shapes.push(createCircleShape(armEndX, housingY, lightHousingRadius * 0.6, bulbColor)); return shapes; }
    function generateBushShapes(width, height, colors) { const shapes = []; const numClusters = getRandomInt(9, 13); const baseColorParams = colors.bush || [70, 130, 50, 30]; for (let i = 0; i < numClusters; i++) { const clusterRadius = (width / 1.8) * (0.28 + Math.random() * 0.5); const clusterX = width * (Math.random() * 0.9 + 0.05); const clusterY = height * (Math.random() * 0.8 + 0.15); const bushColor = getRandomColor(baseColorParams[0], baseColorParams[1], baseColorParams[2], getRandomInt(baseColorParams[3] - 10, baseColorParams[3] + 10)); shapes.push(createCircleShape(clusterX, clusterY, clusterRadius, bushColor)); } for (let i = 0; i < 3; i++) { const clusterRadius = (width / 2) * (0.2 + Math.random() * 0.35); const clusterX = width * (Math.random() * 0.7 + 0.15); const clusterY = height * (0.1 + Math.random() * 0.55); const bushColor = getRandomColor(baseColorParams[0], baseColorParams[1], baseColorParams[2] + 10, baseColorParams[3] + 15); shapes.push(createCircleShape(clusterX, clusterY, clusterRadius, bushColor)); } return shapes; }
    function generateHouseShapes(width, height, colors) { const shapes = []; const wallColorParams = colors.houseWall || [20, 50, 40, 65]; const wallColor = getRandomColor(...wallColorParams); const wallHighlight = `hsl(${wallColorParams[0]}, ${wallColorParams[1]}%, ${wallColorParams[3] + 10}%)`; const wallShadow = `hsl(${wallColorParams[0]}, ${wallColorParams[1]}%, ${wallColorParams[3] - 15}%)`; const roofColorParams = colors.houseRoof || [0, 30, 50, 40]; const roofColor = getRandomColor(...roofColorParams); const roofHighlight = `hsl(${roofColorParams[0]}, ${roofColorParams[1]}%, ${roofColorParams[3] + 10}%)`; const roofShadow = `hsl(${roofColorParams[0]}, ${roofColorParams[1]}%, ${roofColorParams[3] - 15}%)`; const doorColor = getRandomColor(20, 40, 50, 30); const darkDoorColor = getRandomColor(20, 40, 45, 20); const windowColor = '#aaddff'; const windowFrameColor = '#556'; const roofHeight = height * 0.45; const wallHeight = height - roofHeight; const wallX = 0; const wallY = roofHeight; shapes.push(createRectangleShape(wallX, wallY, width, wallHeight, wallShadow)); shapes.push(createRectangleShape(wallX + 3, wallY, width - 6, wallHeight, wallColor)); shapes.push(createRectangleShape(wallX + 3, wallY, width - 6, 5, wallHighlight)); if (Math.random() > 0.3) { for (let i = 1; i < 5; i++) shapes.push(createRectangleShape(wallX+3, wallY + wallHeight * (i/5), width-6, 1, `rgba(0,0,0,0.07)`)); for (let i = 1; i < 6; i++) shapes.push(createRectangleShape(wallX + width * (i/6), wallY, 1, wallHeight, `rgba(0,0,0,0.07)`)); } shapes.push(createPolygonShape([{x: -5, y: roofHeight+5}, {x: width/2, y: -5}, {x: width+5, y: roofHeight+5}], roofShadow)); shapes.push(createPolygonShape([{x: 0, y: roofHeight}, {x: width/2, y: 0}, {x: width, y: roofHeight}], roofColor)); shapes.push(createPolygonShape([{x: 0, y: roofHeight}, {x: width/2, y: 0}, {x: width*0.45, y: 5}, {x: 0, y: roofHeight-5} ], roofHighlight)); if (width > 50 && Math.random() < 0.75) { const chimneyWidth = width * 0.14; const chimneyHeight = roofHeight * 0.55; const chimneyX = width * (0.6 + Math.random() * 0.2); const chimneyBaseY = roofHeight * (1 - (Math.abs(chimneyX - width/2) / (width/2))); const chimneyTopY = chimneyBaseY - chimneyHeight; shapes.push(createRectangleShape(chimneyX - chimneyWidth/2, chimneyTopY, chimneyWidth, chimneyHeight, roofShadow)); shapes.push(createRectangleShape(chimneyX - chimneyWidth*0.4, chimneyTopY + 2, chimneyWidth*0.8, chimneyHeight-2, roofColor)); shapes.push(createRectangleShape(chimneyX - chimneyWidth*0.6, chimneyTopY - 4, chimneyWidth*1.2, 4, getRandomColor(0,30,40,30))); } const doorWidth = width * 0.28; const doorHeight = wallHeight * 0.65; const doorX = width * 0.15; const doorY = height - doorHeight; shapes.push(createRectangleShape(doorX, doorY, doorWidth, doorHeight, darkDoorColor)); shapes.push(createRectangleShape(doorX + 3, doorY + 3, doorWidth - 6, doorHeight - 6, doorColor)); shapes.push(createCircleShape(doorX + doorWidth*0.8, doorY + doorHeight*0.5, 4, '#666')); shapes.push(createCircleShape(doorX + doorWidth*0.8, doorY + doorHeight*0.5, 3, '#444')); const windowSize = Math.min(width * 0.22, wallHeight * 0.33); const windowX = width * 0.6; const windowY = wallY + wallHeight * 0.25; const frameW = 3; shapes.push(createRectangleShape(windowX - frameW, windowY - frameW, windowSize + 2*frameW, windowSize + 2*frameW, windowFrameColor)); shapes.push(createRectangleShape(windowX, windowY, windowSize, windowSize, windowColor)); shapes.push(createRectangleShape(windowX, windowY + windowSize/2 - frameW/2, windowSize, frameW, windowFrameColor)); shapes.push(createRectangleShape(windowX + windowSize/2 - frameW/2, windowY, frameW, windowSize, windowFrameColor)); shapes.push(createRectangleShape(windowX + 1, windowY + 1, windowSize - 2, windowSize - 2, `rgba(255,255,255,0.25)`)); return shapes; }
    function generateGrassPatchShapes(width, height, colors) { const shapes = []; const numBlades = getRandomInt(8, 14); const grassColorParams = colors.grass || [80, 140, 60, 50]; for (let i = 0; i < numBlades; i++) { const bladeHeight = height * (0.4 + Math.random() * 0.6); const bladeWidth = width * 0.07 * (0.7 + Math.random() * 0.6); const bladeX = width * Math.random(); const bladeY = height - bladeHeight; const angle = (Math.random() - 0.5) * 40; const bladeColor = getRandomColor(grassColorParams[0], grassColorParams[1], grassColorParams[2], getRandomInt(grassColorParams[3]-12, grassColorParams[3]+12)); shapes.push(createRectangleShape(bladeX, bladeY, bladeWidth, bladeHeight, bladeColor, angle)); } return shapes; }
    function generateRockShapes(width, height, colors) { const shapes = []; const rockColorParams = colors.rock || [0, 0, 15, 45]; const baseColor = getRandomColor(...rockColorParams); const highlightColor = `hsla(${rockColorParams[0]}, ${rockColorParams[1]}%, ${rockColorParams[3] + 15}%, 0.7)`; const shadowColor = `hsla(${rockColorParams[0]}, ${rockColorParams[1]}%, ${rockColorParams[3] - 15}%, 0.6)`; const points = []; const numPoints = getRandomInt(5, 7); const centerX = width/2; const centerY = height/2; const avgRadius = Math.min(width, height) / 2 * 0.85; for(let j=0; j<numPoints; j++){ const angle = (j/numPoints) * Math.PI * 2 + (Math.random()-0.5)*0.25; const radius = avgRadius * (0.7 + Math.random()*0.6); points.push({x: centerX + Math.cos(angle)*radius, y: centerY + Math.sin(angle)*radius}); } shapes.push(createPolygonShape(points, shadowColor)); shapes.push(createPolygonShape(points.map(p => ({ x: p.x * 0.97 + centerX * 0.03, y: p.y * 0.97 + centerY * 0.03 })), baseColor)); shapes.push(createPolygonShape(points.map(p => ({ x: p.x * 0.88 + centerX * 0.12, y: p.y * 0.88 + centerY * 0.12 - 2.5 })), highlightColor)); return shapes; }
    function generateLavaRockShapes(width, height, colors) { const shapes = generateRockShapes(width, height, colors); const crackColor = 'hsl(25, 100%, 50%)'; const glowColor = 'hsla(35, 100%, 60%, 0.65)'; const numCracks = getRandomInt(1, 3); for (let i = 0; i < numCracks; i++) { const startX = width * (0.1 + Math.random()*0.8); const startY = height * (0.1 + Math.random()*0.8); const endX = startX + (Math.random() - 0.5) * width * 0.7; const endY = startY + (Math.random() - 0.5) * height * 0.7; const lineWidth = 1.4 + Math.random() * 1.8; shapes.push({ type: 'line', x1: startX, y1: startY, x2: endX, y2: endY, color: glowColor, lineWidth: lineWidth + 1.8 }); shapes.push({ type: 'line', x1: startX, y1: startY, x2: endX, y2: endY, color: crackColor, lineWidth: lineWidth }); } return shapes; }
    function generateSnowDriftShapes(width, height, colors) { const shapes = []; const snowColorParams = colors.snow || [190, 220, 80, 95]; const snowColor = getRandomColor(...snowColorParams); const shadowColor = `hsla(${snowColorParams[0]}, ${snowColorParams[1]-10}%, ${snowColorParams[3]-15}%, 0.7)`; const highlightColor = `hsla(${snowColorParams[0]}, ${snowColorParams[1]+5}%, ${snowColorParams[3]+5}%, 0.5)`; const numLayers = getRandomInt(2, 3); let currentY = height; for (let i = 0; i < numLayers; i++) { const layerHeight = height / numLayers * (0.5 + Math.random() * 0.7); const layerWidth = width * (0.5 + Math.random() * 0.5); const layerX = (width - layerWidth) / 2 + (Math.random()-0.5)*width*0.15; const layerY = currentY - layerHeight; const radius = Math.min(layerWidth, layerHeight)/1.35; shapes.push(createCircleShape(layerX + layerWidth/2, layerY + layerHeight/2 + 5, radius, shadowColor)); shapes.push(createCircleShape(layerX + layerWidth/2, layerY + layerHeight/2, radius, snowColor)); shapes.push(createCircleShape(layerX + layerWidth/2, layerY + layerHeight/2 - 2.5, radius*0.75, highlightColor)); currentY -= layerHeight * 0.25; } return shapes; }
    function generateIceSpikeShapes(width, height, colors) { const shapes = []; const spikeColorParams = colors.ice || [180, 210, 70, 85]; const spikeColor = getRandomColor(...spikeColorParams); const highlightColor = `hsla(${spikeColorParams[0]}, ${spikeColorParams[1]}%, ${spikeColorParams[3] + 18}%, 0.8)`; const shadowColor = `hsla(${spikeColorParams[0]}, ${spikeColorParams[1]}%, ${spikeColorParams[3] - 18}%, 0.65)`; const tipY = height * (0.05 + Math.random()*0.1); const points = [ {x: width/2 + (Math.random()-0.5)*width*0.3, y: tipY}, {x: width*(1+Math.random()*0.1-0.05), y: height*(1+Math.random()*0.1-0.05)}, {x: width*(Math.random()*0.1-0.05), y: height*(1+Math.random()*0.1-0.05)} ]; shapes.push(createPolygonShape(points, shadowColor)); shapes.push(createPolygonShape(points.map(p=>({x:p.x*0.95+width*0.025, y:p.y*0.95+height*0.025})), spikeColor)); shapes.push(createPolygonShape([{x: width/2, y: tipY}, {x: width*0.7, y: height*0.6}, {x: width*0.3, y: height*0.7}].map(p=>({x:p.x*0.9+width*0.05, y:p.y*0.9+height*0.05})), highlightColor)); return shapes; }
    function generatePipeShapes(width, height, colors) { const shapes = []; const pipeColorParams = colors.pipe || [0, 0, 20, 40]; const pipeColor = getRandomColor(...pipeColorParams); const darkPipeColor = `hsl(${pipeColorParams[0]}, ${pipeColorParams[1]}%, ${pipeColorParams[3] - 12}%)`; const lightPipeColor = `hsla(0, 0%, 100%, 0.2)`; const rustColor = getRandomColor(15, 35, 55, 35, 0.28); const isVertical = height > width; if (isVertical) { shapes.push(createRectangleShape(0, 0, width, height, darkPipeColor)); shapes.push(createRectangleShape(width*0.1, 0, width*0.8, height, pipeColor)); shapes.push(createRectangleShape(width*0.2, 0, width*0.6, height, lightPipeColor)); shapes.push(createRectangleShape(width*0.1, 0, width*0.8, height, rustColor)); shapes.push(createRectangleShape(0, 0, width, 8, darkPipeColor)); shapes.push(createRectangleShape(0, height-8, width, 8, darkPipeColor)); } else { shapes.push(createRectangleShape(0, 0, width, height, darkPipeColor)); shapes.push(createRectangleShape(0, height*0.1, width, height*0.8, pipeColor)); shapes.push(createRectangleShape(0, height*0.2, width, height*0.6, lightPipeColor)); shapes.push(createRectangleShape(0, height*0.1, width, height*0.8, rustColor)); shapes.push(createRectangleShape(0, 0, 8, height, darkPipeColor)); shapes.push(createRectangleShape(width-8, 0, 8, height, darkPipeColor)); } return shapes; }
    function generateCrateShapes(width, height, colors) { const shapes = []; const crateColorParams = colors.crate || [30, 45, 50, 45]; const crateColor = getRandomColor(...crateColorParams); const darkCrateColor = `hsl(${crateColorParams[0]}, ${crateColorParams[1]}%, ${crateColorParams[3] - 18}%)`; const lightCrateColor = `hsl(${crateColorParams[0]}, ${crateColorParams[1]}%, ${crateColorParams[3] + 8}%)`; shapes.push(createRectangleShape(0, 0, width, height, darkCrateColor)); shapes.push(createRectangleShape(4, 4, width-8, height-8, crateColor)); const borderWidth = Math.min(width, height) * 0.12; shapes.push(createRectangleShape(0, 0, width, borderWidth, darkCrateColor)); shapes.push(createRectangleShape(0, height - borderWidth, width, borderWidth, darkCrateColor)); shapes.push(createRectangleShape(0, 0, borderWidth, height, darkCrateColor)); shapes.push(createRectangleShape(width - borderWidth, 0, borderWidth, height, darkCrateColor)); shapes.push(createRectangleShape(borderWidth, borderWidth, width - 2*borderWidth, height - 2*borderWidth, `rgba(0,0,0,0.08)`)); shapes.push(createRectangleShape(borderWidth, borderWidth, width - 2*borderWidth, 3, lightCrateColor)); shapes.push(createRectangleShape(borderWidth, borderWidth, 3, height - 2*borderWidth, lightCrateColor)); shapes.push(createRectangleShape(width/2 - 2, borderWidth, 4, height - 2*borderWidth, darkCrateColor)); shapes.push(createRectangleShape(borderWidth, height/2 - 2, width - 2*borderWidth, 4, darkCrateColor)); return shapes; }
    function generateBarrelShapes(width, height, colors) { const shapes = []; const barrelColorParams = colors.barrel || [20, 40, 45, 40]; const barrelColor = getRandomColor(...barrelColorParams); const darkBarrelColor = `hsl(${barrelColorParams[0]}, ${barrelColorParams[1]}%, ${barrelColorParams[3] - 15}%)`; const metalBandColor = '#999'; const darkMetalBandColor = '#777'; const lightMetalBandColor = '#bbb'; shapes.push(createRectangleShape(0, 0, width, height, darkBarrelColor)); shapes.push(createRectangleShape(width*0.05, 0, width*0.9, height, barrelColor)); const bandHeight = height*0.12; shapes.push(createRectangleShape(0, height*0.1, width, bandHeight, darkMetalBandColor)); shapes.push(createRectangleShape(width*0.03, height*0.1+2, width*0.94, bandHeight-4, metalBandColor)); shapes.push(createRectangleShape(width*0.03, height*0.1+2, width*0.94, 2, lightMetalBandColor)); shapes.push(createRectangleShape(0, height*0.8 - bandHeight*0.2, width, bandHeight, darkMetalBandColor)); shapes.push(createRectangleShape(width*0.03, height*0.8 - bandHeight*0.2+2, width*0.94, bandHeight-4, metalBandColor)); shapes.push(createRectangleShape(width*0.03, height*0.8 - bandHeight*0.2+2, width*0.94, 2, lightMetalBandColor)); shapes.push(createRectangleShape(width*0.1, 0, width*0.8, height, `rgba(255,255,255,0.1)`)); shapes.push(createRectangleShape(width*0.2, 0, width*0.6, height, `rgba(0,0,0,0.1)`)); return shapes; }
    function generateJungleVineShapes(width, height, colors) { const shapes = []; const vineColorParams = colors.vine || [90, 130, 60, 30]; const vineColor = getRandomColor(...vineColorParams); const darkVineColor = `hsl(${vineColorParams[0]}, ${vineColorParams[1]}%, ${vineColorParams[3] - 18}%)`; const numSegments = getRandomInt(2, 4); const segmentHeight = height / numSegments; let currentX = width/2; for(let i = 0; i < numSegments; i++) { const nextX = width/2 + (Math.random() - 0.5) * width * 0.75; const lineWidth = 3.2 + Math.random()*3.2; shapes.push({ type: 'line', x1: currentX, y1: i*segmentHeight, x2: nextX, y2: (i+1)*segmentHeight, color: darkVineColor, lineWidth: lineWidth + 1.1 }); shapes.push({ type: 'line', x1: currentX, y1: i*segmentHeight, x2: nextX, y2: (i+1)*segmentHeight, color: vineColor, lineWidth: lineWidth }); currentX = nextX; if (Math.random() < 0.25) { const leafColorParams = colors.treeLeaf || [90, 150, 70, 40]; const leafColor = getRandomColor(leafColorParams[0], leafColorParams[1], leafColorParams[2]-5, leafColorParams[3]-8); const leafSize = 7.0 + Math.random()*4.0; shapes.push(createCircleShape(nextX+(Math.random()-0.5)*10, (i+0.5)*segmentHeight+(Math.random()-0.5)*10, leafSize, leafColor)); } } return shapes; }
    function generatePrisonBarShapes(width, height, colors) { const shapes = []; const barColorParams = colors.bars || [0, 0, 10, 30]; const barColor = getRandomColor(...barColorParams); const darkBarColor = `hsl(${barColorParams[0]}, ${barColorParams[1]}%, ${barColorParams[3] - 10}%)`; const lightBarColor = `hsla(0, 0%, 100%, 0.15)`; const rustColor = getRandomColor(15, 30, 40, 25, 0.38); const numBars = Math.max(3, Math.floor(width / 23)); const barWidth = 6.0; const spacing = (width - numBars * barWidth) / (numBars + 1); for(let i = 0; i < numBars; i++) { const x = spacing + i * (spacing + barWidth); shapes.push(createRectangleShape(x, 0, barWidth, height, darkBarColor)); shapes.push(createRectangleShape(x+1, 0, barWidth-2, height, barColor)); shapes.push(createRectangleShape(x+1, 0, barWidth*0.4, height, lightBarColor)); shapes.push(createRectangleShape(x+1, 0, barWidth-2, height, rustColor)); } const frameH = barWidth*1.8; shapes.push(createRectangleShape(0, 0, width, frameH, darkBarColor)); shapes.push(createRectangleShape(0, height - frameH, width, frameH, darkBarColor)); shapes.push(createRectangleShape(0, 2, width, frameH-4, barColor)); shapes.push(createRectangleShape(0, height - frameH+2, width, frameH-4, barColor)); shapes.push(createRectangleShape(0, 2, width, frameH-4, rustColor)); shapes.push(createRectangleShape(0, height - frameH+2, width, frameH-4, rustColor)); return shapes; }
    function generateFurnitureShapes(width, height, colors) { const shapes = []; const furnitureColorParams = colors.furniture || [20, 50, 50, 60]; const furnitureColor = getRandomColor(...furnitureColorParams); const darkFurnitureColor = `hsl(${furnitureColorParams[0]}, ${furnitureColorParams[1]}%, ${furnitureColorParams[3] - 18}%)`; const lightFurnitureColor = `hsl(${furnitureColorParams[0]}, ${furnitureColorParams[1]}%, ${furnitureColorParams[3] + 12}%)`; const legHeight = height*0.18; const bodyHeight = height - legHeight; shapes.push(createRectangleShape(0, 0, width, bodyHeight, darkFurnitureColor)); shapes.push(createRectangleShape(4, 4, width-8, bodyHeight-8, furnitureColor)); shapes.push(createRectangleShape(4, 4, width-8, 5, lightFurnitureColor)); shapes.push(createRectangleShape(width*0.1, bodyHeight, width*0.15, legHeight, darkFurnitureColor)); shapes.push(createRectangleShape(width*0.75, bodyHeight, width*0.15, legHeight, darkFurnitureColor)); if (Math.random() < 0.30) { const handleSize = 4.2; shapes.push(createCircleShape(width*0.3, bodyHeight*0.5, handleSize, darkFurnitureColor)); shapes.push(createCircleShape(width*0.7, bodyHeight*0.5, handleSize, darkFurnitureColor)); shapes.push(createCircleShape(width*0.3, bodyHeight*0.5, handleSize*0.7, lightFurnitureColor)); shapes.push(createCircleShape(width*0.7, bodyHeight*0.5, handleSize*0.7, lightFurnitureColor)); } return shapes; }
    function generateCrystalShapes(width, height, colors) { const shapes = []; const crystalColorParams = colors.crystal || [240, 300, 70, 75]; const baseColor = getRandomColor(...crystalColorParams); const highlightColor = `hsla(${crystalColorParams[0]}, ${crystalColorParams[1]}%, ${crystalColorParams[3] + 18}%, 0.8)`; const shadowColor = `hsla(${crystalColorParams[0]}, ${crystalColorParams[1]}%, ${crystalColorParams[3] - 25}%, 0.7)`; const numFacets = getRandomInt(3, 5); const centerBaseX = width/2; const centerTopY = height * (0.05 + Math.random()*0.1); const baseWidth = width * (0.5 + Math.random() * 0.4); const basePoints = []; for (let i = 0; i < numFacets; i++) { const angle = Math.PI + (i / (numFacets - 1)) * Math.PI + (Math.random()-0.5)*0.15; basePoints.push({ x: centerBaseX + Math.cos(angle) * baseWidth / 2, y: height * (0.9 + Math.random()*0.1) }); } for (let i = 0; i < numFacets - 1; i++) { const p1 = basePoints[i]; const p2 = basePoints[i+1]; const facetColor = getRandomColor(crystalColorParams[0], crystalColorParams[1], crystalColorParams[2], getRandomInt(crystalColorParams[3]-15, crystalColorParams[3]+8)); shapes.push(createPolygonShape([{x: centerBaseX, y: centerTopY}, p1, p2], facetColor)); } shapes.push(createPolygonShape([{x: centerBaseX, y: centerTopY}, basePoints[0], basePoints[1]].map(p => ({x:p.x*0.9+centerBaseX*0.1, y:p.y*0.9+centerTopY*0.1})), highlightColor)); shapes.push(createPolygonShape([{x: centerBaseX, y: centerTopY}, basePoints[numFacets-2], basePoints[numFacets-1]].map(p => ({x:p.x*0.9+centerBaseX*0.1, y:p.y*0.9+centerTopY*0.1})), shadowColor)); return shapes; }
    function generateMushroomShapes(width, height, colors) { const shapes = []; const capColorParams = colors.mushroomCap || [0, 30, 70, 55]; const stemColorParams = colors.mushroomStem || [0, 0, 85, 90]; const capColor = getRandomColor(...capColorParams); const capHighlight = `hsla(${capColorParams[0]}, ${capColorParams[1]}%, ${capColorParams[3] + 15}%, 0.7)`; const capShadow = `hsla(${capColorParams[0]}, ${capColorParams[1]}%, ${capColorParams[3] - 15}%, 0.6)`; const stemColor = getRandomColor(...stemColorParams); const darkStemColor = `hsl(${stemColorParams[0]}, ${stemColorParams[1]}%, ${stemColorParams[3] - 18}%)`; const capHeight = height * (0.45 + Math.random() * 0.3); const stemHeight = height - capHeight; const stemWidth = width * (0.25 + Math.random() * 0.25); const stemX = (width - stemWidth) / 2; shapes.push(createRectangleShape(stemX, capHeight, stemWidth, stemHeight, darkStemColor)); shapes.push(createRectangleShape(stemX + stemWidth * 0.1, capHeight, stemWidth * 0.8, stemHeight, stemColor)); const capRadius = width/2 * (0.85 + Math.random()*0.15); shapes.push(createCircleShape(width/2, capHeight/2 + 5, capRadius, capShadow)); shapes.push(createCircleShape(width/2, capHeight/2, capRadius, capColor)); shapes.push(createCircleShape(width/2, capHeight/2 - 3, capRadius*0.8, capHighlight)); if (Math.random() < 0.40) { const numSpots = getRandomInt(1, 2); for (let i = 0; i < numSpots; i++) { const spotRadius = width * 0.09 * (0.8 + Math.random()*0.4); const angle = Math.random() * Math.PI; const dist = Math.random() * capRadius * 0.7; const spotColor = getRandomColor(0, 0, 90, 95, 0.85); shapes.push(createCircleShape(width/2 + Math.cos(angle)*dist, capHeight/2 + Math.sin(angle)*dist*0.5, spotRadius, spotColor)); } } return shapes; }
    function generateRuinsShapes(width, height, colors) { const shapes = []; const ruinColorParams = colors.ruins || [30, 40, 40, 50]; const baseColor = getRandomColor(...ruinColorParams); const darkColor = `hsl(${ruinColorParams[0]}, ${ruinColorParams[1]}%, ${ruinColorParams[3] - 18}%)`; const crackColor = `rgba(0,0,0,0.28)`; const mossColor = getRandomColor(80, 140, 40, 35, 0.38); const pieceType = getRandomInt(1, 3); if (pieceType === 1) { shapes.push(createRectangleShape(0, height*0.3, width, height*0.7, darkColor)); shapes.push(createRectangleShape(5, height*0.3+5, width-10, height*0.7-10, baseColor)); shapes.push(createRectangleShape(0, 0, width*0.4, height*0.5, darkColor)); shapes.push(createRectangleShape(5, 5, width*0.4-10, height*0.5-10, baseColor)); shapes.push(createRectangleShape(5, 5, width*0.4-10, height*0.1, mossColor)); } else if (pieceType === 2) { shapes.push(createRectangleShape(width*0.2, 0, width*0.6, height, darkColor)); shapes.push(createRectangleShape(width*0.2+5, 5, width*0.6-10, height-10, baseColor)); shapes.push(createRectangleShape(width*0.2+5, 5, width*0.6-10, height*0.2, mossColor)); } else { shapes.push(createRectangleShape(0, height*0.5, width*0.7, height*0.5, darkColor)); shapes.push(createRectangleShape(5, height*0.5+5, width*0.7-10, height*0.5-10, baseColor)); shapes.push(createRectangleShape(width*0.3, 0, width*0.5, height*0.6, darkColor)); shapes.push(createRectangleShape(width*0.3+5, 5, width*0.5-10, height*0.6-10, baseColor)); shapes.push(createRectangleShape(5, height*0.5+5, width*0.7-10, height*0.1, mossColor)); } const numCracks = 1; for (let i = 0; i < numCracks; i++) { const x1=Math.random()*width; const y1=Math.random()*height; const x2=x1+(Math.random()-0.5)*width*0.5; const y2=y1+(Math.random()-0.5)*height*0.5; shapes.push({type:'line', x1,y1,x2,y2, color:crackColor, lineWidth:1.5+Math.random()*0.8}); } return shapes; }
    function generateVolcanoShapes(width, height, colors) { const shapes = []; const volcColorParams = colors.volcano || [0, 15, 20, 30]; const baseColor = getRandomColor(...volcColorParams); const darkColor = `hsl(${volcColorParams[0]}, ${volcColorParams[1]}%, ${volcColorParams[3] - 12}%)`; const lavaColor = 'hsl(28, 100%, 55%)'; const lavaGlow = 'hsla(35, 100%, 65%, 0.65)'; const points = [{x:0, y:height}, {x:width*0.25, y:height*0.1}, {x:width*0.75, y:height*0.1}, {x:width, y:height}]; shapes.push(createPolygonShape(points, darkColor)); shapes.push(createPolygonShape(points.map(p=>({x:p.x*0.95+width*0.025, y:p.y*0.95})), baseColor)); shapes.push(createCircleShape(width/2, height*0.1 + 3, width*0.2, lavaGlow)); shapes.push(createCircleShape(width/2, height*0.1, width*0.18, lavaColor)); return shapes; }
    function generateFossilShapes(width, height, colors) { const shapes = []; const fossilColorParams = colors.fossil || [30, 50, 55, 65]; const baseColor = getRandomColor(...fossilColorParams); const darkColor = `hsl(${fossilColorParams[0]}, ${fossilColorParams[1]}%, ${fossilColorParams[3] - 18}%)`; const shapeType = getRandomInt(1, 2); if (shapeType === 1) { shapes.push(createCircleShape(width/2, height/2, Math.min(width,height)/2, darkColor)); shapes.push(createCircleShape(width/2, height/2, Math.min(width,height)/2 * 0.85, baseColor)); const numLines = getRandomInt(2, 4); const centerRadius = Math.min(width, height)/2 * 0.15; for(let i=0; i<numLines; i++) { const angle = Math.random() * Math.PI * 2; const radius = Math.min(width, height)/2 * 0.75; const x1 = width/2 + Math.cos(angle)*centerRadius; const y1 = height/2 + Math.sin(angle)*centerRadius; const x2 = width/2 + Math.cos(angle)*radius * (0.8 + Math.random()*0.2); const y2 = height/2 + Math.sin(angle)*radius * (0.8 + Math.random()*0.2); shapes.push({type:'line', x1,y1,x2,y2, color:darkColor, lineWidth: 1.4+Math.random()*1.1}); } } else { const numPoints = getRandomInt(4, 6); const points = []; const centerX = width / 2; const centerY = height / 2; const avgRadius = Math.min(width, height) / 2 * 0.80; for (let j = 0; j < numPoints; j++) { const angle = (j / numPoints) * Math.PI * 2 + (Math.random() - 0.5) * 0.55; const radius = avgRadius * (0.55 + Math.random() * 0.45); points.push({ x: centerX + Math.cos(angle) * radius, y: centerY + Math.sin(angle) * radius }); } shapes.push(createPolygonShape(points, darkColor)); shapes.push(createPolygonShape(points.map(p => ({ x: p.x * 0.82 + centerX * 0.18, y: p.y * 0.82 + centerY * 0.18 })), baseColor)); } return shapes; }
    function generateScrapMetalShapes(width, height, colors) { const shapes = []; const scrapColorParams = colors.scrap || [190, 220, 20, 40]; const baseColor = getRandomColor(...scrapColorParams); const darkColor = `hsl(${scrapColorParams[0]}, ${scrapColorParams[1]}%, ${scrapColorParams[3] - 15}%)`; const rustColor = getRandomColor(20, 40, 65, 40, 0.50); const numParts = 1; for (let i = 0; i < numParts; i++) { const partW = width * (0.25 + Math.random()*0.6); const partH = height * (0.25 + Math.random()*0.6); const partX = Math.random()*(width-partW); const partY = Math.random()*(height-partH); const rotation = Math.random()*180-90; shapes.push(createRectangleShape(partX, partY, partW, partH, darkColor, rotation)); shapes.push(createRectangleShape(partX+2, partY+2, partW-4, partH-4, baseColor, rotation)); shapes.push(createRectangleShape(partX+2, partY+2, partW-4, partH-4, rustColor, rotation)); if(Math.random() < 0.15) shapes.push(createCircleShape(partX+partW/2, partY+partH/2, Math.min(partW, partH)*0.1, darkColor)); } return shapes; }
    function generateIceWallShapes(width, height, colors) { const shapes = []; const wallColorParams = colors.iceWall || [180, 210, 65, 80]; const baseColor = getRandomColor(...wallColorParams); const highlightColor = `hsla(${wallColorParams[0]}, ${wallColorParams[1]}%, ${wallColorParams[3] + 12}%, 0.75)`; const shadowColor = `hsla(${wallColorParams[0]}, ${wallColorParams[1]}%, ${wallColorParams[3] - 12}%, 0.65)`; shapes.push(createRectangleShape(0, 0, width, height, shadowColor)); shapes.push(createRectangleShape(4, 4, width-8, height-8, baseColor)); shapes.push(createRectangleShape(4, 4, width-8, 10, highlightColor)); for(let i=0; i<1; i++){ const facetW = width*(0.1+Math.random()*0.2); const facetH = height*(0.1+Math.random()*0.2); const facetX = Math.random()*(width-facetW); const facetY = Math.random()*(height-facetH); shapes.push(createRectangleShape(facetX, facetY, facetW, facetH, highlightColor, Math.random()*60-30)); shapes.push(createRectangleShape(facetX, facetY, facetW, facetH, shadowColor, Math.random()*60-30)); } return shapes; }
    function generateBonesShapes(width, height, colors) { const shapes = []; const boneColorParams = colors.bones || [30, 40, 80, 90]; const baseColor = getRandomColor(...boneColorParams); const darkColor = `hsl(${boneColorParams[0]}, ${boneColorParams[1]}%, ${boneColorParams[3] - 18}%)`; const numBones = 1; for(let i=0; i<numBones; i++) { const boneLength = Math.min(width, height) * (0.75 + Math.random()*0.25); const boneWidth = boneLength * 0.13; const x = Math.random()*(width-boneLength*1.05); const y = Math.random()*(height-boneWidth*1.5); const angle = Math.random()*180-90; const knobRadius = boneWidth*1.1; const end1X = x + knobRadius*0.5; const end1Y = y + boneWidth/2; const end2X = x + boneLength - knobRadius*0.5; const end2Y = y + boneWidth/2; shapes.push(createRectangleShape(end1X, y, boneLength - knobRadius, boneWidth, darkColor, angle)); shapes.push(createRectangleShape(end1X+1.5, y+0.8, boneLength - knobRadius-3, boneWidth-1.6, baseColor, angle)); shapes.push(createCircleShape(end1X, end1Y, knobRadius, darkColor)); shapes.push(createCircleShape(end2X, end2Y, knobRadius, darkColor)); shapes.push(createCircleShape(end1X+1.5, end1Y, knobRadius*0.8, baseColor)); shapes.push(createCircleShape(end2X-1.5, end2Y, knobRadius*0.8, baseColor)); } return shapes; }
    function generateCactusShapes(width, height, colors) { const shapes = []; const cactusColorParams = colors.cactus || [80, 140, 50, 40]; const baseColor = getRandomColor(...cactusColorParams); const darkColor = `hsl(${cactusColorParams[0]}, ${cactusColorParams[1]}%, ${cactusColorParams[3] - 18}%)`; const lightColor = `hsl(${cactusColorParams[0]}, ${cactusColorParams[1]}%, ${cactusColorParams[3] + 10}%)`; const trunkWidth = width * (0.35 + Math.random()*0.25); const trunkHeight = height; const trunkX = (width - trunkWidth) / 2; shapes.push(createRectangleShape(trunkX, 0, trunkWidth, trunkHeight, darkColor)); shapes.push(createRectangleShape(trunkX + trunkWidth*0.1, 0, trunkWidth*0.8, trunkHeight, baseColor)); shapes.push(createRectangleShape(trunkX + trunkWidth*0.1, 0, trunkWidth*0.3, trunkHeight, lightColor)); const numArms = getRandomInt(0, 1); for(let i=0; i<numArms; i++) { const armHeight = height * (0.35 + Math.random()*0.35); const armWidth = trunkWidth * (0.6 + Math.random()*0.25); const armY = height * (0.15 + Math.random()*0.45); const side = Math.random() < 0.5 ? -1 : 1; const armStartX = side < 0 ? trunkX : trunkX + trunkWidth - armWidth; const armStartY = armY; shapes.push(createRectangleShape(armStartX, armStartY, armWidth, armHeight, darkColor)); shapes.push(createRectangleShape(armStartX + armWidth*0.1, armStartY, armWidth*0.8, armHeight, baseColor)); shapes.push(createRectangleShape(armStartX + armWidth*0.1, armStartY, armWidth*0.3, armHeight, lightColor)); } return shapes; }
    function generateFallenLogShapes(width, height, colors) { const shapes = []; const logColorParams = colors.fallenLog || [30, 45, 35, 25]; const baseColor = getRandomColor(...logColorParams); const darkColor = `hsl(${logColorParams[0]}, ${logColorParams[1]}%, ${logColorParams[3] - 15}%)`; const lightColor = `hsl(${logColorParams[0]}, ${logColorParams[1]}%, ${logColorParams[3] + 10}%)`; const endRadius = height*0.5; shapes.push(createRectangleShape(endRadius, 0, width - 2*endRadius, height, darkColor)); shapes.push(createRectangleShape(endRadius, height*0.1, width - 2*endRadius, height*0.8, baseColor)); shapes.push(createRectangleShape(endRadius, height*0.1, width - 2*endRadius, height*0.2, lightColor)); shapes.push(createCircleShape(endRadius, height/2, endRadius, darkColor)); shapes.push(createCircleShape(width-endRadius, height/2, endRadius, darkColor)); shapes.push(createCircleShape(endRadius, height/2, endRadius*0.9, baseColor)); shapes.push(createCircleShape(width-endRadius, height/2, endRadius*0.9, baseColor)); return shapes; }
    function generateArenaPillarShapes(width, height, colors) { const shapes = []; const pillarColorParams = colors.pillar || [0, 0, 15, 25]; const baseColor = getRandomColor(...pillarColorParams); const darkColor = `hsl(${pillarColorParams[0]}, ${pillarColorParams[1]}%, ${pillarColorParams[3] - 10}%)`; const crackColor = 'rgba(0,0,0,0.35)'; shapes.push(createRectangleShape(0, 0, width, height, darkColor)); shapes.push(createRectangleShape(width*0.1, 0, width*0.8, height, baseColor)); const numCracks = getRandomInt(1, 2); for (let i = 0; i < numCracks; i++) { const x1=Math.random()*width; const y1=Math.random()*height; const x2=x1+(Math.random()-0.5)*width*0.4; const y2=y1+(Math.random()-0.5)*height*0.4; shapes.push({type:'line', x1,y1,x2,y2, color:crackColor, lineWidth:1.1+Math.random()*1.0}); } return shapes; }
    function generateArenaWallShapes(width, height, colors) { const shapes = []; const wallColorParams = colors.wall || [0, 0, 10, 20]; const baseColor = getRandomColor(...wallColorParams); const darkColor = `hsl(${wallColorParams[0]}, ${wallColorParams[1]}%, ${wallColorParams[3] - 8}%)`; shapes.push(createRectangleShape(0, 0, width, height, darkColor)); shapes.push(createRectangleShape(5, 5, width-10, height-10, baseColor)); return shapes; }

    function generatePebbleShapes(width, height, colors) { const shapes = []; const numPebbles = getRandomInt(7, 12); const pebbleColorParams = colors.pebbles || [0,0,70,85,0.6]; for (let i = 0; i < numPebbles; i++) { const pebbleSize = 3.8 + Math.random() * 4.2; const pebbleX = Math.random() * width; const pebbleY = Math.random() * height; const pebbleColor = getRandomColor(pebbleColorParams[0], pebbleColorParams[1], pebbleColorParams[2], getRandomInt(pebbleColorParams[3]-12, pebbleColorParams[3]+12), pebbleColorParams[4]||0.6); shapes.push(createCircleShape(pebbleX, pebbleY, pebbleSize/2, pebbleColor)); } return shapes; }
    function generateGravelShapes(width, height, colors) { const shapes = []; const numGravel = getRandomInt(12, 20); const gravelColorParams = colors.gravel || [0,0,50,60,0.7]; for (let i = 0; i < numGravel; i++) { const gravelW = 2.8 + Math.random() * 3.8; const gravelH = 2.8 + Math.random() * 3.8; const gravelX = Math.random() * width; const gravelY = Math.random() * height; const gravelColor = getRandomColor(gravelColorParams[0], gravelColorParams[1], gravelColorParams[2], getRandomInt(gravelColorParams[3]-15, gravelColorParams[3]+15), gravelColorParams[4]||0.7); shapes.push(createRectangleShape(gravelX, gravelY, gravelW, gravelH, gravelColor, Math.random()*180)); } return shapes; }
    function generateMossShapes(width, height, colors) { const shapes = []; const numPatches = getRandomInt(3, 6); const mossColorParams = colors.moss || [80,140,40,50,0.7]; for (let i = 0; i < numPatches; i++) { const patchRadius = width * (0.12 + Math.random()*0.35); const patchX = Math.random() * width; const patchY = Math.random() * height; const patchColor = getRandomColor(mossColorParams[0], mossColorParams[1], mossColorParams[2], getRandomInt(mossColorParams[3]-15, mossColorParams[3]+15), mossColorParams[4]||0.7); shapes.push(createCircleShape(patchX, patchY, patchRadius, patchColor)); } return shapes; }
    function generateAshShapes(width, height, colors) { const shapes = []; const numAsh = getRandomInt(12, 22); const ashColorParams = colors.ash || [0,0,15,25,0.7]; for (let i = 0; i < numAsh; i++) { const ashSize = 2.8 + Math.random() * 4.2; const ashX = Math.random() * width; const ashY = Math.random() * height; const ashColor = getRandomColor(ashColorParams[0], ashColorParams[1], ashColorParams[2], getRandomInt(ashColorParams[3]-8, ashColorParams[3]+8), ashColorParams[4]||0.7); shapes.push(createCircleShape(ashX, ashY, ashSize/2, ashColor)); } return shapes; }
    function generateSmallCrystalShapes(width, height, colors) { const shapes = []; const numCrystals = getRandomInt(4, 8); const crystalColorParams = colors.smallCrystal || [240, 300, 75, 85, 0.7]; for (let i = 0; i < numCrystals; i++) { const crystalW = 3.8 + Math.random() * 5.0; const crystalH = 5.5 + Math.random() * 8.5; const crystalX = Math.random() * (width-crystalW); const crystalY = Math.random() * (height - crystalH); const crystalColor = getRandomColor(crystalColorParams[0], crystalColorParams[1], crystalColorParams[2], getRandomInt(crystalColorParams[3]-15, crystalColorParams[3]+15), crystalColorParams[4]||0.7); const highlightColor = `hsla(${crystalColorParams[0]}, ${crystalColorParams[1]}%, ${crystalColorParams[3] + 10}%, 0.5)`; shapes.push(createPolygonShape([{x:crystalX, y:crystalY+crystalH}, {x:crystalX+crystalW/2, y:crystalY}, {x:crystalX+crystalW, y:crystalY+crystalH}], crystalColor)); shapes.push(createPolygonShape([{x:crystalX+crystalW*0.1, y:crystalY+crystalH*0.9}, {x:crystalX+crystalW/2, y:crystalY+crystalH*0.1}, {x:crystalX+crystalW*0.9, y:crystalY+crystalH*0.9}], highlightColor)); } return shapes; }
    function generateGlowWormShapes(width, height, colors) { const shapes = []; const numWorms = getRandomInt(2, 4); const wormColorParams = colors.glowWorm || [60, 80, 80, 90, 0.9]; for (let i = 0; i < numWorms; i++) { const wormSize = 2.2 + Math.random() * 2.6; const wormX = Math.random() * width; const wormY = Math.random() * height; const wormColor = getRandomColor(wormColorParams[0], wormColorParams[1], wormColorParams[2], getRandomInt(wormColorParams[3]-8, wormColorParams[3]+8), wormColorParams[4]||0.9); const glowColor = `hsla(${wormColorParams[0]}, ${wormColorParams[1]}%, ${wormColorParams[3] + 5}%, 0.45)`; shapes.push(createCircleShape(wormX, wormY, wormSize + 1.2, glowColor)); shapes.push(createCircleShape(wormX, wormY, wormSize, wormColor)); } return shapes; }
    function generateSandShapes(width, height, colors) { const shapes = []; const numGrains = getRandomInt(18, 30); const sandColorParams = colors.sand || [40, 50, 75, 85, 0.5]; for (let i = 0; i < numGrains; i++) { const grainSize = 1.4 + Math.random() * 2.6; const grainX = Math.random() * width; const grainY = Math.random() * height; const grainColor = getRandomColor(sandColorParams[0], sandColorParams[1], sandColorParams[2], getRandomInt(sandColorParams[3]-8, sandColorParams[3]+8), sandColorParams[4]||0.5); shapes.push(createCircleShape(grainX, grainY, grainSize/2, grainColor)); } return shapes; }
    function generateSnowPatchShapes(width, height, colors) { const shapes = []; const numPatches = getRandomInt(5, 9); const snowColorParams = colors.snowPatch || [190, 220, 85, 98, 0.6]; for (let i = 0; i < numPatches; i++) { const patchRadius = width * (0.06 + Math.random()*0.25); const patchX = Math.random() * width; const patchY = Math.random() * height; const patchColor = getRandomColor(snowColorParams[0], snowColorParams[1], snowColorParams[2], getRandomInt(snowColorParams[3]-6, snowColorParams[3]+2), snowColorParams[4]||0.6); shapes.push(createCircleShape(patchX, patchY, patchRadius, patchColor)); } return shapes; }
    function generatePuddleShapes(width, height, colors) { const shapes = []; const puddleColorParams = colors.puddle || [180, 210, 30, 50]; const puddleColor = getRandomColor(...puddleColorParams); const highlightColor = `hsla(${puddleColorParams[0]}, ${puddleColorParams[1]+10}%, ${puddleColorParams[3]+15}%, 0.25)`; const radius = Math.min(width, height)/2 * (0.85 + Math.random()*0.15); shapes.push(createCircleShape(width/2, height/2, radius, `hsla(${puddleColorParams[0]}, ${puddleColorParams[1]}%, ${puddleColorParams[3]}%, 0.60)`)); shapes.push(createCircleShape(width/2, height/2, radius * 0.75, highlightColor)); shapes.push(createCircleShape(width/2, height/2, radius * 0.5, highlightColor)); return shapes; }
    function generateLavaPoolShapes(width, height, colors) { const shapes = []; const poolColorParams = colors.lavaPool || [25, 50, 60, 55]; const poolColor = getRandomColor(...poolColorParams); const brightPoolColor = `hsla(${poolColorParams[0]}, ${poolColorParams[1]+10}%, ${poolColorParams[3]+18}%, 0.70)`; const centerGlowColor = `hsla(${poolColorParams[0]+5}, ${poolColorParams[1]+15}%, ${poolColorParams[3]+25}%, 0.78)`; const radius = Math.min(width, height)/2 * (0.9 + Math.random()*0.1); shapes.push(createCircleShape(width/2, height/2, radius, `hsl(${poolColorParams[0]}, ${poolColorParams[1]}%, ${poolColorParams[3]}%)`)); shapes.push(createCircleShape(width/2, height/2, radius * 0.8, brightPoolColor)); shapes.push(createCircleShape(width/2, height/2, radius * 0.5, centerGlowColor)); return shapes; }

    function generateObstacles(level){
        obstacles = []; nonCollidingDecor = [];
        currentBiome = getBiomeForLevel(level);
        console.log(`Generating Level ${level} with Biome: ${currentBiome.name}`);

        if (currentBiome.isBossLevel) {
            obstacles.push({ x: 0, y: 0, width: canvas.width, height: 40, type: ObstacleType.ARENA_WALL, shapes: generateArenaWallShapes(canvas.width, 40, currentBiome.propColors), baseColor: '#333', isBoundary: true });
            obstacles.push({ x: 0, y: canvas.height - 40, width: canvas.width, height: 40, type: ObstacleType.ARENA_WALL, shapes: generateArenaWallShapes(canvas.width, 40, currentBiome.propColors), baseColor: '#333', isBoundary: true });
            obstacles.push({ x: 0, y: 40, width: 40, height: canvas.height - 80, type: ObstacleType.ARENA_WALL, shapes: generateArenaWallShapes(40, canvas.height - 80, currentBiome.propColors), baseColor: '#333', isBoundary: true });
            obstacles.push({ x: canvas.width - 40, y: 40, width: 40, height: canvas.height - 80, type: ObstacleType.ARENA_WALL, shapes: generateArenaWallShapes(40, canvas.height - 80, currentBiome.propColors), baseColor: '#333', isBoundary: true });

            const pillarPositions = [ { x: 200, y: 150 }, { x: canvas.width - 200, y: 150 }, { x: 200, y: canvas.height - 150 }, { x: canvas.width - 200, y: canvas.height - 150 } ];
            pillarPositions.forEach(pos => {
                 const pillarW = 55 + getRandomInt(-8, 8);
                 const pillarH = 95 + getRandomInt(-12, 12);
                 obstacles.push({ x: pos.x - pillarW/2, y: pos.y - pillarH/2, width: pillarW, height: pillarH, type: ObstacleType.ARENA_PILLAR, shapes: generateArenaPillarShapes(pillarW, pillarH, currentBiome.propColors), baseColor: '#444' });
            });

        } else {
            const layouts = [
                 [ { x: 150, y: 100, width: 70, height: 110 }, { x: 400, y: 150, width: 120, height: 50 }, { x: 650, y: 200, width: 60, height: 90 }, { x: 100, y: 450, width: 40, height: 130 }, { x: 500, y: 500, width: 70, height: 110 }, { x: 750, y: 450, width: 120, height: 50 } ],
                 [ { x: 100, y: 100, width: 80, height: 120 }, { x: 700, y: 150, width: 80, height: 120 }, { x: 400, y: 300, width: 90, height: 70 }, { x: 150, y: 500, width: 70, height: 100 }, { x: 650, y: 550, width: 60, height: 50 } ],
                 [ { x: 100, y: 100, width: 130, height: 110 }, { x: 650, y: 80, width: 110, height: 100 }, { x: 350, y: 250, width: 60, height: 100 }, { x: 450, y: 260, width: 50, height: 80 }, { x: 150, y: 450, width: 40, height: 130 }, { x: 600, y: 480, width: 90, height: 50 }, { x: 750, y: 400, width: 90, height: 80 } ],
                 [ { x: 150, y: 150, width: 70, height: 110 }, { x: 700, y: 150, width: 70, height: 110 }, { x: 425, y: 100, width: 110, height: 50 }, { x: 100, y: 350, width: 40, height: 130 }, { x: 770, y: 350, width: 40, height: 130 }, { x: 300, y: 500, width: 60, height: 90 }, { x: 550, y: 500, width: 60, height: 90 }, { x: 425, y: 550, width: 110, height: 50 } ],
                 [ { x: 50, y: 50, width: 70, height: 110 }, { x: 150, y: 80, width: 80, height: 120 }, { x: 260, y: 60, width: 60, height: 100 }, { x: 400, y: 50, width: 70, height: 110 }, { x: 500, y: 80, width: 80, height: 120 }, { x: 610, y: 60, width: 60, height: 100 }, { x: 750, y: 50, width: 70, height: 110 }, { x: 100, y: 200, width: 70, height: 60 }, { x: 300, y: 220, width: 80, height: 65 }, { x: 550, y: 210, width: 75, height: 60 }, { x: 750, y: 200, width: 70, height: 60 }, { x: 450, y: 400, width: 130, height: 60 }, { x: 200, y: 550, width: 90, height: 70 }, { x: 600, y: 560, width: 80, height: 60 } ],
            ];
            const layoutId = (level-1)%layouts.length;
            const currentLayout = layouts[layoutId];

            currentLayout.forEach(objData => {
                const nonDecorTypes = Object.values(ObstacleType).filter(t => ![ObstacleType.GRASS, ObstacleType.PUDDLE, ObstacleType.LAVA_POOL, ObstacleType.JUNGLE_VINE, ObstacleType.PEBBLES, ObstacleType.GRAVEL, ObstacleType.MOSS, ObstacleType.ASH, ObstacleType.SMALL_CRYSTALS, ObstacleType.GLOW_WORMS, ObstacleType.SAND, ObstacleType.SNOW_PATCH].includes(t));
                let allowedObstacleTypes = currentBiome.obstacleTypes.filter(t => nonDecorTypes.includes(t));
                 if (allowedObstacleTypes.length === 0) { allowedObstacleTypes.push(ObstacleType.ROCK); }
                const objType = objData.type || getRandomElement(allowedObstacleTypes);
                let shapes = []; let baseColor = '#888';
                 let plankHeight = 0; if (objType === ObstacleType.BENCH && objData.height) plankHeight = objData.height * 0.1;
                 let poleWidth = 0; if(objType === ObstacleType.LAMP && objData.width) poleWidth = objData.width * 0.12;

                switch (objType) {
                     case ObstacleType.TREE: shapes = generateTreeShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes.find(s => s.type === 'rect')?.color || '#8B4513'; break;
                     case ObstacleType.BENCH: shapes = generateBenchShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes.find(s => s.height > plankHeight * 1.1)?.color || '#A0522D'; break;
                     case ObstacleType.LAMP: shapes = generateLampShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes.find(s => s.width === poleWidth)?.color || '#778899'; break;
                     case ObstacleType.BUSH: shapes = generateBushShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.HOUSE: shapes = generateHouseShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes.find(s => s.type === 'rect' && s.y > 0)?.color || '#C4A484'; break;
                     case ObstacleType.ROCK: shapes = generateRockShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.LAVA_ROCK: shapes = generateLavaRockShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.SNOW_DRIFT: shapes = generateSnowDriftShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.ICE_SPIKE: shapes = generateIceSpikeShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.PIPE: shapes = generatePipeShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.CRATE: shapes = generateCrateShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.BARREL: shapes = generateBarrelShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.PRISON_BARS: shapes = generatePrisonBarShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.FURNITURE: shapes = generateFurnitureShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.CRYSTAL: shapes = generateCrystalShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.MUSHROOM: shapes = generateMushroomShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes.find(s=>s.type==='circle')?.color; break;
                     case ObstacleType.RUINS: shapes = generateRuinsShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.VOLCANO: shapes = generateVolcanoShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.FOSSIL: shapes = generateFossilShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.SCRAP_METAL: shapes = generateScrapMetalShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.ICE_WALL: shapes = generateIceWallShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.BONES: shapes = generateBonesShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes.find(s=>s.type==='rect')?.color; break;
                     case ObstacleType.CACTUS: shapes = generateCactusShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes.find(s=>s.type==='rect')?.color; break;
                     case ObstacleType.FALLEN_LOG: shapes = generateFallenLogShapes(objData.width, objData.height, currentBiome.propColors); baseColor = shapes[0]?.color; break;
                     case ObstacleType.RECT: default: baseColor = objData.color || '#778899'; shapes = [createRectangleShape(0, 0, objData.width, objData.height, baseColor)]; break;
                }
                if (shapes && shapes.length > 0) {
                     obstacles.push({ x: objData.x, y: objData.y, width: objData.width, height: objData.height, type: objType, shapes: shapes, baseColor: baseColor, isBoundary: objData.isBoundary || false });
                } else {
                     console.warn(`Failed to generate shapes for obstacle type ${objType} at ${objData.x},${objData.y}`);
                }
            });
            obstacles.forEach(o => { if (!o.isBoundary && distance(o.x + o.width/2, o.y + o.height/2, 50, 50) < 80) { console.warn("Obstacle too close to default cat spawn, shifting."); o.x += 100; o.y += 50; o.x = clamp(o.x, WALL_BUFFER, canvas.width - o.width - WALL_BUFFER); o.y = clamp(o.y, WALL_BUFFER, canvas.height - o.height - WALL_BUFFER); } });
        }

        const numDecor = currentBiome.isBossLevel ? getRandomInt(8, 15) : getRandomInt(12, 20);
        for (let i = 0; i < numDecor; i++) {
            const decorW = getRandomInt(22, 52); const decorH = getRandomInt(18, 42);
            const decorPos = findSafeSpawnLocation(decorW, decorH, 0, obstacles);
            if (decorPos) {
                const allowedDecor = currentBiome.decorTypes || [];
                if (currentBiome.obstacleTypes.includes(ObstacleType.JUNGLE_VINE) && !allowedDecor.includes(ObstacleType.JUNGLE_VINE)) { allowedDecor.push(ObstacleType.JUNGLE_VINE); }

                if (allowedDecor.length > 0) {
                    const decorType = getRandomElement(allowedDecor); let decorShapes = [];
                    switch(decorType) {
                        case ObstacleType.GRASS: decorShapes = generateGrassPatchShapes(decorW, decorH, currentBiome.propColors); break;
                        case ObstacleType.PUDDLE: decorShapes = generatePuddleShapes(decorW, decorH, currentBiome.propColors); break;
                        case ObstacleType.LAVA_POOL: decorShapes = generateLavaPoolShapes(decorW, decorH, currentBiome.propColors); break;
                        case ObstacleType.JUNGLE_VINE: decorShapes = generateJungleVineShapes(decorW, decorH, currentBiome.propColors); break;
                        case ObstacleType.PEBBLES: decorShapes = generatePebbleShapes(decorW, decorH, currentBiome.propColors); break;
                        case ObstacleType.GRAVEL: decorShapes = generateGravelShapes(decorW, decorH, currentBiome.propColors); break;
                        case ObstacleType.MOSS: decorShapes = generateMossShapes(decorW, decorH, currentBiome.propColors); break;
                        case ObstacleType.ASH: decorShapes = generateAshShapes(decorW, decorH, currentBiome.propColors); break;
                        case ObstacleType.SMALL_CRYSTALS: decorShapes = generateSmallCrystalShapes(decorW, decorH, currentBiome.propColors); break;
                        case ObstacleType.GLOW_WORMS: decorShapes = generateGlowWormShapes(decorW, decorH, currentBiome.propColors); break;
                        case ObstacleType.SAND: decorShapes = generateSandShapes(decorW, decorH, currentBiome.propColors); break;
                        case ObstacleType.SNOW_PATCH: decorShapes = generateSnowPatchShapes(decorW, decorH, currentBiome.propColors); break;
                        case ObstacleType.BONES: decorShapes = generateBonesShapes(decorW, decorH, currentBiome.propColors); break;
                    }
                    if (decorShapes.length > 0) { nonCollidingDecor.push({ x: decorPos.x, y: decorPos.y, width: decorW, height: decorH, type: decorType, shapes: decorShapes }); }
                }
            }
        }

        console.log(`Generated ${obstacles.length} obstacles and ${nonCollidingDecor.length} decor items for level ${level} (${currentBiome.name}).`);
        return obstacles;
    }

    function Particle(x, y, options = {}) { this.x=x;this.y=y;this.size=options.size||Math.random()*4+2.5; const angle = options.angle !== undefined ? options.angle : Math.random() * Math.PI * 2; const speed = (options.speed !== undefined ? options.speed : Math.random()*0.4+0.15) * (options.maxSpeed || 1.4) + (options.minSpeed || 0.4); this.speedX=Math.cos(angle)*speed*(options.speedXMultiplier||1); this.speedY=Math.sin(angle)*speed*(options.speedYMultiplier||1); this.color=options.color||`hsl(${Math.random()*60+180},100%,50%)`; this.life=options.life||Math.random()*90+100; this.gravity=options.gravity||0; this.drag=options.drag||0.98; this.shrinkRate=options.shrinkRate !==undefined?options.shrinkRate:0.99; this.fadeRate=options.fadeRate||0.010; this.alpha=options.alpha||1; this.text=options.text; this.rotation=options.rotation||0; this.rotationSpeed=options.rotationSpeed||0; this.shape=options.shape||'circle'; this.light = options.light || false; this.blendMode = options.blendMode || 'source-over'; }
    Particle.prototype.update = function(){this.speedX*=this.drag;this.speedY*=this.drag;this.speedY+=this.gravity;this.x+=this.speedX * GAME_SPEED_MULTIPLIER; this.y+=this.speedY * GAME_SPEED_MULTIPLIER; this.size*=this.shrinkRate;this.alpha-=this.fadeRate;this.rotation+=this.rotationSpeed * GAME_SPEED_MULTIPLIER; this.life--;if(this.size<0.2||this.alpha<=0)this.life=0;}
    Particle.prototype.draw = function(){ ctx.save(); ctx.globalAlpha=clamp(this.alpha, 0, 1); ctx.globalCompositeOperation = this.light ? 'lighter' : this.blendMode; ctx.translate(this.x, this.y); ctx.rotate(this.rotation); ctx.fillStyle=this.color; if (this.text) { let fS=clamp(Math.ceil(this.size * 1.5), 10, 38); ctx.font=`bold ${fS}px 'Segoe UI', sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.shadowColor = 'rgba(0,0,0,0.75)'; ctx.shadowBlur = 6; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2; ctx.fillText(this.text,0,0); ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; } else { const s = Math.max(0, this.size); switch(this.shape) { case 'spark': ctx.beginPath(); const spk = s / 1.4; ctx.moveTo(0,-spk);ctx.lineTo(spk*0.3,-spk*0.3);ctx.lineTo(spk,0);ctx.lineTo(spk*0.3,spk*0.3); ctx.lineTo(0,spk);ctx.lineTo(-spk*0.3,spk*0.3);ctx.lineTo(-spk,0);ctx.lineTo(-spk*0.3,-spk*0.3); ctx.closePath();ctx.fill(); break; case 'square': ctx.fillRect(-s/2, -s/2, s, s); break; case 'puff': ctx.beginPath(); ctx.arc(0, 0, s * 1.1, 0, Math.PI*2); ctx.globalAlpha *= 0.40; ctx.fill(); break; case 'trail': ctx.beginPath(); ctx.arc(0, 0, s/1.4, 0, Math.PI*2); ctx.fill(); break; case 'mote': case 'dust': case 'sunset_mote': ctx.beginPath(); ctx.arc(0, 0, s/1.8, 0, Math.PI*2); ctx.globalAlpha *= 0.70; ctx.fill(); break; case 'line': ctx.lineWidth = clamp(s, 1.8, 5.5); ctx.beginPath(); ctx.moveTo(-s*1.6, 0); ctx.lineTo(s*1.6, 0); ctx.strokeStyle = this.color; ctx.stroke(); break; case 'star': const spikes = 5; const outerRadius = s; const innerRadius = s / 2.1; let rot = Math.PI / 2 * 3 + this.rotation; let step = Math.PI / spikes; ctx.beginPath(); ctx.moveTo(Math.cos(rot)*outerRadius, Math.sin(rot)*outerRadius); for (let i = 0; i < spikes; i++) { rot += step; ctx.lineTo(Math.cos(rot) * innerRadius, Math.sin(rot) * innerRadius); rot += step; ctx.lineTo(Math.cos(rot) * outerRadius, Math.sin(rot) * outerRadius); } ctx.closePath(); ctx.fill(); break; case 'leaf': ctx.beginPath(); ctx.moveTo(0, -s); ctx.quadraticCurveTo(s*0.8, -s*0.2, s*0.2, s*0.8); ctx.quadraticCurveTo(0, s, 0, s); ctx.quadraticCurveTo(0, s, -s*0.2, s*0.8); ctx.quadraticCurveTo(-s*0.8, -s*0.2, 0, -s); ctx.closePath(); ctx.fill(); break; case '?': ctx.font = `bold ${s*2.3}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('?', 0, 0); break; case '!': ctx.font = `bold ${s*2.3}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('!', 0, 0); break; case '+': ctx.lineWidth = clamp(s / 2.4, 1.8, 6.5); ctx.strokeStyle = this.color; ctx.beginPath(); ctx.moveTo(-s * 0.85, 0); ctx.lineTo(s * 0.85, 0); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, -s * 0.85); ctx.lineTo(0, s * 0.85); ctx.stroke(); break; case 'snow': ctx.beginPath(); ctx.arc(0, 0, s * 1.1, 0, Math.PI * 2); ctx.fill(); break; case 'ember': case 'ash_flake': ctx.fillStyle = `hsl(${getRandomInt(0, 50)}, 100%, ${58 + Math.random()*18}%)`; ctx.beginPath(); ctx.arc(0, 0, s * 1.1, 0, Math.PI * 2); ctx.fill(); break; case 'crystal_dust': const shardPts = 3 + Math.floor(Math.random()*3); ctx.beginPath(); ctx.moveTo(0, -s); for(let i=1; i<shardPts; i++){const angle = (i/shardPts)*Math.PI*2 + (Math.random()-0.5)*0.6; const radius = s * (0.6 + Math.random()*0.6); ctx.lineTo(Math.cos(angle)*radius, Math.sin(angle)*radius);} ctx.closePath(); ctx.fill(); break; case 'spore': ctx.beginPath(); ctx.arc(0, 0, s * 1.2, 0, Math.PI*2); ctx.globalAlpha *= 0.30; ctx.fill(); break; case 'sand': ctx.beginPath(); ctx.arc(0, 0, s*0.8, 0, Math.PI*2); ctx.globalAlpha *= 0.80; ctx.fill(); break; case 'steam': ctx.beginPath(); ctx.arc(0, 0, s*1.4, 0, Math.PI*2); ctx.globalAlpha *= 0.15; ctx.fill(); break; case 'shadow_flicker': ctx.fillStyle = `rgba(10, 0, 20, ${0.18 + Math.random()*0.22})`; ctx.beginPath(); ctx.arc(0, 0, s*1.4, 0, Math.PI*2); ctx.fill(); break; case 'circle': default: ctx.beginPath(); ctx.arc(0, 0, s, 0, Math.PI * 2); ctx.fill(); break; } } ctx.restore(); }
    function createParticles(x, y, count, options = {}) { options.speed = (options.speed || 0.9) * 0.85; options.maxSpeed = (options.maxSpeed || 1.4) * 0.85; options.minSpeed = (options.minSpeed || 0.4) * 0.85; options.life = (options.life || 100) * 1.5; options.drag = options.drag || 0.978; options.fadeRate = options.fadeRate || 0.008; options.shrinkRate = options.shrinkRate || 0.993; options.gravity = options.gravity || 0; options.angleSpread = options.angleSpread || Math.PI * 2; const baseAngle = options.angle || 0; for (let i = 0; i < count; i++) { let angleOffset = (Math.random() - 0.5) * options.angleSpread; options.angle = baseAngle + angleOffset; particles.push(new Particle(x, y, options)); } }
    function spawnAmbientParticles() { ambientParticleTimer--; if(ambientParticleTimer <= 0 && particles.length < 70 && currentBiome) { let options = { size: Math.random() * 2.0 + 1.4, life: 300 + Math.random() * 340, speed: (0.020 + Math.random()*0.048), gravity: (Math.random()-0.5)*0.011, fadeRate:0.0015, shrinkRate:0.9994, drag: 0.993 }; switch(currentBiome.ambientParticleType) { case 'leaf': options.color = getRandomColor(70, 140, 55, 45, 0.50); options.shape = 'leaf'; options.gravity = 0.017 * GAME_SPEED_MULTIPLIER; options.rotationSpeed = (Math.random()-0.5)*0.055; options.size = 5.0 + Math.random()*5.0; break; case 'leaf_heavy': options.color = getRandomColor(80, 150, 60, 40, 0.62); options.shape = 'leaf'; options.gravity = 0.024 * GAME_SPEED_MULTIPLIER; options.rotationSpeed = (Math.random()-0.5)*0.065; options.size = 6.0 + Math.random()*6.0; break; case 'snow': options.color = 'rgba(235, 245, 255, 0.52)'; options.shape = 'snow'; options.gravity = (0.033 + Math.random()*0.020) * GAME_SPEED_MULTIPLIER; options.speedYMultiplier = 1.55; options.drag = 0.997; options.size = 2.6 + Math.random()*3.3; break; case 'ember': options.color = `hsl(${getRandomInt(0, 50)}, 100%, 65%)`; options.shape = 'ember'; options.gravity = (-0.023 - Math.random()*0.025) * GAME_SPEED_MULTIPLIER; options.light = true; options.size = 3.5 + Math.random()*3.5; options.life = 100 + Math.random()*95; break; case 'crystal_dust': options.color = getRandomColor(240, 300, 75, 80, 0.30); options.shape = 'crystal_dust'; options.gravity = 0.011 * GAME_SPEED_MULTIPLIER; options.light = true; options.size = 3.0 + Math.random()*4.0; options.life = 115 + Math.random()*110; options.rotationSpeed = (Math.random()-0.5)*0.07; break; case 'spore': options.color = getRandomColor(40, 150, 65, 60, 0.18); options.shape = 'spore'; options.gravity = (Math.random()-0.8)*0.012 * GAME_SPEED_MULTIPLIER; options.drag=0.955; options.size = 3.8 + Math.random()*5.2; break; case 'sand': options.color = getRandomColor(35, 55, 45, 70, 0.40); options.shape = 'sand'; options.gravity = 0.035 * GAME_SPEED_MULTIPLIER; options.speedXMultiplier = 1.42; options.drag = 0.994; options.size = 1.7 + Math.random()*2.8; break; case 'steam': options.color = 'rgba(190, 190, 200, 0.05)'; options.shape = 'steam'; options.gravity = -0.033 * GAME_SPEED_MULTIPLIER; options.drag=0.968; options.size = 11 + Math.random()*12; options.life=95+Math.random()*90; break; case 'dust': options.color = 'rgba(170, 150, 130, 0.08)'; options.shape = 'dust'; options.size=2.6+Math.random()*3.4; break; case 'dust_heavy': options.color = 'rgba(150, 130, 110, 0.10)'; options.shape = 'dust'; options.size=3.2+Math.random()*3.9; options.gravity = 0.008 * GAME_SPEED_MULTIPLIER; break; case 'shadow_flicker': options.color = `rgba(20, 0, 30, ${0.08 + Math.random()*0.12})`; options.shape = 'shadow_flicker'; options.light = true; options.size = 10 + Math.random()*17; options.life = 80 + Math.random()*80; options.blendMode='multiply'; options.speed = 0.017; break; case 'mote': options.color = `rgba(210, 210, 190, ${0.05 + Math.random()*0.05})`; options.shape = 'mote'; options.size=1.8+Math.random()*2.8; break; case 'mote_dense': options.color = `rgba(200, 200, 180, ${0.06 + Math.random()*0.06})`; options.shape = 'mote'; options.size=2.3+Math.random()*3.2; break; default: options.color = `rgba(200, 200, 180, ${0.04 + Math.random()*0.04})`; options.shape = 'mote'; break; } createParticles(Math.random() * canvas.width, Math.random() * canvas.height, 1, options); ambientParticleTimer = getRandomInt(30, 65); } }
    function createWinScreenParticles() {

         if (Math.random() < 0.12) {
             const x = Math.random() * canvas.width;
             const y = Math.random() * canvas.height * 0.75;
             const size = 1.8 + Math.random() * 2.8;
             const life = 180 + Math.random() * 150;
             const color = `hsla(${25 + Math.random()*40}, 100%, ${75 + Math.random()*18}%, ${0.35 + Math.random()*0.45})`;
             createParticles(x, y, 1, {
                 size: size, life: life, speed: 0.05 + Math.random()*0.12,
                 gravity: -0.018, drag: 0.988, color: color,
                 shape: 'sunset_mote', light: true, fadeRate: 0.0035
             });
         }

         if (Math.random() < 0.06) {
              const x = Math.random() * canvas.width;
              const y = Math.random() * canvas.height * 0.85;
              const size = 2.5 + Math.random() * 3.5;
              createParticles(x, y, 1, {
                 size: size, life: 60 + Math.random()*40, speed: Math.random()*0.35 + 0.15,
                 gravity: -0.010, drag: 0.96, color: 'rgba(255, 255, 230, 0.95)',
                 shape: 'spark', light: true, fadeRate: 0.025, rotationSpeed: (Math.random() - 0.5) * 0.12
             });
         }

         if (Math.random() < 0.25) {
              const blossom = document.createElement('div');
              blossom.className = 'cherry-blossom';

              const isFromTree = Math.random() < 0.6;
              let startX;
              if (isFromTree) {
                  const trees = winScreenOverlay.querySelectorAll('.win-cherry-tree');
                  if (trees.length > 0) {
                      const tree = getRandomElement(Array.from(trees));
                      const treeRect = tree.getBoundingClientRect();
                      const gameRect = gameContainer.getBoundingClientRect();
                      startX = (treeRect.left - gameRect.left + treeRect.width * (0.1 + Math.random()*0.8)) / gameRect.width * 100;
                  } else {
                      startX = Math.random() * 100;
                  }
              } else {
                   startX = Math.random() * 100;
              }
              blossom.style.left = startX + 'vw';

              const duration = (Math.random() * 8 + 9);
              blossom.style.animationDuration = duration + 's';
              blossom.style.setProperty('--drift', (Math.random() - 0.5) * 150);
              blossom.style.width = (Math.random() * 5 + 7) + 'px';
              blossom.style.height = (Math.random() * 4 + 6) + 'px';
              winScreenOverlay.appendChild(blossom);
              setTimeout(() => { if (blossom && blossom.parentNode === winScreenOverlay) blossom.remove(); }, duration * 1000 + 500);
          }
     }

    function spawnBird(forceNormal = false) {
        const isBossArena = currentBiome?.isBossLevel;

        const goldenChance = isBossArena ? BOSS_ARENA_GOLDEN_BIRD_CHANCE : GOLDEN_BIRD_CHANCE;
        const isGolden = !forceNormal && Math.random() < goldenChance;

        if (!bird || !isBossArena) {
            const birdType = isGolden ? BirdType.GOLDEN : BirdType.NORMAL;
            const size = isGolden ? 38 : 32;
            const avoid = isBossArena ? [cat, boss, ...pickups] : [cat, ...dogs, ...pickups];
            const pos = findSafeSpawnLocation(size, size, SAFE_SPAWN_DISTANCE_BIRD, avoid);

            if (pos) {
                bird = { x: pos.x, y: pos.y, type: birdType, width: size, height: size, bobOffset: 0, bobSpeed: Math.random() * 0.06 + 0.04 };
                createParticles(pos.x + size/2, pos.y + size/2, isGolden ? 6 : 3, { color: isGolden ? 'hsl(50, 100%, 75%)' : 'hsl(180, 100%, 75%)', size: isGolden ? 8.0 : 5.5, life: 90, speed: 2.5, gravity: 0.05, light: isGolden, drag:0.97, shape: isGolden ? 'star' : 'circle', angleSpread: Math.PI * 1.9 });
            } else {
                console.error(`CRITICAL: Failed to find safe spawn for bird on level ${level}!`);
                bird = null;
            }
        }
    }
    function spawnNewDog() { if (dogs.length >= (currentBiome?.maxDogs || MAX_DOGS) || currentBiome?.isBossLevel) return; const dogWidth = 50, dogHeight = 50; const pos = findSafeSpawnLocation(dogWidth, dogHeight, SAFE_SPAWN_DISTANCE_CAT, [...dogs, ...pickups]); if (pos) { const aiTypes = Object.values(DogAiType); const randomAiType = aiTypes[getRandomInt(0, aiTypes.length - 1)]; const baseSpeedMultiplier = currentBiome?.dogBaseSpeedMult || 1.0; const newDog = { x: pos.x, y: pos.y, width: dogWidth, height: dogHeight, baseSpeed: (1.3 + Math.min(level * 0.17, 2.5)) * baseSpeedMultiplier * GAME_SPEED_MULTIPLIER, currentSpeed: 0, aiType: randomAiType, state: DogState.IDLE_WANDER, targetX: pos.x, targetY: pos.y, stateTimer: getRandomInt(60, DOG_WANDER_TIMER_MAX), enrageTimer: 0, detourTimer: 0, detourTargetX: 0, detourTargetY: 0, hasClearLOS: false, losCheckTimer: getRandomInt(0, LINE_OF_SIGHT_CHECK_INTERVAL), losLostTimer: 0, stunTimer: 0, dazeTimer: 0, facingRight: (Math.random() > 0.5), separationForceX: 0, separationForceY: 0, lastState: DogState.IDLE_WANDER }; newDog.currentSpeed = newDog.baseSpeed * 0.7; dogs.push(newDog); createParticles(pos.x + dogWidth/2, pos.y + dogHeight/2, 6, { color:'rgb(139, 69, 19)', shape:'square', size:8.8, life:110, speed:2.5, gravity: 0.095, drag: 0.948, rotationSpeed: (Math.random()-0.5)*0.09, angleSpread: Math.PI * 2.2 }); triggerScreenShake(1.9, 7.8); } }
    function spawnPickup() { if (pickups.length >= MAX_PICKUPS || currentBiome?.isBossLevel) return; const pos = findSafeSpawnLocation(PICKUP_SIZE, PICKUP_SIZE, SAFE_SPAWN_DISTANCE_CAT * 0.8, [...dogs, ...pickups]); if (pos) { let rand = Math.random() * totalPickupWeight, cumulative = 0, chosenType = null; for (const type in PICKUP_WEIGHTS) { cumulative += PICKUP_WEIGHTS[type]; if (rand <= cumulative) { chosenType = type; break; } } if (!chosenType) chosenType = Object.keys(PICKUP_WEIGHTS)[0]; pickups.push({ x: pos.x, y: pos.y, width: PICKUP_SIZE, height: PICKUP_SIZE, type: chosenType, spawnTime: frameCount }); createParticles(pos.x + PICKUP_SIZE/2, pos.y + PICKUP_SIZE/2, 6, { color: getPickupColor(chosenType, true), size:7.8, life:100, speed:2.3, gravity:0.065, drag: 0.96, shape: Math.random() < 0.6 ? 'spark' : 'star', light: true, angleSpread: Math.PI * 2.1 }); } }

    function updateDash() { if (cat.isDashing) { cat.dashTimer--; if (frameCount % 6 === 0) { createParticles(cat.x + cat.width/2, cat.y + cat.height/2, 1, { color:'rgba(230, 230, 255, 0.60)', size:13.5, life:16, speed:0.09, drag:0.92, shrinkRate:0.86, fadeRate: 0.14, shape: 'line', light: true, angle: Math.atan2(cat.dashDirectionY, cat.dashDirectionX) + Math.PI + (Math.random()-0.5)*0.5, rotation: Math.atan2(cat.dashDirectionY, cat.dashDirectionX) }); } if (cat.dashTimer <= 0) { cat.isDashing = false; cat.dashCooldownTimer = DASH_COOLDOWN; updateDashCooldownBar(); createParticles(cat.x + cat.width/2, cat.y + cat.height/2, 6, { color:'rgba(200, 200, 255, 0.80)', size: 11.5, life: 65, speed: 4.2, drag: 0.92, gravity: 0.045, shape: 'spark', light:true, angleSpread: Math.PI * 1.4 }); triggerScreenShake(2.8, 6); } } else if (cat.dashCooldownTimer > 0 && !isGodModeActive) { cat.dashCooldownTimer--; if (cat.dashCooldownTimer <= 0) { updateDashCooldownBar(); createParticles(cat.x + cat.width * 0.5, cat.y + cat.height * 0.5, 5, { color: '#5dade2', size: 6.5, life: 32, speed: 1.4, gravity: -0.055, light:true, shape:'spark' }); triggerScreenShake(1.6, 4); } else if (cat.dashCooldownTimer % Math.floor(DASH_COOLDOWN/4) === 0) { updateDashCooldownBar(); } } else { updateDashCooldownBar(); } }
    function updateDashCooldownBar() { const ready = cat.dashCooldownTimer <= 0 || isGodModeActive; const cooldownPercent = ready ? 100 : ((DASH_COOLDOWN - cat.dashCooldownTimer) / DASH_COOLDOWN) * 100; dashCooldownBar.style.width = `${clamp(cooldownPercent, 0, 100)}%`; if (ready) { if (!dashCooldownContainer.classList.contains('ready')) { dashCooldownContainer.classList.add('ready'); dashCooldownBar.classList.add('ready'); } } else { if (dashCooldownContainer.classList.contains('ready')) { dashCooldownContainer.classList.remove('ready'); dashCooldownBar.classList.remove('ready'); dashCooldownContainer.style.animation = 'none'; void dashCooldownContainer.offsetWidth; dashCooldownContainer.style.animation = ''; } } }
    function handleDashInput() { if (!isLevelTransitioning && keys[' '] && !cat.isDashing && (cat.dashCooldownTimer <= 0 || isGodModeActive)) { cat.isDashing = true; cat.dashTimer = DASH_DURATION; if (!isGodModeActive) cat.dashCooldownTimer = DASH_COOLDOWN; let dashDirX = cat.intendedDx; let dashDirY = cat.intendedDy; if (Math.abs(dashDirX) < 0.1 && Math.abs(dashDirY) < 0.1) { dashDirX = cat.facingRight ? 1 : -1; dashDirY = 0; } let mag = Math.sqrt(dashDirX * dashDirX + dashDirY * dashDirY); if (mag === 0) { dashDirX = cat.facingRight ? 1 : -1; mag = 1; } cat.dashDirectionX = (dashDirX / mag); cat.dashDirectionY = (dashDirY / mag); updateDashCooldownBar(); triggerScreenShake(4.5, 8); createParticles(cat.x+cat.width/2, cat.y+cat.height/2, 6, { color:'rgba(220,220,255,0.92)', size:13.5, life:45, speed:6.0, angle:Math.atan2(dashDirY,dashDirX), drag:0.88, shrinkRate:0.87, fadeRate: 0.055, light: true, shape: 'spark', angleSpread: 1.0 }); if (cat.heldBird) { const birdData = cat.heldBird; const damageMultiplier = birdData.type === BirdType.GOLDEN ? BOSS_GOLDEN_BIRD_DAMAGE_MULTIPLIER : 1; projectiles.push({ x: cat.x + cat.width/2, y: cat.y + cat.height/2, width: birdData.width * 0.8, height: birdData.height * 0.8, vx: cat.dashDirectionX * 12 * GAME_SPEED_MULTIPLIER, vy: cat.dashDirectionY * 12 * GAME_SPEED_MULTIPLIER, image: birdData.type === BirdType.GOLDEN ? goldenBirdImg : birdImg, birdType: birdData.type, damage: BOSS_BIRD_DAMAGE * damageMultiplier, life: 2.8 * 60, type: 'bird_projectile' }); cat.heldBird = null; createParticles(cat.x + cat.width/2, cat.y + cat.height/2, 5, { color: birdData.type === BirdType.GOLDEN ? 'gold' : '#4dd0e1', size: 7.5, life: 55, speed: 3.8, angle: Math.atan2(cat.dashDirectionY, cat.dashDirectionX), angleSpread: 0.7, shape: 'spark' }); } } }
    function updateCatPosition() { let currentSpeed = CAT_BASE_SPEED * GAME_SPEED_MULTIPLIER; let moveDx = 0, moveDy = 0; if(keys['arrowup']||keys['w'])moveDy-=1;if(keys['arrowdown']||keys['s'])moveDy+=1;if(keys['arrowleft']||keys['a'])moveDx-=1;if(keys['arrowright']||keys['d'])moveDx+=1; let magnitude=Math.sqrt(moveDx*moveDx+moveDy*moveDy); let movedThisFrame = false; let turning = false; if (magnitude > 0) { moveDx /= magnitude; moveDy /= magnitude; let prevFacingRight = cat.facingRight; if (Math.abs(moveDx) > 0.1 && !cat.isDashing) cat.facingRight=(moveDx>0); if (cat.facingRight !== prevFacingRight) turning = true; cat.intendedDx = moveDx; cat.intendedDy = moveDy; movedThisFrame = true; } else { if (lastCatMoveDx !== 0 || lastCatMoveDy !== 0 && frameCount % 2 === 0) { createParticles(cat.x + cat.width/2, cat.y + cat.height - 1.5, 1, { color:`rgba(180, 160, 140, 0.28)`, size: 3.8+Math.random()*2.8, life: 32+Math.random()*16, speed:0.28+Math.random()*0.16, gravity: -0.032, speedYMultiplier:0.07, shrinkRate:0.93, shape: 'puff' }); } cat.intendedDx = 0; cat.intendedDy = 0; movedThisFrame = false; } lastCatMoveDx = cat.intendedDx; lastCatMoveDy = cat.intendedDy; let nextX = cat.x, nextY = cat.y; let appliedSpeed = currentSpeed; if (cat.isDashing) { appliedSpeed *= DASH_SPEED_MULTIPLIER; nextX += cat.dashDirectionX * appliedSpeed; nextY += cat.dashDirectionY * appliedSpeed; movedThisFrame = true; } else { const boostActive = cat.speedBoostTimer > 0 || cat.goldenBoostTimer > 0; appliedSpeed *= (boostActive ? 1.75 : 1.0); nextX += moveDx * appliedSpeed; nextY += moveDy * appliedSpeed; } let finalX = cat.x, finalY = cat.y; let collidedX = false, collidedY = false; const collisionX = checkWallCollision(nextX, cat.y, cat.width, cat.height); if (!collisionX) { finalX = nextX; } else { collidedX = true; if(cat.isDashing) { cat.dashTimer = 0; cat.isDashing = false; createParticles(cat.x + (cat.dashDirectionX > 0 ? cat.width : 0), cat.y + cat.height/2, 5, { color: '#cacfd2', size: 6.5, speed: 1.4, gravity: 0.075, life: 45, angleSpread: Math.PI * 1.0 }); triggerScreenShake(2.2, 3); } else if(movedThisFrame) { createParticles(nextX > cat.x ? cat.x+cat.width : cat.x, cat.y+cat.height/2, 1, { color: '#b0a090', size: 3.2, speed: 0.45, gravity: 0.045, life: 22, shape:'puff'}); } } const collisionY = checkWallCollision(finalX, nextY, cat.width, cat.height); if (!collisionY) { finalY = nextY; } else { collidedY = true; if(cat.isDashing && !collidedX) { cat.dashTimer = 0; cat.isDashing = false; createParticles(cat.x + cat.width/2, cat.y + (cat.dashDirectionY > 0 ? cat.height : 0), 5, { color: '#cacfd2', size: 6.5, speed: 1.4, gravity: 0.075, life: 45, angleSpread: Math.PI * 1.0 }); triggerScreenShake(2.2, 3); } else if(movedThisFrame && !collidedX){ createParticles(cat.x + cat.width/2, nextY > cat.y ? cat.y+cat.height : cat.y, 1, { color: '#b0a090', size: 3.2, speed: 0.45, gravity: 0.045, life: 22, shape:'puff'}); } } if (collidedX && collidedY && !checkWallCollision(nextX, nextY, cat.width, cat.height)) { if (Math.abs(moveDx) > Math.abs(moveDy) && !checkWallCollision(cat.x, nextY, cat.width, cat.height)) { finalY = nextY; collidedY = false; } else if (Math.abs(moveDy) >= Math.abs(moveDx) && !checkWallCollision(nextX, cat.y, cat.width, cat.height)) { finalX = nextX; collidedX = false; } } cat.x = finalX; cat.y = finalY; cat.x=clamp(cat.x, WALL_BUFFER, canvas.width-cat.width-WALL_BUFFER); cat.y=clamp(cat.y, WALL_BUFFER, canvas.height-cat.height-WALL_BUFFER); if(!movedThisFrame && !cat.isDashing){ cat.idleBob=Math.sin(frameCount*0.1)*1.8; } else { cat.idleBob=0; } if(movedThisFrame && !cat.isDashing && frameCount%11 === 0){ createParticles(cat.x + cat.width/2, cat.y + cat.height - 1.5, 1, { color:`rgba(180, 160, 140, ${0.18 + Math.random()*0.10})`, size: 2.6+Math.random()*2.8, life: 22+Math.random()*11, speed:0.07+Math.random()*0.07, gravity: -0.03, speedYMultiplier:0.05, shrinkRate:0.96, shape: 'puff' }); } if (turning && !cat.isDashing && frameCount % 7 === 0) { createParticles(cat.x + cat.width/2, cat.y + cat.height - 1, 1, { color:`rgba(195, 175, 155, 0.30)`, size: 3.5+Math.random()*2.4, life: 24+Math.random()*8, speed:0.25+Math.random()*0.10, gravity: -0.025, speedYMultiplier:0.06, shrinkRate:0.94, shape: 'puff' }); } }
        function updateDogAIState(dog) { const catCenterX = cat.x + cat.width / 2; const catCenterY = cat.y + cat.height / 2; const dogCenterX = dog.x + dog.width / 2; const dogCenterY = dog.y + dog.height / 2; const distToCat = distance(dogCenterX, dogCenterY, catCenterX, catCenterY); const prevState = dog.state; dog.stateTimer = Math.max(0, dog.stateTimer - 1); dog.enrageTimer = Math.max(0, dog.enrageTimer - 1); dog.stunTimer = Math.max(0, dog.stunTimer - 1); dog.dazeTimer = Math.max(0, dog.dazeTimer - 1); dog.losCheckTimer = Math.max(0, dog.losCheckTimer - 1); dog.detourTimer = Math.max(0, dog.detourTimer - 1); dog.losLostTimer = Math.max(0, dog.losLostTimer - 1); if (dog.state === DogState.STUNNED) { if (dog.stunTimer <= 0) { dog.state = DogState.IDLE_WANDER; dog.stateTimer = getRandomInt(35, 65); dog.currentSpeed = dog.baseSpeed * 0.7 * GAME_SPEED_MULTIPLIER; createParticles(dog.x + dog.width/2, dog.y + dog.height/2, 7, { color: 'rgba(200, 200, 200, 0.60)', size: 9.5, life: 40, speed: 2.0, drag: 0.92, shape: 'puff', angleSpread: Math.PI*1.2 }); createParticles(dog.x + dog.width / 2, dog.y, 1, { color: 'yellow', size: 8.5, life: 65, speed: 1.0, gravity: 0.045, shape: 'star', rotationSpeed: 0.08, drag: 0.94 }); } else { if (frameCount % 11 === (dogs.indexOf(dog)%7)) { createParticles(dog.x + dog.width / 2 + (Math.random() - 0.5) * dog.width * 0.85, dog.y + dog.height / 2 + (Math.random() - 0.5) * dog.height * 0.65, 1, { color: 'hsl(55, 100%, 75%)', size: 4.5 + Math.random() * 3.0, life: 16 + Math.random() * 11, speed: 0.05, gravity: -0.045, shape: 'spark', fadeRate: 0.08, light:true }); } dog.targetX = dog.x; dog.targetY = dog.y; return; } } if (dog.state === DogState.DETOURING && dog.detourTimer <= 0) { dog.state = DogState.IDLE_WANDER; dog.stateTimer = 10; } else if (dog.detourTimer > 0) { dog.state = DogState.DETOURING; } else if (dog.dazeTimer > 0) { dog.state = DogState.DAZED; } if (dog.losCheckTimer <= 0) { dog.hasClearLOS = hasLineOfSight(dogCenterX, dogCenterY, catCenterX, catCenterY, dog.width * 0.65); dog.losCheckTimer = LINE_OF_SIGHT_CHECK_INTERVAL; if (dog.hasClearLOS) { dog.losLostTimer = 0; if (dog.state === DogState.DETOURING) { if (hasLineOfSight(dogCenterX, dogCenterY, catCenterX, catCenterY, dog.width*0.65)) { dog.detourTimer = 0; dog.state = DogState.CHASING; dog.stateTimer = 0; } } } else if (dog.state !== DogState.IDLE_WANDER && dog.state !== DogState.FLEEING && dog.state !== DogState.DETOURING) { if (dog.losLostTimer <= 0) dog.losLostTimer = DOG_LOS_LOST_PERSISTENCE; } } let intendedState = dog.state; if (dog.state !== DogState.DAZED && dog.state !== DogState.DETOURING) { if (dog.hasClearLOS || distToCat < DOG_DETECTION_RANGE * 0.65) { if (dog.state === DogState.IDLE_WANDER || dog.losLostTimer > 0) { if(dog.state === DogState.IDLE_WANDER && distToCat < DOG_DETECTION_RANGE) { triggerScreenShake(0.9, 2.5); createParticles(dog.x + dog.width/2, dog.y - 5, 1, { color: 'yellow', shape: '!', size: 8.5, life: 38, speed: 0.85, gravity: -0.05 }); } dog.losLostTimer = 0; } const effectiveAiType = dog.enrageTimer > 0 ? DogAiType.CHASER : dog.aiType; switch (effectiveAiType) { case DogAiType.AMBUSHER: intendedState = DogState.AMBUSHING; break; case DogAiType.SKITTISH: const fleeDist = 85; const approachDist = 290; if (distToCat < fleeDist && dog.state !== DogState.FLEEING) { intendedState = DogState.FLEEING; dog.stateTimer = 0; } else if (dog.state === DogState.FLEEING && distToCat >= fleeDist + 20) { intendedState = DogState.CHASING; dog.stateTimer = 0; } else if (distToCat > approachDist && dog.state !== DogState.FLEEING) { intendedState = DogState.CHASING; } else if (dog.state !== DogState.FLEEING){ intendedState = DogState.CHASING; } break; case DogAiType.CHASER: default: intendedState = DogState.CHASING; break; } } else { if (dog.losLostTimer > 0) { intendedState = (dog.state === DogState.AMBUSHING) ? DogState.AMBUSHING : DogState.CHASING; } else if (dog.state !== DogState.FLEEING) { intendedState = DogState.IDLE_WANDER; } } if (dog.state !== intendedState) { let particleOptions = { size: 6.5, life: 32, speed: 1.0, gravity: -0.05, shape: 'puff' }; if (dog.state === DogState.IDLE_WANDER && intendedState === DogState.CHASING) { particleOptions.color = 'yellow'; particleOptions.shape = '!'; particleOptions.size=8.5; createParticles(dog.x + dog.width/2, dog.y - 5, 1, particleOptions); } else if (intendedState === DogState.FLEEING) { particleOptions.color = 'lightblue'; particleOptions.shape = '!'; particleOptions.size=7.5; particleOptions.speed=1.5; particleOptions.text='!!'; createParticles(dog.x + dog.width/2, dog.y - 5, 1, particleOptions); } else if (intendedState === DogState.IDLE_WANDER) { particleOptions.color = 'grey'; particleOptions.shape = '?'; particleOptions.size=5.5; particleOptions.speed=0.32; createParticles(dog.x + dog.width/2, dog.y - 5, 1, particleOptions); } dog.state = intendedState; dog.stateTimer = 0; } } const catSpeedFactor = (cat.speedBoostTimer > 0 || cat.goldenBoostTimer > 0) ? 1.75 : 1.0; const catPredictedX = cat.x + (cat.intendedDx || 0) * catSpeedFactor * 18; const catPredictedY = cat.y + (cat.intendedDy || 0) * catSpeedFactor * 18; switch (dog.state) { case DogState.CHASING: dog.targetX = dog.losLostTimer > 0 ? dog.targetX : catPredictedX; dog.targetY = dog.losLostTimer > 0 ? dog.targetY : catPredictedY; break; case DogState.AMBUSHING: const leadFactor = clamp(distToCat * 0.38, 38, 115); if (dog.hasClearLOS) { dog.targetX = cat.x + (cat.intendedDx || 0) * leadFactor; dog.targetY = cat.y + (cat.intendedDy || 0) * leadFactor; } else if (!dog.losLostTimer > 0) { dog.state = DogState.CHASING; dog.targetX = cat.x; dog.targetY = cat.y; } break; case DogState.FLEEING: if (dog.stateTimer <= 0) { const fleeTargetX = dog.x - (catCenterX - dogCenterX) * 3.0; const fleeTargetY = dog.y - (catCenterY - dogCenterY) * 3.0; dog.targetX = clamp(fleeTargetX + (Math.random()-0.5)*300, 0, canvas.width-dog.width); dog.targetY = clamp(fleeTargetY + (Math.random()-0.5)*300, 0, canvas.height-dog.height); dog.stateTimer = getRandomInt(95, 145); createParticles(dog.x + dog.width / 2, dog.y + dog.height / 2, 1, { color: 'rgba(173, 216, 230, 0.60)', size: 5.0, life: 45, speed: 0.55, gravity: 0.085, shape: 'circle', angle: Math.PI * 1.5 + (Math.random()-0.5)*0.7 }); } break; case DogState.IDLE_WANDER: if (dog.stateTimer <= 0 || distance(dog.x, dog.y, dog.targetX, dog.targetY) < dog.width) { dog.targetX = clamp(dog.x + (Math.random() - 0.5) * 2 * DOG_WANDER_RADIUS, WALL_BUFFER, canvas.width - dog.width - WALL_BUFFER); dog.targetY = clamp(dog.y + (Math.random() - 0.5) * 2 * DOG_WANDER_RADIUS, WALL_BUFFER, canvas.height - dog.height - WALL_BUFFER); dog.stateTimer = getRandomInt(110, DOG_WANDER_TIMER_MAX); } break; case DogState.DETOURING: dog.targetX = dog.detourTargetX; dog.targetY = dog.detourTargetY; if (distance(dog.x, dog.y, dog.targetX, dog.targetY) < dog.width*0.5) { dog.detourTimer = 0; } break; case DogState.DAZED: if (frameCount % 18 === 0) { dog.targetX += (Math.random() - 0.5) * 10; dog.targetY += (Math.random() - 0.5) * 10; } break; } dog.targetX = clamp(dog.targetX || dog.x, 0, canvas.width - dog.width); dog.targetY = clamp(dog.targetY || dog.y, 0, canvas.height - dog.height); dog.lastState = prevState; }
    function updateDogMovement(dog) { updateDogAIState(dog); if (dog.state === DogState.STUNNED) { return; } let speedMultiplier = 1.0; if (cat.dogSlowTimer > 0) speedMultiplier *= 0.30; if (dog.enrageTimer > 0) speedMultiplier *= DOG_ENRAGE_SPEED_MULTIPLIER; if (dog.state === DogState.DAZED) speedMultiplier *= DOG_DAZE_SLOW_FACTOR; if (dog.state === DogState.IDLE_WANDER) speedMultiplier *= 0.65; if (dog.aiType === DogAiType.SKITTISH) { if (dog.state === DogState.FLEEING) speedMultiplier *= 1.20; else if (dog.state === DogState.CHASING && distance(dog.x,dog.y,cat.x,cat.y) < 180) speedMultiplier *= 0.80; } dog.currentSpeed = dog.baseSpeed * speedMultiplier * GAME_SPEED_MULTIPLIER; dog.currentSpeed = Math.max(0, dog.currentSpeed); dog.separationForceX = 0; dog.separationForceY = 0; let neighborCount = 0; const dogCenterX = dog.x + dog.width / 2; const dogCenterY = dog.y + dog.height / 2; let separationActive = false; for (const otherDog of dogs) { if (dog === otherDog) continue; const otherCenterX = otherDog.x + otherDog.width / 2; const otherCenterY = otherDog.y + otherDog.height / 2; const distBetween = distance(dogCenterX, dogCenterY, otherCenterX, otherCenterY); if (distBetween < DOG_SEPARATION_DISTANCE && distBetween > 0.1) { neighborCount++; const repelFactor = (1 - (distBetween / DOG_SEPARATION_DISTANCE))**2; dog.separationForceX += (dogCenterX - otherCenterX) / distBetween * repelFactor; dog.separationForceY += (dogCenterY - otherCenterY) / distBetween * repelFactor; separationActive = true; } } if (neighborCount > 0) { const separationMag = Math.sqrt(dog.separationForceX**2 + dog.separationForceY**2); if (separationMag > 0) { const desiredSeparationSpeed = DOG_SEPARATION_FORCE * dog.currentSpeed * 1.25; dog.separationForceX = (dog.separationForceX / separationMag) * desiredSeparationSpeed; dog.separationForceY = (dog.separationForceY / separationMag) * desiredSeparationSpeed; if (separationActive && frameCount % 9 === (dogs.indexOf(dog) % 9)) { createParticles(dogCenterX + dog.separationForceX*0.06, dogCenterY + dog.separationForceY*0.06, 1, {color:'rgba(120,120,120,0.38)', size: 5.8, life:11, speed:0.55, shape:'square', rotationSpeed: 0.09}); } } } const targetCenterX = dog.targetX + dog.width / 2; const targetCenterY = dog.targetY + dog.height / 2; let moveDx = 0, moveDy = 0; let primaryDx = targetCenterX - dogCenterX; let primaryDy = targetCenterY - dogCenterY; const distToTarget = Math.sqrt(primaryDx * primaryDx + primaryDy * primaryDy); const targetReachedThreshold = dog.width * 0.45; if (distToTarget > targetReachedThreshold || dog.state === DogState.DETOURING || dog.state === DogState.FLEEING) { if (distToTarget > 0) { moveDx = (primaryDx / distToTarget) * dog.currentSpeed; moveDy = (primaryDy / distToTarget) * dog.currentSpeed;} } moveDx += dog.separationForceX; moveDy += dog.separationForceY; const totalMoveMag = Math.sqrt(moveDx*moveDx + moveDy*moveDy); const maxSpeed = dog.currentSpeed * 1.30; if (totalMoveMag > maxSpeed) { moveDx = (moveDx / totalMoveMag) * maxSpeed; moveDy = (moveDy / totalMoveMag) * maxSpeed; } let finalX = dog.x; let finalY = dog.y; if (isNaN(moveDx)) moveDx = 0; if (isNaN(moveDy)) moveDy = 0; let potentialX = dog.x + moveDx; let potentialY = dog.y + moveDy; let movedX = false, movedY = false; let hitWallThisFrame = false; const directCollision = checkWallCollision(potentialX, potentialY, dog.width, dog.height); if (!directCollision) { finalX = potentialX; finalY = potentialY; movedX = Math.abs(moveDx) > 0.1; movedY = Math.abs(moveDy) > 0.1; } else { hitWallThisFrame = true; const collisionX = checkWallCollision(potentialX, dog.y, dog.width, dog.height); const collisionY = checkWallCollision(dog.x, potentialY, dog.width, dog.height); let slid = false; if (!collisionX && Math.abs(moveDx) > 0.01) { finalX = potentialX; finalY = dog.y; if (!checkWallCollision(finalX, finalY, dog.width, dog.height)) { movedX = true; slid = true; } else { finalX = dog.x; } } if (!slid && !collisionY && Math.abs(moveDy) > 0.01) { finalY = potentialY; finalX = dog.x; if (!checkWallCollision(finalX, finalY, dog.width, dog.height)) { movedY = true; slid = true; } else { finalY = dog.y; } } if (!slid && dog.state !== DogState.DETOURING && dog.state !== DogState.DAZED ) { if (directCollision) { dog.dazeTimer = Math.max(dog.dazeTimer, DOG_WALL_HIT_DAZE_DURATION); const impactPointX = clamp(potentialX + dog.width/2, dog.x, dog.x + dog.width); const impactPointY = clamp(potentialY + dog.height/2, dog.y, dog.y + dog.height); const obstacleColor = directCollision.baseColor || '#a89a8e'; createParticles(impactPointX, impactPointY, 3 + Math.random()*2, { color: obstacleColor, size: clamp(dog.currentSpeed * 1.05, 2.8, 8.0), speed: clamp(dog.currentSpeed * 0.26, 0.42, 1.6), gravity: 0.11, life: 65 + Math.random() * 45, drag: 0.935, shape: 'square', angleSpread: Math.PI*1.4 }); if (dog.currentSpeed > dog.baseSpeed * 1.08 / GAME_SPEED_MULTIPLIER) { createParticles(impactPointX, impactPointY, 1, {color: 'white', size: 4.6, speed: dog.currentSpeed * 0.20, life: 26, shape: 'spark', light: true, angleSpread: Math.PI * 1.1}); } triggerScreenShake(clamp(dog.currentSpeed * 0.68, 1.4, 4.0), 14); if (dog.state !== DogState.DETOURING) { dog.detourTimer = getRandomInt(34, 68); dog.state = DogState.DETOURING; dog.stateTimer = dog.detourTimer; let pushDx = dogCenterX - (directCollision.x + directCollision.width / 2); let pushDy = dogCenterY - (directCollision.y + directCollision.height / 2); let detourDx = 0, detourDy = 0; if (Math.abs(pushDx) > Math.abs(pushDy)) { detourDy = (pushDy > 0 ? 1 : -1) * (1 + Math.random()); } else { detourDx = (pushDx > 0 ? 1 : -1) * (1 + Math.random()); } if(detourDx === 0 && detourDy === 0) { detourDx = (Math.random() > 0.5 ? 1 : -1); detourDy = (Math.random() > 0.5 ? 1 : -1); } dog.detourTargetX = clamp(dog.x + detourDx * dog.width * 2.5, 0, canvas.width - dog.width); dog.detourTargetY = clamp(dog.y + detourDy * dog.width * 2.5, 0, canvas.height - dog.height); dog.targetX = dog.detourTargetX; dog.targetY = dog.detourTargetY; } } } } dog.x = finalX; dog.y = finalY; dog.x = clamp(dog.x, WALL_BUFFER, canvas.width - dog.width - WALL_BUFFER); dog.y = clamp(dog.y, WALL_BUFFER, canvas.height - dog.height - WALL_BUFFER); const intendedMoveDx = primaryDx; const intendedMoveDy = primaryDy; if (Math.abs(intendedMoveDx) > 0.05) { dog.facingRight = intendedMoveDx > 0; } let emitParticle = (movedX || movedY || (dog.state === DogState.DETOURING && dog.currentSpeed > 0.1)); if (emitParticle && frameCount % 10 === (dogs.indexOf(dog) % 10) ) { let particleColor = 'rgba(160, 82, 45, 0.20)'; let particleSize = 3.6; let shape = 'puff'; let speed = 0.17; if (dog.enrageTimer > 0) { particleColor = `rgba(255, ${getRandomInt(0,80)}, ${getRandomInt(0,80)}, 0.48)`; particleSize = 5.0; shape='spark'; speed=0.40; } else if (dog.state === DogState.DAZED) { particleColor = 'rgba(180, 180, 180, 0.30)'; particleSize = 3.6; shape='circle';} else if (dog.state === DogState.FLEEING) { particleColor = 'rgba(150, 150, 220, 0.30)'; particleSize = 4.0; speed=0.48;} else if (dog.state === DogState.DETOURING) { particleColor = 'rgba(190, 190, 190, 0.26)'; particleSize = 3.6;} createParticles(dog.x + dog.width / 2, dog.y + dog.height - 0.5, 1, { color: particleColor, size: particleSize + Math.random()*1.5, life: 48+Math.random()*18, speed: speed+Math.random()*0.09, speedYMultiplier: 0.023, gravity:-0.017, shape: shape, drag:0.945 }); } if (dog.enrageTimer > 0 && frameCount % 10 === 0) { createParticles(dog.x + dog.width / 2 + (Math.random()-0.5)*dog.width*0.8, dog.y + dog.height / 2+ (Math.random()-0.5)*dog.height*0.8, 1, { color: 'rgba(255,10,10,0.55)', size: 4.0 + Math.random() * 3.0, life: 17, speed: Math.random()*0.36 + 0.07, gravity: -0.042, shape:'spark', light:true }); } if (dog.state === DogState.DAZED && frameCount % 16 === 0) { createParticles(dog.x + dog.width / 2 + (Math.random()-0.5)*dog.width*0.6, dog.y + (Math.random()-0.8)*17, 1, { color: 'grey', size: 6.5, life: 55, speed: 0, gravity: -0.030, shape: '?', rotationSpeed: (Math.random()-0.5)*0.085, fadeRate: 0.026 }); } }
    function resetGame(){ cat={ x:50,y:50,width:40,height:40,maxHealth:100,health:100,invincibleTimer:0,speedBoostTimer:0, dogSlowTimer:0,goldenBoostTimer:0,intendedDx:0,intendedDy:0,isDashing:false,dashTimer:0, dashCooldownTimer:0,facingRight:true,idleBob:0, heldBird: null }; bird={x:-100,y:-100,width:32,height:32,type:BirdType.NORMAL,bobOffset:0,bobSpeed:0.05}; dogs=[]; particles=[]; pickups=[]; projectiles=[]; score=0; level=1; gameOver=false;gameWon=false;gamePaused=false;keys={};frameCount=0; lastTime=performance.now(); startTime = performance.now(); elapsedTime = 0; currentBiome = getBiomeForLevel(level); pickupSpawnTimer = PICKUP_SPAWN_TIME_FRAMES * (currentBiome.pickupSpawnTimeFactor || 1.0) * 0.8; screenShakeIntensity=0;screenShakeDuration=0;comboCounter=0;comboTimer=0;updateComboDisplay(); isLevelTransitioning=false;transitionTimer=0; fadingToWinScreen = false; winFadeTimer = 0; levelTransitionDisplay.classList.remove('visible');levelTransitionDisplay.style.display='none'; boss = null; bossAttackWave = { active: false, type: null, radius: 0, angle: 0, spread: 0, timer: 0, speed: 0, startRadius: 0 }; bossHealthBarContainer.style.display = 'none'; bossNameElement.style.display = 'none'; winScreenOverlay.classList.remove('visible'); setTimeout(() => { winScreenOverlay.style.display = 'none'; const blossoms = winScreenOverlay.querySelectorAll('.cherry-blossom'); blossoms.forEach(b => b.remove());}, 10); fadeOverlay.style.opacity = 0; fadeOverlay.style.transition = 'none'; ambientParticleTimer = 0; lastCatMoveDx = 0; lastCatMoveDy = 0; isGodModeActive = false; const cornerSafety = 80; corners = [ { x: cornerSafety, y: cornerSafety }, { x: canvas.width - cornerSafety, y: cornerSafety }, { x: cornerSafety, y: canvas.height - cornerSafety }, { x: canvas.width - cornerSafety, y: canvas.height - cornerSafety } ]; obstacles = generateObstacles(level); updateBackground(); let initialCatPos = findSafeSpawnLocation(cat.width, cat.height, 0, []); if (initialCatPos) { cat.x = initialCatPos.x; cat.y = initialCatPos.y; } else { console.error("Failed fallback spawn!"); cat.x = WALL_BUFFER + 10; cat.y = WALL_BUFFER + 10; relocateIfStuck(cat, true); } updateHealthBar();updateDashCooldownBar(); spawnBird(); const initialDogs = Math.floor((level - 1) / NEW_DOG_LEVEL_INTERVAL) + 1; for (let i = 0; i < initialDogs; i++) { spawnNewDog(); } gameOverDisplay.style.display='none';upgradeInfoDisplay.style.display='none'; damageFlashOverlay.classList.remove('active'); scoreDisplay.innerText=`Skóre: ${score}`;levelDisplay.innerText=`Úroveň: ${level}`; }
    function triggerScreenShake(intensity, duration){ screenShakeIntensity=Math.max(screenShakeIntensity, intensity * 1.1); screenShakeDuration=Math.max(screenShakeDuration, duration * (1 + Math.random()*0.15 - 0.08) ); }
    function applyScreenShake(){if(screenShakeDuration>0){const currentIntensity=screenShakeIntensity*(screenShakeDuration/(screenShakeDuration+5)); const shakeX=(Math.random()-0.5)*2*currentIntensity;const shakeY=(Math.random()-0.5)*2*currentIntensity;gameContainer.style.transform=`translate(${shakeX}px,${shakeY}px)`;screenShakeDuration--;if(screenShakeDuration<=0){screenShakeIntensity=0;gameContainer.style.transform='translate(0px,0px)';}}else if(gameContainer.style.transform!=='translate(0px,0px)'){gameContainer.style.transform='translate(0px,0px)';}}
    function triggerDamageFlash(){ if(isGodModeActive) return; damageFlashOverlay.classList.add('active'); setTimeout(() => damageFlashOverlay.classList.remove('active'), 75); healthFlashElement.classList.add('active'); setTimeout(() => healthFlashElement.classList.remove('active'), 110); }
    function incrementCombo(){ comboCounter++; comboTimer=COMBO_TIMEOUT_FRAMES; updateComboDisplay(); triggerScreenShake(0.55 + comboCounter*0.16, 4.0 + comboCounter*1.4); createParticles(comboDisplay.offsetLeft + comboDisplay.offsetWidth/2, comboDisplay.offsetTop + comboDisplay.offsetHeight/2, 1 + Math.floor(comboCounter/2), { color: `hsl(0, ${clamp(85 + comboCounter*4, 85, 100)}%, ${clamp(58 - comboCounter*2, 45, 58)}%)`, size: 6.5 + comboCounter*0.55, life: 50, speed: 2.1 + comboCounter*0.09, gravity: 0.045, shape: 'spark', light: true, angleSpread: Math.PI * 1.0 }); }
    function resetCombo(){if(comboCounter>1) { triggerScreenShake(2.6, 4.5); } comboCounter=0;comboTimer=0;updateComboDisplay();}
    function updateComboDisplay(){const visClass='visible';if(comboCounter>1){comboDisplay.textContent=`Kombo x${comboCounter}!`; comboDisplay.style.color = `hsl(0, ${clamp(85 + comboCounter*4, 85, 100)}%, ${clamp(50 - comboCounter*2.5, 38, 50)}%)`; comboDisplay.style.fontSize = `${35 + comboCounter*1.5}px`;comboDisplay.style.display='block';if(!comboDisplay.classList.contains(visClass)){comboDisplay.classList.add(visClass);comboDisplay.style.animation='none';void comboDisplay.offsetWidth; comboDisplay.style.animation=`comboPulse 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)`;}}else{comboDisplay.classList.remove(visClass);comboDisplay.style.display='none';}}
    function updateComboTimer(){if(comboTimer>0){comboTimer--;if(comboTimer<=0){resetCombo();}}}
    function checkDogCatCollision(){ if (cat.invincibleTimer > 0 || cat.isDashing || gameOver || gameWon || isGodModeActive) return; for (const dog of dogs) { if (dog.state !== DogState.STUNNED && checkRectCollision(cat, dog)){ cat.health -= CAT_DAMAGE_TAKEN; cat.health = Math.max(0, cat.health); updateHealthBar(); cat.invincibleTimer = CAT_INVINCIBILITY_DURATION_FRAMES; resetCombo(); triggerScreenShake(8.5, 23); triggerDamageFlash(); createParticles(cat.x + cat.width/2, cat.y + cat.height/2, 12, { color:`hsl(0, 100%, ${getRandomInt(50, 70)}%)`, size:getRandomInt(6.0, 12), life:85, speed:getRandomInt(2.8, 6.0), drag:.935, gravity:.19, shape:'spark', light:true, angleSpread: Math.PI * 2.1 }); createParticles(dog.x + dog.width/2, dog.y + dog.height/2, 2, {color:'white', size:5.8, speed:2.3, life:32, angle: Math.atan2(cat.y-dog.y, cat.x-dog.x), angleSpread: 0.8 }); const knockbackDirX=cat.x+cat.width/2-(dog.x+dog.width/2); const knockbackDirY=cat.y+cat.height/2-(dog.y+dog.height/2); const dist=Math.sqrt(knockbackDirX**2+knockbackDirY**2)||1; const knockbackForce=28; let pushX = (knockbackDirX / dist) * knockbackForce; let pushY = (knockbackDirY / dist) * knockbackForce; let knockedX = cat.x + pushX; let knockedY = cat.y + pushY; let attempts = 0; while (checkWallCollision(knockedX, knockedY, cat.width, cat.height) && attempts < 5) { attempts++; pushX *= 0.6; pushY *= 0.6; knockedX = cat.x + pushX; knockedY = cat.y + pushY; } if (!checkWallCollision(knockedX, knockedY, cat.width, cat.height)) { cat.x = knockedX; cat.y = knockedY; cat.x=clamp(cat.x, WALL_BUFFER, canvas.width-cat.width-WALL_BUFFER); cat.y=clamp(cat.y, WALL_BUFFER, canvas.height-cat.height-WALL_BUFFER); } else { createParticles(cat.x + cat.width/2, cat.y + cat.height/2, 2, {color:'grey', size: 3.6, speed: 0.60}); } if (cat.health <= 0) { triggerGameOver(); } return; } } }
    function checkPickupCollision() { if (cat.isDashing || isLevelTransitioning || cat.heldBird) return; for (let i = pickups.length - 1; i >= 0; i--) { const p = pickups[i]; const pickupHitbox = { x: p.x - 5, y: p.y - 5, width: p.width + 10, height: p.height + 10 }; if (checkRectCollision(cat, pickupHitbox)) { applyPickupEffect(p.type); createParticles(p.x+p.width/2, p.y+p.height/2, 10, { color:getPickupColor(p.type, true), size:10.0, life:95, speed:3.6, gravity:0.024, drag:0.945, light: true, shape: p.type === PickupType.HEALTH ? 'star' : 'spark', angleSpread: Math.PI*1.9 }); pickups.splice(i, 1); triggerScreenShake(4.0, 10); } } }
    function applyPickupEffect(type){ switch(type){ case PickupType.HEALTH: let healthAmount=48; let restored = Math.min(healthAmount, cat.maxHealth - cat.health); cat.health += restored; if (isGodModeActive) cat.health = cat.maxHealth; updateHealthBar(); createParticles(cat.x + cat.width / 2, cat.y - cat.height / 3, 1, { shape:'+', color:'#2ecc71', size:19, life:90, speed:0, gravity:-0.065, fadeRate:0.010 }); createParticles(cat.x + cat.width / 2, cat.y + cat.height / 2, 4, { color: '#2ecc71', size: 6.0, life: 50, speed: 1.4, gravity: -0.028, shape: 'star', light: true, angleSpread: Math.PI*1.3 }); triggerScreenShake(2.0, 5.5); break; case PickupType.SPEED_BOOST: cat.speedBoostTimer = PICKUP_DURATIONS[type]; createParticles(cat.x + cat.width / 2, cat.y + cat.height / 2, 7, { color: getPickupColor(type, true), size: 7.0, life: 65, speed: 2.1, shape: 'line', drag: 0.94, light: true, angleSpread: Math.PI*1.7 }); break; case PickupType.INVINCIBILITY: cat.invincibleTimer = Math.max(cat.invincibleTimer, PICKUP_DURATIONS[type]); createParticles(cat.x + cat.width / 2, cat.y + cat.height / 2, 9, { color: getPickupColor(type, true), size: 8.0, life: 75, speed: 1.6, shape: 'circle', drag: 0.95, light: true, blendMode: 'screen', angleSpread: Math.PI*2 }); break; case PickupType.DOG_SLOW: cat.dogSlowTimer = PICKUP_DURATIONS[type]; dogs.forEach(d => createParticles(d.x+d.width/2, d.y+d.height/2, 5, {color:'#aa77cc', size:7.0, speed:0.75, life: PICKUP_DURATIONS[type]*0.78, drag:0.955, gravity:-0.014, shape:'puff', angleSpread: Math.PI*2.0 })); break; case PickupType.DOG_STUN: let stunCount = 0; dogs.forEach(d => { if (d.state !== DogState.STUNNED) { d.stunTimer = DOG_STUN_DURATION; d.state = DogState.STUNNED; d.enrageTimer = 0; d.dazeTimer = 0; d.detourTimer = 0; d.losLostTimer = 0; d.currentSpeed = 0; stunCount++; createParticles(d.x+d.width/2, d.y+d.height/2, 9, { color:'hsl(55, 100%, 75%)', size:11, life:DOG_STUN_DURATION*0.70, speed:1.4, drag:.95, shape:'spark', rotationSpeed:(Math.random()-0.5)*0.45, light: true, angleSpread: Math.PI*2.1 }); } }); if (stunCount > 0) triggerScreenShake(4.8 + stunCount*0.38, 11 + stunCount*1.3); break; } if(type !== PickupType.HEALTH) updateUpgradeDisplay(); }
    function updateEffects(deltaTimeFrames = 1){ if (isGodModeActive) { cat.invincibleTimer = 9999 * 60; cat.speedBoostTimer = 0; cat.dogSlowTimer = 0; cat.goldenBoostTimer = 0; cat.health = cat.maxHealth; updateHealthBar(); updateDashCooldownBar(); } let hadBuffLastFrame = cat.invincibleTimer > 0 || cat.speedBoostTimer > 0 || cat.dogSlowTimer > 0 || cat.goldenBoostTimer > 0; if(cat.invincibleTimer > 0 && !isGodModeActive) cat.invincibleTimer = Math.max(0, cat.invincibleTimer - deltaTimeFrames); if(cat.speedBoostTimer > 0) cat.speedBoostTimer = Math.max(0, cat.speedBoostTimer - deltaTimeFrames); if(cat.dogSlowTimer > 0) cat.dogSlowTimer = Math.max(0, cat.dogSlowTimer - deltaTimeFrames); if(cat.goldenBoostTimer > 0) cat.goldenBoostTimer = Math.max(0, cat.goldenBoostTimer - deltaTimeFrames); updateDash(); let hasBuffThisFrame = cat.invincibleTimer > 0 || cat.speedBoostTimer > 0 || cat.dogSlowTimer > 0 || cat.goldenBoostTimer > 0; let buffEnded = hadBuffLastFrame && !hasBuffThisFrame && !isGodModeActive; let needsHudUpdate = false; if (hasBuffThisFrame && frameCount % 15 === 0 && !isGodModeActive) { if (cat.speedBoostTimer > 0) { createParticles(cat.x + Math.random()*cat.width, cat.y + cat.height, 1, { color: getPickupColor(PickupType.SPEED_BOOST, true), size: 4.6, life: 19, speed: 0.26, gravity: -0.048, shape: 'line'}); } if (cat.invincibleTimer > CAT_INVINCIBILITY_DURATION_FRAMES && PICKUP_DURATIONS[PickupType.INVINCIBILITY] && cat.invincibleTimer <= PICKUP_DURATIONS[PickupType.INVINCIBILITY] + 5) { createParticles(cat.x + cat.width/2, cat.y + cat.height/2, 1, { color: getPickupColor(PickupType.INVINCIBILITY, true), size: 5.6, life: 26, speed: 0, shape: 'circle', shrinkRate: 0.94, fadeRate: 0.042, light: true}); } if (cat.goldenBoostTimer > 0) { createParticles(cat.x + Math.random()*cat.width, cat.y + Math.random()*cat.height, 1, { color: 'gold', size: 4.6, life: 24, speed: 0.08, shape: 'star', light: true}); } } if (cat.dogSlowTimer > 0 && frameCount % 18 === 0) { dogs.forEach(d => { if (d.state !== DogState.STUNNED) { createParticles(d.x + d.width/2, d.y + d.height, 1, { color: '#bca0d1', size: 4.0, life: 26, speed: 0.15, gravity: 0.048, shape: 'puff'}); } }); } if ((cat.invincibleTimer > 0 && cat.invincibleTimer <= LOW_TIME_WARNING) || (cat.speedBoostTimer > 0 && cat.speedBoostTimer <= LOW_TIME_WARNING) || (cat.dogSlowTimer > 0 && cat.dogSlowTimer <= LOW_TIME_WARNING) || (cat.goldenBoostTimer > 0 && cat.goldenBoostTimer <= LOW_TIME_WARNING)) { needsHudUpdate = true; if (frameCount % 15 === 0 && !isGodModeActive) { const activeEffect = getActiveEffect(); if (activeEffect) { createParticles(upgradeInfoDisplay.offsetLeft + upgradeInfoDisplay.offsetWidth/2 + (Math.random()-0.5)*52, upgradeInfoDisplay.offsetTop + 10, 1, { color: activeEffect.color || getPickupColor(activeEffect.type, true), size: 5.6, life: 19, speed: 0.48, gravity: -0.075, shape:'spark', light:true }); } } } else if (cat.invincibleTimer > 0 || cat.speedBoostTimer > 0 || cat.dogSlowTimer > 0 || cat.goldenBoostTimer > 0) { needsHudUpdate = true; } if (buffEnded) { needsHudUpdate = true; createParticles(cat.x + cat.width/2, cat.y + cat.height/2, 8, { color: 'rgba(200, 200, 200, 0.38)', size: 8.8, life: 55, speed: 2.0, drag: 0.945, shape: 'puff', angleSpread: Math.PI*1.8 }); } if (needsHudUpdate || isGodModeActive) updateUpgradeDisplay(); }
    function getActiveEffect() { if(isGodModeActive) return {type: 'god_mode', name: 'BOŽSKÝ MÓD', timer: 999, duration: 999, color: 'gold'}; let activeEffects = []; if (cat.dogSlowTimer > 0) activeEffects.push({ type: PickupType.DOG_SLOW, timer: cat.dogSlowTimer, duration: PICKUP_DURATIONS[PickupType.DOG_SLOW] }); if (cat.speedBoostTimer > 0) activeEffects.push({ type: PickupType.SPEED_BOOST, timer: cat.speedBoostTimer, duration: PICKUP_DURATIONS[PickupType.SPEED_BOOST] }); if (cat.invincibleTimer > CAT_INVINCIBILITY_DURATION_FRAMES && PICKUP_DURATIONS[PickupType.INVINCIBILITY] && cat.invincibleTimer <= PICKUP_DURATIONS[PickupType.INVINCIBILITY] + 5) { activeEffects.push({ type: PickupType.INVINCIBILITY, timer: cat.invincibleTimer, duration: PICKUP_DURATIONS[PickupType.INVINCIBILITY] }); } if (cat.goldenBoostTimer > 0) activeEffects.push({ type: 'golden_boost', name: 'Zlatý Boost', timer: cat.goldenBoostTimer, duration: GOLDEN_BIRD_BOOST_DURATION, color: 'gold' }); if (activeEffects.length === 0) return null; activeEffects.sort((a, b) => b.timer - a.timer); return activeEffects[0]; }
    function updateHealthBar(){ const oldHealthPercent = parseFloat(healthBarElement.style.width || "100"); let currentHealth = isGodModeActive ? cat.maxHealth : cat.health; const healthPercent=(currentHealth/cat.maxHealth)*100; healthBarElement.style.width=`${clamp(healthPercent,0,100)}%`; const currentClass = healthPercent <= 0 ? 'empty' : healthPercent < 35 ? 'low' : healthPercent < 65 ? 'medium' : 'high'; healthBarElement.classList.remove('low', 'medium', 'high', 'empty'); if (healthPercent > 0) healthBarElement.classList.add(currentClass); else healthBarElement.classList.add('empty'); healthBarContainer.classList.toggle('low', healthPercent > 0 && healthPercent < 35); healthBarContainer.classList.toggle('medium', healthPercent >= 35 && healthPercent < 65); if (healthPercent > oldHealthPercent && oldHealthPercent > 0 && !isGodModeActive) { const barEndX = healthBarContainer.offsetLeft + (healthBarContainer.offsetWidth * (healthPercent/100)); const barCenterY = healthBarContainer.offsetTop + healthBarContainer.offsetHeight / 2; createParticles(barEndX, barCenterY, 2, { color: '#2ecc71', size: 5.0, life: 30, speed: 1.2, gravity: (Math.random()-0.5)*0.08, shape: 'spark', light: true, angleSpread: Math.PI*1.2 }); } }
    function updateUpgradeDisplay(){ const displayEffect = getActiveEffect(); if (displayEffect) { const remainingPercent = (displayEffect.timer / displayEffect.duration) * 100; upgradeNameElement.textContent = displayEffect.name || getPickupCzechName(displayEffect.type); upgradeDurationBarElement.style.width = `${clamp(remainingPercent, 0, 100)}%`; upgradeDurationBarElement.style.backgroundColor = displayEffect.color || getPickupColor(displayEffect.type); upgradeInfoDisplay.style.display = 'block'; if (displayEffect.timer <= LOW_TIME_WARNING && displayEffect.timer > 0 && !isGodModeActive) { if (!upgradeInfoDisplay.classList.contains('low-time')) { upgradeInfoDisplay.classList.add('low-time'); } } else { if (upgradeInfoDisplay.classList.contains('low-time')) { upgradeInfoDisplay.classList.remove('low-time'); } } } else { upgradeInfoDisplay.style.display = 'none'; if (upgradeInfoDisplay.classList.contains('low-time')) { upgradeInfoDisplay.classList.remove('low-time'); } } }
    function getPickupCzechName(t){switch(t){case PickupType.SPEED_BOOST:return"Turbo Rychlost";case PickupType.INVINCIBILITY:return"Božský Štít";case PickupType.DOG_SLOW:return"Lepidlo na Psy";case PickupType.DOG_STUN:return"Elektrošok Psů";default:return"Neznámý Bonus";}}
    function getPickupColor(t, bright = false){ switch(t){ case PickupType.HEALTH: return bright ? '#ff9a9a' : '#e74c3c'; case PickupType.SPEED_BOOST: return bright ? '#ffee58' : '#f1c40f'; case PickupType.INVINCIBILITY: return bright ? '#81d4fa' : '#3498db'; case PickupType.DOG_SLOW: return bright ? '#d8a7e8' : '#9b59b6'; case PickupType.DOG_STUN: return bright ? '#ffe082' : '#f39c12'; default: return '#bdc3c7'; } }
    function updateBackground() { if (!currentBiome) return; let backgroundStyle = ''; if (Array.isArray(currentBiome.bgColor)) { backgroundStyle = `linear-gradient(165deg, ${currentBiome.bgColor.join(', ')})`; } else { backgroundStyle = currentBiome.bgColor; } if (gameContainer.style.background !== backgroundStyle) { gameContainer.style.background = backgroundStyle; if (Array.isArray(currentBiome.bgColor)) { gameContainer.style.backgroundSize = '450% 450%'; gameContainer.style.animation = 'gradientBG 35s ease infinite alternate'; } else { gameContainer.style.backgroundSize = 'auto'; gameContainer.style.animation = 'none'; } } }
    function startBossFight() {
        console.log("Starting Boss Fight!");
        boss = {
            x: canvas.width / 2 - 75, y: canvas.height / 2 - 75, width: 150, height: 150,
            maxHealth: BOSS_MAX_HEALTH, health: BOSS_MAX_HEALTH,
            state: BossState.IDLE, stateTimer: 80,
            chargeTargetX: 0, chargeTargetY: 0,
            chargeSpeed: 7.8 * GAME_SPEED_MULTIPLIER, stompRadius: 195,
            spitSpeed: 6.8 * GAME_SPEED_MULTIPLIER, spitCount: 0, barkRadius: 230,
            phase: 1, vulnerabilityWindow: 0, hitReactionTimer: 0,
            facingRight: true
        };
        dogs = [];
        pickups = [];
        projectiles = [];
        bossAttackWave.active = false;
        updateBossHealthBar();
        bossHealthBarContainer.style.display = 'block';
        bossNameElement.style.display = 'block';
        bossNameElement.textContent = `OBŘÍ PES (Fáze ${boss.phase})`;
        arenaBirdSpawnTimer = BOSS_ARENA_BIRD_SPAWN_INTERVAL;
        triggerScreenShake(18, 45);
        createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 25, { color: '#a04040', size: 20, life: 140, speed: 6.8, drag: 0.96, shape: 'square', rotationSpeed: 0.13, angleSpread: Math.PI * 2 });
    }
    function updateBossHealthBar() {
        if (!boss) return;
        const healthPercent = (boss.health / boss.maxHealth) * 100;
        bossHealthBarElement.style.width = `${clamp(healthPercent, 0, 100)}%`;
        const phaseClass = boss.phase === 3 ? 'phase3' : boss.phase === 2 ? 'phase2' : 'phase1';
        bossHealthBarElement.className = 'bossHealthBar';
        bossHealthBarElement.classList.add(phaseClass);
    }
    function damageBoss(amount) {
        if (!boss || boss.state === BossState.DEFEATED || boss.state === BossState.PHASE_TRANSITION || boss.hitReactionTimer > 0 || fadingToWinScreen) return;
        if (isGodModeActive) amount = boss.maxHealth / 5;
        boss.health -= amount;
        boss.health = Math.max(0, boss.health);
        updateBossHealthBar();
        boss.hitReactionTimer = 20;
        boss.state = BossState.HIT_REACTION;
        boss.stateTimer = boss.hitReactionTimer;
        bossHealthFlashElement.classList.add('active');
        setTimeout(() => bossHealthFlashElement.classList.remove('active'), 140);
        triggerScreenShake(10 + amount * 4, 18 + amount * 6);
        createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 8 + amount * 3, { color: '#ffdddd', size: 8.0 + amount * 3.2, life: 70, speed: 4.1 + amount * 0.75, drag: 0.94, shape: 'spark', light: true, angleSpread: Math.PI*1.7 });

        if (boss.health <= 0 && boss.state !== BossState.DEFEATED) {
            boss.state = BossState.DEFEATED;
            boss.stateTimer = 90;
            gamePaused = true;
            triggerScreenShake(40, 110);
            createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 40, { color: `hsl(45, 100%, ${getRandomInt(68, 93)}%)`, size: 36, speed: 12.8, life: 230, gravity: 0.115, drag: 0.97, shape: 'star', light: true, rotationSpeed: 0.115, angleSpread: Math.PI*2 });
            console.log("Boss defeated! State set, animation timer started.");
            saveScoreToLeaderboard(WIN_LEVEL, elapsedTime);
        } else if (boss.health > 0) {
            const phase2Threshold = boss.maxHealth * 0.66;
            const phase3Threshold = boss.maxHealth * 0.33;
            if (boss.phase === 1 && boss.health <= phase2Threshold) {
                boss.phase = 2; boss.state = BossState.PHASE_TRANSITION; boss.stateTimer = 125; triggerScreenShake(26, 60); createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 30, { color: '#ff9800', size: 27, life: 175, speed: 8.2, drag: 0.96, shape: 'spark', light: true, angleSpread: Math.PI * 2 });
                 bossNameElement.textContent = `OBŘÍ PES (Fáze ${boss.phase})`;
            } else if (boss.phase === 2 && boss.health <= phase3Threshold) {
                boss.phase = 3; boss.state = BossState.PHASE_TRANSITION; boss.stateTimer = 135; triggerScreenShake(31, 70); createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 35, { color: '#ffea00', size: 32, life: 195, speed: 10.2, drag: 0.965, shape: 'star', light: true, angleSpread: Math.PI * 2 });
                 bossNameElement.textContent = `OBŘÍ PES (Fáze ${boss.phase})`;
            }
        }
    }
        function updateBossAttackWave(){
        if(!bossAttackWave.active || !boss) return;
        bossAttackWave.timer--;
        const bossCenterX = boss.x + boss.width / 2;
        const bossCenterY = boss.y + boss.height / 2;

        if(bossAttackWave.type === 'stomp'){
             bossAttackWave.radius += bossAttackWave.speed;
             if(frameCount % 4 === 0){
                 for(let i = 0; i < 5; i++){
                    const angle = (i / 5) * Math.PI * 2 + (Math.random()-0.5)*0.2;
                    createParticles(bossCenterX + Math.cos(angle) * bossAttackWave.radius, bossCenterY + Math.sin(angle) * bossAttackWave.radius, 1, { color: '#ffaa00', size: 11 + Math.random()*5.5, life: 28, speed: 0.55, drag: 0.92, shape:'spark', gravity: 0.06 });
                 }
             }
             const currentWaveRadius = bossAttackWave.startRadius + (45 - bossAttackWave.timer) * bossAttackWave.speed;
             if (!isGodModeActive && distance(cat.x+cat.width/2, cat.y+cat.height/2, bossCenterX, bossCenterY) < currentWaveRadius && distance(cat.x+cat.width/2, cat.y+cat.height/2, bossCenterX, bossCenterY) > currentWaveRadius - bossAttackWave.speed*4.0 && cat.invincibleTimer <= 0) {
                  cat.health -= BOSS_STOMP_DAMAGE; cat.health = Math.max(0, cat.health); updateHealthBar(); cat.invincibleTimer = CAT_INVINCIBILITY_DURATION_FRAMES * 0.70; triggerDamageFlash();
                  createParticles(cat.x + cat.width/2, cat.y + cat.height/2, 10, {color: '#ffaa00', size: 10});
                  const kbDirX_s=cat.x+cat.width/2-bossCenterX; const kbDirY_s=cat.y+cat.height/2-bossCenterY; const kbDist_s=Math.sqrt(kbDirX_s**2+kbDirY_s**2)||1; const kbForce_s=35;
                  cat.x += (kbDirX_s / kbDist_s) * kbForce_s; cat.y += (kbDirY_s / kbDist_s) * kbForce_s; relocateIfStuck(cat);
                  if (cat.health <= 0) { triggerGameOver(); }
             }
        } else if (bossAttackWave.type === 'bark') {
             bossAttackWave.radius += bossAttackWave.speed;
             const catAngle = Math.atan2(cat.y+cat.height/2 - bossCenterY, cat.x+cat.width/2 - bossCenterX);
             const angleDiff = Math.abs(catAngle - bossAttackWave.angle);
             const wrappedAngleDiff = Math.min(angleDiff, Math.PI * 2 - angleDiff);
             const currentBarkRadius = bossAttackWave.startRadius + (40 - bossAttackWave.timer) * bossAttackWave.speed;

             if (!isGodModeActive && distance(cat.x+cat.width/2, cat.y+cat.height/2, bossCenterX, bossCenterY) < currentBarkRadius &&
                 distance(cat.x+cat.width/2, cat.y+cat.height/2, bossCenterX, bossCenterY) > currentBarkRadius - bossAttackWave.speed * 5 &&
                 wrappedAngleDiff < bossAttackWave.spread / 1.9 &&
                 cat.invincibleTimer <= 0) {

                  const pushDirX_b = cat.x + cat.width/2 - bossCenterX;
                  const pushDirY_b = cat.y + cat.height/2 - bossCenterY;
                  const pushDist_b = Math.sqrt(pushDirX_b**2 + pushDirY_b**2) || 1;
                  cat.x += (pushDirX_b / pushDist_b) * BOSS_BARK_PUSH_FORCE;
                  cat.y += (pushDirY_b / pushDist_b) * BOSS_BARK_PUSH_FORCE;
                  relocateIfStuck(cat);
                  createParticles(cat.x+cat.width/2, cat.y+cat.height/2, 4, {color: '#d0d0ff', size: 6.5});
                  cat.invincibleTimer = Math.max(cat.invincibleTimer, 26);
             }
        }

        if(bossAttackWave.timer <= 0 || bossAttackWave.radius > Math.max(canvas.width, canvas.height) * 1.3 ){
            bossAttackWave.active = false;
        }
    }
    
    function saveScoreToLeaderboard(finalLevel, finalTime) {
        const user = sessionStorage.getItem('loggedInUser');
        if (user) {
            const leaderboardKey = 'ptak2_leaderboard';
            let scores = JSON.parse(localStorage.getItem(leaderboardKey)) || [];
            const userIndex = scores.findIndex(s => s.user === user);

            const currentScore = {
                user: user,
                level: finalLevel,
                time: finalTime
            };

            if (userIndex > -1) {
                const existingScore = scores[userIndex];
                if (currentScore.level > existingScore.level || (currentScore.level === existingScore.level && currentScore.time < existingScore.time)) {
                    scores[userIndex] = currentScore;
                }
            } else {
                scores.push(currentScore);
            }

            scores.sort((a, b) => b.level - a.level || a.time - b.time);
            localStorage.setItem(leaderboardKey, JSON.stringify(scores.slice(0, 50)));
        }
    }
    
    function triggerGameOver() {
        if (gameOver) return;
        gameOver = true;
        gamePaused = true;
        saveScoreToLeaderboard(level, elapsedTime);
        gameOverDisplay.style.display = 'block';
        createParticles(cat.x + cat.width / 2, cat.y + cat.height / 2, 30, { color: `hsl(0, 0%, ${getRandomInt(25, 50)}%)`, size: 16, speed: 3.0, life: 180, gravity: 0.11, drag: 0.945, angleSpread: Math.PI*2 });
        triggerScreenShake(19, 30);
    }


    function update(timestamp) {
        if (gameOver || gameWon || fadingToWinScreen) {
             return;
         }

        if (!gamePaused && !isLevelTransitioning) {
             elapsedTime = timestamp - startTime;
        }

        const physicsDelta = 1 * GAME_SPEED_MULTIPLIER;

        particles.forEach((p, i) => { p.update(); if (p.life <= 0) particles.splice(i, 1); });
        applyScreenShake();
        spawnAmbientParticles();
        updateBossAttackWave();

        frameCount++;
        updateEffects(1);
        updateComboTimer();
        handleDashInput();
        updateCatPosition();
        if (currentBiome?.isBossLevel && boss) {
             updateBossAI();
             updateProjectiles();
             arenaBirdSpawnTimer--;
             if (arenaBirdSpawnTimer <= 0 && !bird) {
                 spawnBird();
                 arenaBirdSpawnTimer = BOSS_ARENA_BIRD_SPAWN_INTERVAL;
             }
             if (boss && boss.state === BossState.DEFEATED && boss.stateTimer <= 0 && !gameWon && !fadingToWinScreen) {
                 fadingToWinScreen = true;
                 winFadeTimer = WIN_FADE_DURATION;
                 fadeOverlay.style.transition = `opacity ${WIN_FADE_DURATION / 60}s ease-in`;
                 fadeOverlay.style.opacity = 1;
                 console.log("Starting fade to win screen.");
             }
        } else {
             dogs.forEach(dog => { try { updateDogMovement(dog); } catch (e) { console.error(`Error updating dog ${dogs.indexOf(dog)}:`, e); } });
             checkDogCatCollision();
        }

        const currentPickupSpawnTime = PICKUP_SPAWN_TIME_FRAMES * (currentBiome?.pickupSpawnTimeFactor || 1.0);
        if (pickupSpawnTimer > 0 && !currentBiome?.isBossLevel) pickupSpawnTimer -= 1;
        if (pickupSpawnTimer <= 0 && pickups.length < MAX_PICKUPS && !currentBiome?.isBossLevel) {
             spawnPickup();
             pickupSpawnTimer = currentPickupSpawnTime + getRandomInt(-3.2 * 60, 3.2 * 60);
         }

        checkPickupCollision();

        if (bird && checkRectCollision(cat, bird) && !cat.isDashing && !cat.heldBird) {
             if (currentBiome?.isBossLevel) {
                 cat.heldBird = { type: bird.type, width: bird.width, height: bird.height };
                 createParticles(bird.x+bird.width/2, bird.y+bird.height/2, 5, { color: bird.type === BirdType.GOLDEN ? 'gold' : '#4dd0e1', size: 7.0, life: 60, speed: 2.7, angleSpread: Math.PI*1.7 });
                 bird = null;
             } else {
                 const isGolden = bird.type === BirdType.GOLDEN;
                 const baseScore = isGolden ? GOLDEN_BIRD_SCORE : 1;
                 const bonusPoints = comboCounter >= COMBO_BONUS_THRESHOLD ? COMBO_MAX_BONUS_POINTS + Math.floor((comboCounter-COMBO_BONUS_THRESHOLD)/2.5) : 0;
                 const totalScoreGain = baseScore + bonusPoints;
                 score += totalScoreGain;

                 createParticles(cat.x+cat.width/2, cat.y - cat.height/2, 1,{ text:`+${totalScoreGain}${bonusPoints > 0 ? '!!' : ''}`, color: isGolden?'hsl(50, 100%, 65%)':'#ff9900', size:17 + bonusPoints*2.8 + (isGolden ? 3.5 : 0), life:95, gravity:-0.065, speed:0, fadeRate:0.011 });
                 createParticles(scoreDisplay.offsetLeft + scoreDisplay.offsetWidth/2, scoreDisplay.offsetTop, 1, { text:`+${totalScoreGain}`, color: isGolden?'hsl(50, 100%, 65%)':'#ff9900', size: 11.5, life: 70, speed: 0, gravity: -0.042, fadeRate: 0.020 });

                 incrementCombo();

                 if (isGolden) {
                     cat.goldenBoostTimer = GOLDEN_BIRD_BOOST_DURATION;
                     updateUpgradeDisplay();
                     triggerScreenShake(7.5, 18);
                     createParticles(bird.x+bird.width/2, bird.y+bird.height/2, 20, { color:`hsl(50, 100%, ${getRandomInt(75, 95)}%)`, size:getRandomInt(7.5, 14), life:145, speed:getRandomInt(3.2, 6.8), gravity:.055, drag: 0.952, shape:'star', light: true, angleSpread: Math.PI*2.2 });
                 } else {
                     createParticles(bird.x+bird.width/2,bird.y+bird.height/2, 10,{ color:`hsl(${getRandomInt(0,360)}, 95%, 75%)`, size:getRandomInt(5.8, 10.0), life:125, speed:getRandomInt(2.9, 5.6), gravity:.085, drag: 0.962, angleSpread: Math.PI*2.3 });
                     triggerScreenShake(2.5 + bonusPoints*0.32, 7.0);
                 }
                 scoreDisplay.innerText=`Skóre:${score}`;
                 spawnBird();

                 dogs.forEach(d => {
                     const distToDog = distance(cat.x+cat.width/2, cat.y+cat.height/2, d.x+d.width/2, d.y+d.height/2);
                     if (d.state !== DogState.STUNNED && distToDog < DOG_ENRAGE_RANGE) {
                         if (d.enrageTimer <= 0) {
                             createParticles(d.x + d.width / 2, d.y + d.height * 0.2, 8, { color: 'red', size: 8.0, speed: 2.4, life: 70, drag: .915, shape:'spark', gravity:-0.055, angleSpread: Math.PI*1.6 });
                             triggerScreenShake(1.4, 3.2);
                         }
                         d.enrageTimer = DOG_ENRAGE_DURATION;
                         if (d.state === DogState.IDLE_WANDER || d.state === DogState.AMBUSHING || d.state === DogState.FLEEING || d.state === DogState.DAZED) {
                             d.state = DogState.CHASING;
                             d.stateTimer = 0;
                             d.dazeTimer = 0;
                         }
                     }
                 });

                 const targetLevel = Math.floor(score / SCORE_PER_LEVEL) + 1;

                 if (!isLevelTransitioning && targetLevel > level && level < WIN_LEVEL) {
                     const nextLevelActual = targetLevel;
                     const nextBiome = getBiomeForLevel(nextLevelActual);

                     isLevelTransitioning = true; gamePaused = true; transitionTimer = LEVEL_TRANSITION_DURATION;
                     levelDisplay.innerText = `Úroveň: ${nextLevelActual}`;
                     transitionLevelInfo.textContent = `Úroveň ${nextLevelActual}: ${nextBiome.name}`;
                     levelTransitionDisplay.style.display = 'flex';
                     setTimeout(() => { if (isLevelTransitioning) levelTransitionDisplay.classList.add('visible'); }, 10);
                     console.log(`Starting transition to Level ${nextLevelActual}`);

                     particles = [];
                     createParticles(cat.x + cat.width / 2, cat.y + cat.height / 2, 30, { color: '#66ff99', size: 19, life: 190, speed: 5.8, drag: 0.962, shape: 'spark', light: true, angleSpread: Math.PI*2.2 });
                     triggerScreenShake(11, 23);

                     level = nextLevelActual;
                     currentBiome = nextBiome;
                     obstacles = generateObstacles(level);
                     updateBackground();

                     console.log(`Relocating entities for level ${level} within transition...`);
                     relocateIfStuck(cat);
                     if (bird) relocateIfStuck(bird);
                      dogs.forEach((d, index) => {
                         relocateIfStuck(d);
                         d.baseSpeed = (1.3 + Math.min(level * 0.17, 2.5)) * (currentBiome?.dogBaseSpeedMult || 1.0) * GAME_SPEED_MULTIPLIER;
                         d.state = DogState.IDLE_WANDER;
                         d.stunTimer = 0; d.dazeTimer = 0; d.enrageTimer = 0; d.losLostTimer = 0; d.detourTimer = 0;
                         d.targetX = d.x; d.targetY = d.y;
                         d.stateTimer = getRandomInt(30, 90);
                     });
                     pickups.forEach(p => relocateIfStuck(p));
                     console.log(`Entity relocation complete during transition.`);
                 }
             }
        }

         if (bird) {
             bird.bobOffset = Math.sin(frameCount * bird.bobSpeed * GAME_SPEED_MULTIPLIER) * (bird.type === BirdType.GOLDEN ? 3.2 : 2.2);
             if (frameCount % 20 === 0) {
                 createParticles(bird.x + bird.width/2, bird.y + bird.height/2 + bird.bobOffset, 1, { color: bird.type === BirdType.GOLDEN ? 'rgba(255, 223, 0, 0.20)' : 'rgba(0, 188, 212, 0.14)', size: bird.type === BirdType.GOLDEN ? 5.0 : 4.0, life: 55, speed: 0.050, gravity: -0.011, shape: 'mote', fadeRate: 0.029 });
             }
         }


        try { draw(); } catch(e) { console.error("Draw error during gameplay:", e); triggerGameOver(); }
    }

     function drawObstacles() { obstacles.forEach(o => { ctx.save(); ctx.translate(o.x, o.y); const shadowY = o.height - 1.5; const shadowWidth = o.width * 0.72; const shadowHeight = o.height * 0.17; ctx.fillStyle = 'rgba(0, 0, 0, 0.16)'; ctx.beginPath(); ctx.ellipse(o.width / 2, shadowY, shadowWidth / 2, shadowHeight / 2, 0, 0, Math.PI * 2); ctx.fill(); o.shapes.forEach(shape => { ctx.save(); ctx.fillStyle = shape.color; ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 0.35; if (shape.type === 'rect') { ctx.translate(shape.x + shape.width/2, shape.y + shape.height/2); ctx.rotate(shape.rotation * Math.PI / 180); ctx.fillRect(-shape.width/2, -shape.height/2, shape.width, shape.height); if(shape.width > 1 && shape.height > 1) ctx.strokeRect(-shape.width/2, -shape.height/2, shape.width, shape.height); } else if (shape.type === 'circle') { ctx.beginPath(); ctx.arc(shape.x, shape.y, shape.radius, 0, Math.PI * 2); ctx.fill(); if(shape.radius > 1) ctx.stroke(); } else if (shape.type === 'poly') { ctx.beginPath(); ctx.moveTo(shape.points[0].x, shape.points[0].y); for (let i = 1; i < shape.points.length; i++) { ctx.lineTo(shape.points[i].x, shape.points[i].y); } ctx.closePath(); ctx.fill(); ctx.stroke(); } else if (shape.type === 'line') { ctx.strokeStyle = shape.color; ctx.lineWidth = shape.lineWidth || 1; ctx.beginPath(); ctx.moveTo(shape.x1, shape.y1); ctx.lineTo(shape.x2, shape.y2); ctx.stroke(); } ctx.restore(); }); if (o.type === ObstacleType.TREE && frameCount % 60 === 0 && Math.random() < 0.08 && currentBiome?.propColors?.treeLeaf) { createParticles(o.x + o.width * (0.2 + Math.random() * 0.6), o.y + o.height * 0.35, 1, { color: getRandomColor(...(currentBiome.propColors.treeLeaf || [80, 140, 60, 45])), shape: 'leaf', size: 4.8 + Math.random() * 2.8, life: 150, gravity: 0.028, speed: 0.28, rotationSpeed: (Math.random()-0.5)*0.08, drag: 0.985 }); } if (o.type === ObstacleType.LAMP && frameCount % 55 === 0 && Math.random() < 0.18) { const bulbShape = o.shapes.find(s => s.type === 'circle' && s.color === '#fff5cc'); if (bulbShape) { createParticles(o.x + bulbShape.x, o.y + bulbShape.y, 1, { color: 'rgba(255, 245, 204, 0.50)', shape: 'mote', size: 4.2 + Math.random() * 2.8, life: 45, speed: 0.09, gravity: -0.016, light: true, fadeRate: 0.04 }); } } if (o.type === ObstacleType.LAVA_ROCK && frameCount % 20 === 0 && Math.random() < 0.25) { createParticles(o.x + o.width * Math.random(), o.y + o.height * Math.random(), 1, { color: `hsl(${getRandomInt(10, 45)}, 100%, 58%)`, shape: 'spark', size: 3.2 + Math.random() * 4.2, life: 50, speed: 0.50, gravity: -0.05, light: true, fadeRate: 0.024 }); } if (o.type === ObstacleType.VOLCANO && frameCount % 30 === 0 && Math.random() < 0.40) { createParticles(o.x + o.width/2 + (Math.random()-0.5)*o.width*0.15, o.y + o.height*0.1, 1, { color: `hsl(${getRandomInt(15, 50)}, 100%, 65%)`, shape: 'ember', size: 4.8 + Math.random() * 6.0, life: 65, speed: 0.80, gravity: -0.11, light: true, fadeRate: 0.022 }); } if (o.type === ObstacleType.CRYSTAL && frameCount % 20 === 0 && Math.random() < 0.22) { createParticles(o.x + o.width/2 + (Math.random()-0.5)*o.width*0.6, o.y + o.height/2 + (Math.random()-0.5)*o.height*0.6, 1, { color: `hsla(${getRandomInt(240, 300)}, 85%, 85%, 0.60)`, shape: 'crystal_dust', size: 3.2 + Math.random() * 4.2, life: 45, speed: 0.16, gravity: 0, light: true, fadeRate: 0.03 }); } ctx.restore(); }); }
     function drawNonCollidingDecor() { nonCollidingDecor.forEach(d => { ctx.save(); ctx.translate(d.x, d.y); ctx.globalAlpha = 0.78 + Math.sin(frameCount * 0.05 + d.x * 0.1) * 0.08; d.shapes.forEach(shape => { ctx.save(); ctx.fillStyle = shape.color; if (shape.type === 'rect') { ctx.translate(shape.x + shape.width/2, shape.y + shape.height/2); ctx.rotate(shape.rotation * Math.PI / 180); ctx.fillRect(-shape.width/2, -shape.height/2, shape.width, shape.height); } else if (shape.type === 'circle') { ctx.beginPath(); ctx.arc(shape.x, shape.y, shape.radius, 0, Math.PI * 2); ctx.fill(); } else if (shape.type === 'line') { ctx.strokeStyle = shape.color; ctx.lineWidth = shape.lineWidth || 1; ctx.beginPath(); ctx.moveTo(shape.x1, shape.y1); ctx.lineTo(shape.x2, shape.y2); ctx.stroke();} else if (shape.type === 'poly') { ctx.beginPath(); ctx.moveTo(shape.points[0].x, shape.points[0].y); for (let i = 1; i < shape.points.length; i++) { ctx.lineTo(shape.points[i].x, shape.points[i].y); } ctx.closePath(); ctx.fill(); } ctx.restore(); }); if (d.type === ObstacleType.LAVA_POOL && frameCount % 15 === 0 && Math.random() < 0.30) { createParticles(d.x + d.width * Math.random(), d.y + d.height * Math.random(), 1, { color: `hsl(${getRandomInt(15, 45)}, 100%, 65%)`, shape: 'ember', size: 4.2 + Math.random() * 3.2, life: 45, speed: 0.28, gravity: -0.055, light: true, fadeRate: 0.038 }); } if (d.type === ObstacleType.PUDDLE && frameCount % 90 === 0 && Math.random() < 0.12) { createParticles(d.x + d.width/2, d.y + d.height/2, 1, { color: `rgba(180, 210, 240, 0.28)`, shape: 'circle', size: 2.2, life: 65, speed: 0, shrinkRate: 1.045, fadeRate: 0.02, alpha: 0.32, blendMode: 'overlay' }); } if (d.type === ObstacleType.GLOW_WORMS && frameCount % 18 === 0) { d.shapes.forEach(s => { if (Math.random() < 0.12) { createParticles(d.x + s.x, d.y + s.y, 1, { color: `hsla(${getRandomInt(60, 120)}, 95%, 90%, 0.48)`, size: s.radius * 1.7, life: 24, speed: 0, light: true, fadeRate: 0.045 }); } }); } ctx.restore(); }); ctx.globalAlpha = 1.0; }
     function drawPickups() { pickups.forEach(p => { ctx.save(); const centerX = p.x + p.width/2; const centerY = p.y + p.height/2; const baseColor = getPickupColor(p.type); const brightColor = getPickupColor(p.type, true); const timeAlive = (frameCount - p.spawnTime); const pulseFactor = Math.sin(timeAlive * 0.10) * 0.13 + 1.0; const glowAlpha = Math.sin(timeAlive * 0.08) * 0.30 + 0.50; ctx.translate(centerX, centerY); ctx.scale(pulseFactor, pulseFactor); ctx.filter = `blur(${5.5 + glowAlpha * 5.5}px)`; ctx.fillStyle = brightColor; ctx.globalAlpha = glowAlpha * 0.80; const glowSizeFactor = 1.7 + glowAlpha * 0.35; ctx.beginPath(); ctx.arc(0, 0, p.width/2 * glowSizeFactor, 0, Math.PI*2); ctx.fill(); ctx.filter = 'none'; ctx.globalAlpha = 1.0; ctx.fillStyle = baseColor; ctx.strokeStyle = 'rgba(0,0,0,0.50)'; ctx.lineWidth = 1.5 / pulseFactor; ctx.beginPath(); const w = p.width * 0.82; const h = p.height * 0.82; const x = -w/2, y = -h/2; if(p.type===PickupType.HEALTH){ const armWidth = w / 3.5; ctx.rect(x + (w - armWidth) / 2, y, armWidth, h); ctx.rect(x, y + (h - armWidth) / 2, w, armWidth); } else if(p.type===PickupType.SPEED_BOOST){ctx.moveTo(x+w*0.5,y);ctx.lineTo(x+w*0.1,y+h*0.7);ctx.lineTo(x+w*0.4,y+h*0.7);ctx.lineTo(x+w*0.25,y+h);ctx.lineTo(x+w*0.75,y+h);ctx.lineTo(x+w*0.6,y+h*0.7);ctx.lineTo(x+w*0.9,y+h*0.7);ctx.closePath();} else if(p.type===PickupType.INVINCIBILITY){ctx.arc(0,0,w/2.1,0,Math.PI*2);} else if(p.type===PickupType.DOG_SLOW){const s=w/2;ctx.moveTo(x,y+h*0.5);ctx.lineTo(x+w*0.33,y+h);ctx.lineTo(x+w*0.66,y+h);ctx.lineTo(x+w,y+h*0.5);ctx.lineTo(x+w*0.66,y);ctx.lineTo(x+w*0.33,y);ctx.closePath();} else if(p.type===PickupType.DOG_STUN){ctx.fillStyle=brightColor;const s=w/2.0;const pts=8;for(let i=0;i<pts*2;i++){const r=i%2===0?s:s*0.4;const angle=Math.PI/pts*i - Math.PI/9;ctx.lineTo(r*Math.cos(angle),r*Math.sin(angle));}ctx.closePath();} else{ctx.rect(x,y,w,h);} ctx.fill(); if(p.type !== PickupType.DOG_STUN && p.type !== PickupType.HEALTH) ctx.stroke(); if (frameCount % 18 === 0 && Math.random() < 0.20) { createParticles(centerX + (Math.random()-0.5)*w*1.3, centerY + (Math.random()-0.5)*h*1.3, 1, { color: brightColor, size: 2.6+Math.random()*2.6, life:18, speed:0.28, gravity:-0.028, light: true, fadeRate:0.07, shape:'spark' }); } ctx.restore(); }); }
     function drawProjectiles() { projectiles.forEach(p => { ctx.save(); ctx.translate(p.x + p.width/2, p.y + p.height/2); if (p.type === 'bird_projectile' && p.image) { ctx.drawImage(p.image, -p.width/2, -p.height/2, p.width, p.height); } else if (p.type === 'boss_spit') { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(0, 0, p.width/2, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = 'rgba(220, 255, 220, 0.8)'; ctx.beginPath(); ctx.arc(0, 0, p.width/3, 0, Math.PI*2); ctx.fill(); } else if (p.type === 'boss_bark_visual') { ctx.strokeStyle = p.color; ctx.lineWidth = p.lineWidth || 2.5; ctx.globalAlpha = p.alpha || 0.7; ctx.rotate(p.rotation); ctx.beginPath(); ctx.moveTo(-p.width/2, 0); ctx.lineTo(p.width/2, 0); ctx.stroke(); } ctx.restore(); }); }
     function drawBossAttackWave() { if (!bossAttackWave.active || !boss) return; ctx.save(); ctx.globalAlpha = 0.6 * (bossAttackWave.timer / 45); ctx.lineWidth = 7 + Math.sin(frameCount * 0.22) * 2.5; const bossCenterX = boss.x + boss.width/2; const bossCenterY = boss.y + boss.height/2; if (bossAttackWave.type === 'stomp') { ctx.strokeStyle = 'rgba(255, 165, 0, 0.65)'; ctx.beginPath(); ctx.arc(bossCenterX, bossCenterY, bossAttackWave.radius, 0, Math.PI * 2); ctx.stroke(); } ctx.restore(); }
     function draw(){ if (!ctx) { console.error("Canvas context not available!"); return; } ctx.globalAlpha = 1; ctx.filter = 'none'; ctx.globalCompositeOperation = 'source-over'; ctx.clearRect(0,0,canvas.width,canvas.height); drawNonCollidingDecor(); drawObstacles(); drawPickups(); drawProjectiles(); particles.filter(p => !p.light).forEach(p => p.draw()); if (bird) { const birdDrawY=bird.y+bird.bobOffset; const birdImageToDraw = bird.type === BirdType.GOLDEN ? (goldenBirdImg.complete && goldenBirdImg.naturalWidth>0 ? goldenBirdImg : birdImg) : birdImg; const birdCenterX = bird.x + bird.width/2; const birdGroundY = bird.y + bird.height * 0.95; ctx.fillStyle = `rgba(0, 0, 0, ${0.18 - Math.abs(bird.bobOffset) * 0.014})`; ctx.beginPath(); ctx.ellipse(birdCenterX, birdGroundY, bird.width*0.40, bird.height*0.15, 0, 0, Math.PI*2); ctx.fill(); if(bird.type === BirdType.GOLDEN){ ctx.save(); const goldenPulse = 0.68 + Math.sin(frameCount * 0.26) * 0.32; ctx.globalAlpha = goldenPulse * 0.78; ctx.filter = `blur(${7.5 + goldenPulse * 3.5}px) brightness(1.12)`; ctx.fillStyle = 'hsl(50, 100%, 76%)'; ctx.beginPath(); ctx.arc(birdCenterX, birdDrawY + bird.height/2, bird.width * (0.58 + goldenPulse*0.20), 0, Math.PI*2); ctx.fill(); ctx.restore(); if (frameCount % 7 === 0) { createParticles(birdCenterX, birdDrawY + bird.height/2, 1, { color: 'rgba(255, 223, 50, 0.68)', size: 3.8, life: 22, speed: 0.32, gravity: 0.02, shape: 'star', light: true }); } } if(birdImageToDraw.complete&&birdImageToDraw.naturalWidth>0){ ctx.drawImage(birdImageToDraw,bird.x,birdDrawY,bird.width,bird.height); } else { ctx.fillStyle=(bird.type===BirdType.GOLDEN)?'#FFD700':'#00BCD4'; ctx.fillRect(bird.x,birdDrawY,bird.width,bird.height); ctx.strokeRect(bird.x, birdDrawY, bird.width, bird.height); } } dogs.forEach(d => { ctx.save(); const dogCenterX=d.x+d.width/2; const dogCenterY=d.y+d.height/2; const dogGroundY = d.y + d.height; let currentScale = 1.0; let dogAlpha = 1.0; ctx.filter = 'none'; let filters = []; if (cat.dogSlowTimer > 0 && d.state !== DogState.STUNNED) { filters.push('saturate(28%) hue-rotate(175deg) brightness(0.78)'); dogAlpha *= 0.48; } if (d.state === DogState.DAZED && d.state !== DogState.STUNNED) { filters.push('blur(2.2px) brightness(0.72)'); dogAlpha *= 0.68; } if (d.state === DogState.STUNNED) { filters.push('grayscale(100%) brightness(0.45)'); dogAlpha = 0.25; } if (d.enrageTimer > 0 && d.state !== DogState.STUNNED) { const pulse = Math.abs(Math.sin(frameCount * 0.58)) * 0.92 + 0.08; filters.push(`sepia(${pulse*0.65}) brightness(1.42) hue-rotate(-38deg) drop-shadow(0 0 ${4.8+pulse*5.8}px rgba(255,0,0,${pulse*0.72}))`); dogAlpha *= (pulse * 0.1 + 0.9); currentScale = 1.0 + Math.sin(frameCount * 0.58) * 0.065; } ctx.globalAlpha = dogAlpha; if (filters.length > 0) ctx.filter = filters.join(' '); ctx.fillStyle = `rgba(0, 0, 0, ${0.24 * dogAlpha})`; ctx.beginPath(); ctx.ellipse(dogCenterX, dogGroundY - 3.5, d.width*0.35 * currentScale, d.height*0.12, 0, 0, Math.PI*2); ctx.fill(); ctx.translate(dogCenterX, dogCenterY); if (!d.facingRight) ctx.scale(-1, 1); ctx.scale(currentScale, currentScale); ctx.translate(-dogCenterX, -dogCenterY); if(dogImg.complete && dogImg.naturalWidth>0){ ctx.drawImage(dogImg, d.x, d.y, d.width, d.height); } else { ctx.fillStyle='saddlebrown'; ctx.fillRect(d.x, d.y, d.width, d.height); } if (d.state !== DogState.STUNNED) { ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 0.6 / currentScale; ctx.strokeRect(d.x, d.y, d.width, d.height); } if (d.state === DogState.STUNNED) { ctx.filter = 'none'; const stunBob = Math.sin(frameCount * 0.32) * 5.2; ctx.fillStyle = 'hsl(55, 100%, 86%)'; ctx.font = 'bold 26px sans-serif'; ctx.textAlign = 'center'; ctx.shadowColor = 'black'; ctx.shadowBlur = 5.5; ctx.shadowOffsetX = 0.8; ctx.shadowOffsetY = 0.8; const qx = d.facingRight ? d.x + d.width/2 : d.x + d.width/2; ctx.fillText('?', qx, d.y - 16 + stunBob); } ctx.restore(); }); if (boss && boss.state !== BossState.DEFEATED) { ctx.save(); const bossCenterX = boss.x + boss.width/2; const bossCenterY = boss.y + boss.height/2; const bossGroundY = boss.y + boss.height; let bossAlpha = 1.0; let bossScale = 1.0; let filters = []; ctx.filter = 'none'; if (boss.state === BossState.VULNERABLE) { bossAlpha = 0.55 + Math.sin(frameCount * 0.32) * 0.12; filters.push('grayscale(55%) brightness(0.75)'); } if (boss.state === BossState.PHASE_TRANSITION) { bossAlpha = Math.random() * 0.45 + 0.55; bossScale = 1.0 + Math.sin(frameCount * 0.45) * 0.12; filters.push(`brightness(1.6) hue-rotate(${frameCount*6}deg) drop-shadow(0 0 18px #fff)`); } if (boss.state === BossState.HIT_REACTION) { bossAlpha = 0.35 + Math.random()*0.65; filters.push('brightness(1.9) contrast(1.6)'); } if (boss.state === BossState.CHARGE_WINDUP || boss.state === BossState.STOMP_WINDUP || boss.state === BossState.SPIT_WINDUP || boss.state === BossState.BARK_WINDUP) { bossScale = 1.0 + Math.sin(frameCount*0.25) * 0.07; let shadowColor = 'rgba(255,255,255,0.7)'; if (boss.state === BossState.CHARGE_WINDUP) shadowColor = 'rgba(255,0,0,0.7)'; else if (boss.state === BossState.STOMP_WINDUP) shadowColor = 'rgba(255,165,0,0.7)'; else if (boss.state === BossState.SPIT_WINDUP) shadowColor = 'rgba(0,255,0,0.6)'; else if (boss.state === BossState.BARK_WINDUP) shadowColor = 'rgba(200,200,255,0.7)'; filters.push(`drop-shadow(0 0 ${8 + Math.sin(frameCount*0.25)*4}px ${shadowColor})`); } ctx.globalAlpha = bossAlpha; if (filters.length > 0) ctx.filter = filters.join(' '); ctx.fillStyle = `rgba(0, 0, 0, ${0.32 * bossAlpha})`; ctx.beginPath(); ctx.ellipse(bossCenterX, bossGroundY - 5.5, boss.width*0.42 * bossScale, boss.height*0.16, 0, 0, Math.PI*2); ctx.fill(); ctx.translate(bossCenterX, bossCenterY); if (!boss.facingRight) ctx.scale(-1, 1); ctx.scale(bossScale, bossScale); ctx.translate(-bossCenterX, -bossCenterY); if(bossImg.complete && bossImg.naturalWidth > 0) { ctx.drawImage(bossImg, boss.x, boss.y, boss.width, boss.height); } else { ctx.fillStyle='#654321'; ctx.fillRect(boss.x, boss.y, boss.width, boss.height); ctx.strokeRect(boss.x, boss.y, boss.width, boss.height); } ctx.restore(); } if (cat) { ctx.save(); const catDrawY = cat.y + cat.idleBob; const catCenterX = cat.x + cat.width / 2; const catCenterY = catDrawY + cat.height / 2; const catGroundY = cat.y + cat.height; let catAlpha = 1.0; let catFilters = []; ctx.filter = 'none'; let isFlashing = false; if (isGodModeActive) { const pulse = Math.sin(frameCount * 0.3) * 0.15 + 0.85; catFilters.push(`drop-shadow(0 0 ${8+pulse*5}px gold)`); } else if (cat.invincibleTimer > 0 || cat.goldenBoostTimer > 0) { isFlashing = true; const flashCycle = frameCount % 9; catAlpha = (flashCycle < 5.5) ? 1.0 : 0.12; let brightness = 1.0; let shadowColor = null; let shadowSize = 0; let baseFilter = ''; if (cat.goldenBoostTimer > 0) { brightness = 1.55; shadowColor = '#FFFACD'; shadowSize = 12.5 + Math.sin(frameCount*0.26)*3.2; baseFilter = 'saturate(120%)'; } else if (cat.invincibleTimer > CAT_INVINCIBILITY_DURATION_FRAMES && PICKUP_DURATIONS[PickupType.INVINCIBILITY] && cat.invincibleTimer <= PICKUP_DURATIONS[PickupType.INVINCIBILITY] + 5) { brightness = 1.65; shadowColor = '#b3e5fc'; shadowSize = 10.5 + Math.sin(frameCount*0.32)*4.2; baseFilter = 'contrast(108%)'; } else if (cat.invincibleTimer > 0) { brightness = 1.12; baseFilter = `brightness(${brightness})`; catAlpha = (frameCount % 7 < 4.5) ? 1.0 : 0.28; } catFilters.push(baseFilter); if (shadowColor) { catFilters.push(`drop-shadow(0 0 ${shadowSize}px ${shadowColor})`); } } if (cat.isDashing) { catAlpha = 0.48; catFilters.push('blur(0.9px)'); isFlashing = false; } ctx.globalAlpha = catAlpha; if (catFilters.length > 0) ctx.filter = catFilters.join(' '); ctx.fillStyle = `rgba(0, 0, 0, ${0.19 * catAlpha})`; ctx.beginPath(); ctx.ellipse(catCenterX, catGroundY - 1.8 + cat.idleBob*0.3, cat.width*0.35, cat.height*0.10, 0, 0, Math.PI*2); ctx.fill(); ctx.translate(catCenterX, catCenterY); if (!cat.facingRight) ctx.scale(-1, 1); ctx.translate(-catCenterX, -catCenterY); if (!isFlashing || (frameCount % 9 < 5.5)) { if(catImg.complete && catImg.naturalWidth > 0) { ctx.drawImage(catImg, cat.x, catDrawY, cat.width, cat.height); if (cat.heldBird) { const heldBirdImg = cat.heldBird.type === BirdType.GOLDEN ? goldenBirdImg : birdImg; const birdSize = cat.width * 0.45; const birdXOffset = cat.width * 0.2; const birdYOffset = -cat.height * 0.3; const birdDrawX = cat.facingRight ? cat.x + birdXOffset : cat.x + cat.width - birdXOffset - birdSize; ctx.globalAlpha = 0.9; ctx.filter = `drop-shadow(0px 3px 4px rgba(0,0,0,0.4))`; ctx.drawImage(heldBirdImg, birdDrawX, catDrawY + birdYOffset, birdSize, birdSize); ctx.filter = 'none'; ctx.globalAlpha = catAlpha; } } else { ctx.fillStyle='darkorange'; ctx.fillRect(cat.x, catDrawY, cat.width, cat.height); ctx.strokeRect(cat.x, catDrawY, cat.width, cat.height); } } ctx.restore(); } drawBossAttackWave(); particles.filter(p => p.light).forEach(p => p.draw()); ctx.globalCompositeOperation = 'source-over'; }

    function animateWinScreenCharacters() {
         const characters = winScreenOverlay.querySelectorAll('.win-character');
         const time = performance.now() * 0.002;

         characters.forEach((char, index) => {
             const swayFactor = index % 2 === 0 ? 1 : -1;
             const swayAngle = Math.sin(time * (0.8 + index * 0.1) + index) * 3 * swayFactor;
             const bounceY = Math.abs(Math.sin(time * (1.0 + index * 0.05) + index * 0.5)) * -4;
             char.style.transform = `translateY(${bounceY}px) rotate(${swayAngle}deg)`;
         });
     }

    window.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
         if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) return;
         if (key === 'r' && e.ctrlKey && (gameOver || gameWon)) { resetGame(); }
         else if (key === 'p' && !isLevelTransitioning) {
             isGodModeActive = !isGodModeActive;
             console.log(`God Mode ${isGodModeActive ? 'Activated' : 'Deactivated'}`);
             if (isGodModeActive) {
                 cat.health = cat.maxHealth;
                 cat.invincibleTimer = 9999 * 60;
             } else {
                 cat.invincibleTimer = 0;
             }
             updateHealthBar();
             updateDashCooldownBar();
             updateUpgradeDisplay();
         } else if (!gameOver && !gameWon && !isLevelTransitioning) {
             keys[key] = true;
             if (key === ' ') { e.preventDefault(); handleDashInput(); }

         }
    });

    window.addEventListener('keyup', (e) => {
         keys[e.key.toLowerCase()] = false;
    });

    function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        let deltaTimeMs = timestamp - lastTime;
        lastTime = timestamp;
        deltaTimeMs = Math.min(deltaTimeMs, 100);

        if (fadingToWinScreen) {
             winFadeTimer--;
             const fadeOpacity = clamp(1 - (winFadeTimer / WIN_FADE_DURATION), 0, 1);
             fadeOverlay.style.opacity = fadeOpacity;
             try { draw(); } catch(e) { console.error("Draw error during win fade:", e); }

             if (winFadeTimer <= 0) {
                 fadingToWinScreen = false;
                 gameWon = true;
                 gamePaused = true;
                 completionTimeDisplay.textContent = `Čas: ${formatTime(elapsedTime)}`;
                 winScreenOverlay.style.display = 'flex';
                 setTimeout(() => winScreenOverlay.classList.add('visible'), 10);
                 console.log("Win screen triggered by fade completion.");
             }
             requestAnimationFrame(gameLoop);
             return;
         }

        if (gameWon) {
             try {

                 if (winScreenOverlay.style.display === 'flex') {
                    createWinScreenParticles();
                    animateWinScreenCharacters();


                     particles.forEach((p, i) => { p.update(); if (p.life <= 0) particles.splice(i, 1); });
                     ctx.clearRect(0,0,canvas.width,canvas.height);
                     particles.filter(p => !p.light).forEach(p => p.draw());
                     particles.filter(p => p.light).forEach(p => p.draw());
                 } else if (boss && boss.state === BossState.DEFEATED && boss.stateTimer > 0) {
                      boss.stateTimer--;
                      draw();
                 }
                 applyScreenShake();
             } catch(e) {
                 console.error("Draw error during win screen:", e);
             }
              requestAnimationFrame(gameLoop);
              return;
         }

        if(gameOver) {
             try { draw(); } catch(e) { console.error("Draw error on game over:", e); }
             applyScreenShake();
             return;
        }

        if (isLevelTransitioning) {
            transitionTimer -= 1;
            updateEffects(1);
            updateUpgradeDisplay();
            if(cat) cat.idleBob = Math.sin(frameCount * 0.1) * 1.8;
            if(bird) bird.bobOffset = Math.sin(frameCount * bird.bobSpeed * GAME_SPEED_MULTIPLIER) * (bird.type === BirdType.GOLDEN ? 3.2 : 2.2);
            if (frameCount % 10 === 0 && currentBiome && Array.isArray(currentBiome.bgColor)) {
                 const bgColorMatch = currentBiome.bgColor[0].match(/\d+/);
                 const baseHue = bgColorMatch ? parseInt(bgColorMatch[0]) : 200;
                 createParticles(Math.random()*canvas.width, Math.random()*canvas.height, 1, { color: `hsla(${baseHue}, 80%, 70%, 0.20)`, size: 10 + Math.random()*14, life: 75, speed: 0, shrinkRate: 0.98, fadeRate: 0.032, shape:'circle', blendMode: 'overlay' });
             }
            if (transitionTimer <= 0) {
                isLevelTransitioning = false; gamePaused = false;
                levelTransitionDisplay.classList.remove('visible');
                setTimeout(() => { if (!isLevelTransitioning) levelTransitionDisplay.style.display = 'none'; }, 600);

                if (currentBiome.isBossLevel) {
                    startBossFight();
                } else {
                     const requiredDogs = Math.floor((level - 1) / NEW_DOG_LEVEL_INTERVAL) + 1;
                     const maxAllowedDogs = currentBiome?.maxDogs || MAX_DOGS;
                     const dogsToSpawn = Math.min(requiredDogs, maxAllowedDogs);
                     while(dogs.length < dogsToSpawn) { spawnNewDog(); }
                     if (Math.random() < 0.35) spawnPickup();
                }

                triggerScreenShake(6.0, 14);
                createParticles(canvas.width/2, canvas.height/2, 20, { color: `hsl(${level*35 % 360}, 90%, 70%)`, size: 16.0, life: 140, drag: 0.96, shape:'spark', light:true, angleSpread: Math.PI*2.2 });
                console.log(`Level ${level} (${currentBiome?.name || 'Unknown'}) started.`);
            }
            try { draw(); } catch(e) { console.error("Draw error during transition:", e); triggerGameOver(); }
            applyScreenShake();
            requestAnimationFrame(gameLoop);
            return;
        }

        if (gamePaused) {
            if (boss && boss.state === BossState.DEFEATED && boss.stateTimer > 0) {
                 boss.stateTimer--;
                 if (boss.stateTimer <= 0 && !gameWon && !fadingToWinScreen) {
                     fadingToWinScreen = true;
                     winFadeTimer = WIN_FADE_DURATION;
                     fadeOverlay.style.transition = `opacity ${WIN_FADE_DURATION / 60}s ease-in`;
                     fadeOverlay.style.opacity = 1;
                     console.log("Starting fade to win screen (from pause check).");
                 }
                 try { draw(); } catch(e) { console.error("Draw error during pause check:", e); }
                 applyScreenShake();
             }
             requestAnimationFrame(gameLoop);
             return;
         }


        try {
            update(timestamp);
        } catch(e) {
             console.error("!!! Critical error in update loop:", e);
             triggerGameOver();
              return;
         }

        requestAnimationFrame(gameLoop);
    }

    let imagesLoadedCount = 0, totalImages = 5;
    function imageLoaded(img) {
        console.log(`Image loaded: ${img.src}`);
        imagesLoadedCount++;
        if(imagesLoadedCount === totalImages) {
            console.log("All images loaded, starting game...");
            resetGame();
            requestAnimationFrame(gameLoop);
        }
    }

    function imageError(img) {
         console.error(`Failed to load image: ${img.src}. Reducing total image count.`);
         totalImages--;
         if(img === goldenBirdImg) console.warn("Golden Bird image fallback needed.");
         if (img === catImg || img === dogImg || img === birdImg || img === bossImg) {
             console.error(`CRITICAL ERROR: Could not load essential image ${img.src}. Game will likely break!`);
         }
         if(imagesLoadedCount === totalImages && totalImages > 0) {
             console.warn("Some images failed to load, starting game anyway...");
             resetGame();
             requestAnimationFrame(gameLoop);
         } else if (totalImages <= 0 && imagesLoadedCount === 0) {
             console.error("CRITICAL ERROR: No essential images could be loaded. Game cannot start.");
             alert("Critical Error: No essential images could be loaded. Game cannot start.");
         }
    }

    catImg.onload = () => imageLoaded(catImg); catImg.onerror = () => imageError(catImg);
    birdImg.onload = () => imageLoaded(birdImg); birdImg.onerror = () => imageError(birdImg);
    dogImg.onload = () => imageLoaded(dogImg); dogImg.onerror = () => imageError(dogImg);
    goldenBirdImg.onload = () => imageLoaded(goldenBirdImg); goldenBirdImg.onerror = () => imageError(goldenBirdImg);
    bossImg.onload = () => imageLoaded(bossImg); bossImg.onerror = () => imageError(bossImg);

</script>

</body>
</html>