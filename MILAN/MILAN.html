<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Milanovy klob√°sy</title>
<style>
body, html { margin: 0; padding: 0; overflow: hidden; height: 100%; width: 100%; background-color: #3a8f2e; font-family: 'Courier New', Courier, monospace; }

.screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        z-index: 1000; display: flex; flex-direction: column;
        justify-content: center; align-items: center; text-align: center; color: white;
        overflow: hidden;
    }
    .screen-bg {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background-image: url('hospoda.png');
        background-size: cover; background-position: center;
        filter: blur(8px);
        transform: scale(1.1);
        z-index: -1;
    }
    .screen h1 { font-size: 5vw; text-shadow: 4px 4px 8px #000; margin-bottom: 10px; }
    .screen p { font-size: 1.2vw; max-width: 600px; margin: 0 auto 20px; text-shadow: 2px 2px 4px #000; }

    #milan-start-art { position: relative; width: 400px; height: 300px; display: flex; justify-content: center; align-items: center; }
    #milan-start-img { width: 200px; height: 200px; background-image: url('milan.png'); background-size: cover; animation: dance 2s ease-in-out infinite; z-index: 10; }
    @keyframes dance { 0%, 100% { transform: rotate(-5deg) scale(1); } 50% { transform: rotate(5deg) scale(1.05); } }

    .button-container {
        margin-top: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }
    .button-container button { font-family: 'Courier New', Courier, monospace; font-size: 24px; padding: 10px 20px; cursor: pointer; border: 3px solid white; background-color: #8B4513; color: white; border-radius: 5px; width: 200px; }
    #lang-switch-btn { font-size: 16px; background-color: #5C4033; }
    
    #game-over { display: none; }
    #game-over p { font-size: 1.5vw; }

    #game-world { position: relative; width: 100%; height: 100%; overflow: hidden; transition: filter 0.5s ease, transform 0.1s; }
    #river { position: absolute; left: 0; top: 0; width: 280px; height: 100%; background-color: #4682B4; overflow: hidden; }
    .wave { position: absolute; width: 15px; height: 3px; background-color: rgba(255, 255, 255, 0.6); border-radius: 50%; animation: flow 5s linear infinite; }
    @keyframes flow { from { transform: translateY(110vh); } to { transform: translateY(-10vh); } }
    .tree { position: absolute; z-index: 15; }
    .tree .trunk { position: absolute; bottom: 0; background-color: #5C4033; }
    .tree .crown { position: absolute; }
    .tree.deciduous .trunk { width: 20px; height: 80px; }
    .tree.deciduous .crown { bottom: 60px; left: -40px; width: 100px; height: 100px; border-radius: 40% 60% 45% 55% / 50% 45% 55% 50%; }
    .tree.pine .trunk { width: 15px; height: 120px; }
    .tree.pine .crown { position: absolute; bottom: 80px; left: -33px; width: 80px; height: 120px; }
    .tree.pine .crown::before, .tree.pine .crown::after { content: ''; position: absolute; width: 0; height: 0; border-left: 40px solid transparent; border-right: 40px solid transparent; left: 0; }
    .tree.pine .crown::before { border-bottom: 80px solid #1a4325; top: 0; transform: scale(1.1); }
    .tree.pine .crown::after { border-bottom: 60px solid #1e5631; top: 40px; }
    .stone { position: absolute; background-color: #808080; border-radius: 40% 60% 45% 55% / 50% 45% 55% 50%; z-index: 1; }
    .path-stone { position: absolute; background-color: #6b6b6b; border-radius: 30% 70% 25% 75% / 50% 40% 60% 50%; z-index: 1; }
    .grass-patch { position: absolute; background-color: #348029; border-radius: 40% 60% 45% 55% / 50% 45% 55% 50%; z-index: 1; opacity: 0.8; }
    .flower { position: absolute; z-index: 1; width: 20px; height: 20px; }
    .flower-center { position: absolute; width: 8px; height: 8px; background: yellow; border-radius: 50%; top: 6px; left: 6px; }
    .flower-petal { position: absolute; width: 10px; height: 10px; background: white; border-radius: 50%; border: 1px solid #ddd; }
    .p1 { top: 0; left: 5px; } .p2 { top: 5px; left: 0; } .p3 { top: 10px; left: 5px; } .p4 { top: 5px; left: 10px; }
    #stall { 
        position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); 
        width: 750px; height: 450px; 
        background: #DEB887;
        background-image: repeating-linear-gradient(to bottom, transparent, transparent 28px, rgba(0,0,0,0.1) 30px),
                          repeating-linear-gradient(to right, #DEB887, #DEB887 100px, #d1a974 102px);
        border: 8px solid #5C4033; 
        z-index: 3; 
        box-sizing: border-box;
    }
    #sauce-warning-sign {
        position: absolute;
        width: 150px;
        background-color: #FFFACD;
        border: 2px solid #8B4513;
        padding: 5px;
        text-align: center;
        z-index: 4;
        font-family: 'Courier New', Courier, monospace;
        font-size: 11px;
        box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    #sauce-warning-sign p {
        margin: 2px 0;
        font-weight: bold;
    }
    .cooler { position: absolute; background-color: #c0c0c0; border: 3px solid #555; width: 80px; height: 50px; } .cooler::before { content:''; position: absolute; top: 5px; left: 0; width: 100%; height: 2px; background: #555; }
    .chair { position: absolute; width: 30px; height: 50px; z-index: 4; }
    .chair .back { width: 100%; height: 30px; background: linear-gradient(#a55a30, #8B4513); position: absolute; top: 0; border-radius: 3px 3px 0 0; border: 1px solid #5C4033; box-sizing: border-box; }
    .chair .seat { width: 100%; height: 20px; background: #A0522D; position: absolute; bottom: 0; border: 2px solid #5C4033; box-sizing: border-box; border-top: none; }
    .chair .leg { position: absolute; width: 5px; height: 15px; background: #8B4513; bottom: -15px; }
    .chair .leg.front-left { left: 2px; } .chair .leg.front-right { right: 2px; }
    .chair .leg.back-left { left: 2px; bottom: -15px; z-index: -1; background: #6a340f; } .chair .leg.back-right { right: 2px; bottom: -15px; z-index: -1; background: #6a340f; }
    .relax-table { position: absolute; width: 40px; height: 30px; background: #A0522D; border: 2px solid #8B4513; border-radius: 2px;} .relax-table::after { content:''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%); width: 8px; height: 8px; background: #8B4513;}
    #grill { position: absolute; width: 220px; height: 120px; background-color: #36454F; border: 3px solid #000; border-radius: 5px; z-index: 4; }
    #outhouse { position: absolute; right: 80px; top: 60%; width: 80px; height: 120px; background: linear-gradient(90deg, #8B4513 80%, #7a3d11 80%); border: 2px solid #5C4033; z-index: 2; transition: transform 0.1s ease-in-out; }
    #outhouse::before { content:''; position:absolute; left:0; top:0; width:100%; height:100%; background: repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(0,0,0,0.2) 20px); }
    #outhouse.shake { animation: shake-it 0.5s infinite; }
    @keyframes shake-it { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px) rotate(-2deg); } 75% { transform: translateX(5px) rotate(2deg); } }
    #outhouse-roof { position: absolute; top: -20px; left: -10px; width: 100px; height: 20px; background-color: #5C4033; transform: skew(-20deg); }
    #outhouse-heart { position: absolute; top: 30px; left: 30px; width: 20px; height: 20px; background-color: #3a8f2e; }
    #outhouse-heart::before, #outhouse-heart::after { content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; background-color: #3a8f2e; } #outhouse-heart::before { top: -10px; left: 0; } #outhouse-heart::after { top: 0; left: 10px; }
    .seating-area { position: absolute; } .table { width: 120px; height: 50px; background-color: #A0522D; border: 3px solid #5C4033; } .bench { width: 140px; height: 20px; background-color: #A0522D; position: absolute; left: -10px; } .bench.top { top: -25px; } .bench.bottom { bottom: -25px; }
    #milan { position: absolute; width: 50px; height: 50px; background-image: url('milan.png'); background-size: cover; z-index: 10; }
    .item { position: absolute; z-index: 5; }
    .sausage { width: 48px; height: 12px; border-radius: 6px; border: 1px solid #8B4513; }
    .cheese { width: 30px; height: 30px; border-radius: 50%; border: 1px solid #8B4513; }
    .plate { width: 60px; height: 72px; background-color: #f0f0f0; border-radius: 3px; border: 1px solid #ccc; }
    .bread { width: 25px; height: 25px; background-color: #D2B48C; border: 1px solid #8B4513; border-radius: 3px; }
    .static-object { position: absolute; z-index: 4; }
    .ketchup-bottle, .mustard-bottle, .cranberries-pot, .vodka-bottle, .cigarettes-box { position: absolute; }
    .ketchup-bottle { width: 15px; height: 36px; background-color: red; border-radius: 3px 3px 0 0; }
    .mustard-bottle { width: 15px; height: 36px; background-color: #FFDB58; border-radius: 3px 3px 0 0; }
    .cranberries-pot { width: 24px; height: 18px; background-color: #d94468; border-radius: 3px; }
    .vodka-bottle { position: relative; width: 25px; height: 70px; background: linear-gradient(to right, rgba(200, 200, 255, 0.5), rgba(255,255,255,0.8), rgba(200, 200, 255, 0.5)); border: 1px solid #88a; clip-path: polygon(0 100%, 0 25%, 30% 10%, 30% 0, 70% 0, 70% 10%, 100% 25%, 100% 100%); }
    .vodka-bottle::before { content:''; position: absolute; top: 0; left: 30%; width: 40%; height: 5px; background: #444; }
    .vodka-label { z-index: 1; font-size: 8px; color: #fff; background: #c00; padding: 1px 0; border: 1px solid #fff; text-shadow: 1px 1px 1px #000; user-select: none; position: absolute; top: 30px; left: -10px; width: 45px; transform: rotate(-90deg); text-align: center; }
    .cigarettes-box { width: 30px; height: 40px; background: linear-gradient(#eee, #fff); border: 1px solid #999; box-shadow: 1px 1px 3px rgba(0,0,0,0.3); }
    .cigarettes-box::before { content: 'Marlboro'; font-size: 7px; text-align: center; color: white; font-weight: bold; position: absolute; top: 0; left: 0; width: 100%; height: 15px; background-color: #d42121; line-height: 15px; letter-spacing: -0.5px; }
    .raw-sausage { background-color: #FFC0CB; } .golden-sausage { background-color: #DAA520; } .welldone-sausage { background-color: #A0522D; } .burnt-sausage { background-color: #3b2707; }
    .raw-cheese { background-color: #F5F5DC; } .golden-cheese { background-color: #F0E68C; } .welldone-cheese { background-color: #D2B48C; } .burnt-cheese { background-color: #5a4d36; }
    .ketchup-splash { position: absolute; width: 100%; height: 3px; background-color: red; top: 45%; }
    .mustard-splash { position: absolute; width: 100%; height: 3px; background-color: #FFDB58; top: 55%; }
    .cranberries-splash { position: absolute; width: 18px; height: 18px; background-color: #d94468; border-radius: 50%; top: 6px; left: 6px; }
    .smoke { position: absolute; width: 6px; height: 6px; background-color: rgba(200, 200, 200, 0.6); border-radius: 50%; animation: smoke-drift 3s ease-out forwards; pointer-events: none; z-index: 12; }
    @keyframes smoke-drift { from { transform: translateY(0) scale(1); opacity: 0.8; } to { transform: translateY(-100px) translateX(40px) scale(3.5); opacity: 0; } }
    #trash-can { position: absolute; width: 50px; height: 70px; background-color: #696969; border-bottom-left-radius: 10px; border-bottom-right-radius: 10px; z-index: 4; }
    
    .deco-vessel { position: absolute; transition-property: top; transition-timing-function: linear; z-index: 2; }
    .kayak { width: 50px; position: relative; }
    .kayak-body { width: 100%; height: 100%; clip-path: polygon(50% 0%, 100% 15%, 100% 85%, 50% 100%, 0 85%, 0 15%); position: relative; }
    .kayak.red .kayak-body { background-color: #DC143C; } .kayak.green .kayak-body { background-color: #008000; } .kayak.blue .kayak-body { background-color: #0000CD; }
    .kayak-person { position: absolute; width: 20px; height: 20px; background-color: #FFDAB9; border-radius: 50%; border: 2px solid #d3a98d; box-sizing: border-box;}
    .big-ship { width: 100px; height: 200px; background-color: #708090; }
    .big-ship::before { content: ''; position: absolute; width: 70px; height: 40px; background: #D3D3D3; top: 15px; left: 15px; }
    .big-ship::after { content: ''; position: absolute; width: 0; height: 0; border-left: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 20px solid #A9A9A9; top: -5px; left: 30px; }
    .raft { width: 70px; height: 100px; }
    .raft::before { content: ''; position: absolute; width: 100%; height: 100%; background: repeating-linear-gradient(to right, #8B4513, #8B4513 15px, #6a340f 16px, #6a340f 18px); }
    .raft-person { position: absolute; top: 40px; left: 25px; width: 20px; height: 20px; background-color: #FFDAB9; border-radius: 50%; border: 2px solid #d3a98d; box-sizing: border-box;}

    .customer-figure { position: absolute; width: 40px; height: 70px; transition: left 3s ease-in-out, top 3s ease-in-out; z-index: 9; }
    .customer-figure .head { width: 22px; height: 22px; background-color: #FFDAB9; border-radius: 50%; margin: 0 auto; position: relative; border: 1px solid #d3a98d; z-index: 2; }
    .customer-figure .face .eye { position: absolute; width: 3px; height: 3px; background: black; border-radius: 50%; top: 9px; }
    .customer-figure .face .eye.left { left: 5px; } .customer-figure .face .eye.right { right: 5px; }
    .customer-figure .face .mouth { position: absolute; bottom: 4px; left: 50%; transform: translateX(-50%); width: 8px; height: 3px; border-bottom: 2px solid #a56851; border-radius: 0 0 4px 4px; }
    .customer-figure .hair { position: absolute; top: -8px; left: 50%; transform: translateX(-50%); color: #3d2d1b; z-index: 3; }
    .hair.style1 { width: 26px; height: 14px; background: currentColor; border-radius: 50% 50% 20% 20% / 80% 80% 20% 20%; top: -10px; }
    .hair.style2 { width: 28px; height: 18px; background: currentColor; border-radius: 40% 40% 0 0; top: -10px; }
    .hair.style4 { width: 2px; height: 10px; background: currentColor; top: -6px; box-shadow: -7px 1px 0 0.5px currentColor, 7px 1px 0 0.5px currentColor, -3.5px -1px 0 0.5px currentColor, 3.5px -1px 0 0.5px currentColor, 10.5px 3px 0 0.5px currentColor, -10.5px 3px 0 0.5px currentColor, 0 -2px 0 0.5px currentColor; }
    .customer-figure .torso { width: 32px; height: 28px; margin: 0 auto; position: relative; top: -2px; border-radius: 15px 15px 5px 5px; }
    .customer-figure .arm { width: 8px; height: 26px; position: absolute; top: 23px; border-radius: 4px; z-index: 0; }
    .customer-figure .leg { width: 9px; height: 22px; position: absolute; top: 48px; border-radius: 5px; z-index: 0; }
    
    .customer-figure.man .torso { background-color: #FFDAB9; clip-path: polygon(0 0, 100% 0, 85% 100%, 15% 100%); }
    .customer-figure.man .shorts { width: 26px; height: 14px; background-color: #0000FF; margin: 0 auto; position: absolute; top: 49px; left: 7px; border-top: 2px solid rgba(0,0,0,0.2); box-sizing: border-box; z-index: 1; }
    .shorts.style-a { clip-path: polygon(0 0, 100% 0, 100% 100%, 60% 100%, 50% 85%, 40% 100%, 0 100%); }
    .shorts.style-boardshorts { height: 18px; }
    .shorts.style-speedo { height: 10px; top: 48px; clip-path: polygon(10% 0, 90% 0, 100% 100%, 0 100%);}
    .customer-figure.man .arm.left { left: 2px; } .customer-figure.man .arm.right { right: 2px; }
    .customer-figure.man .leg.left { left: 6px; } .customer-figure.man .leg.right { right: 6px; }
    
    .customer-figure.woman .torso { background: #FFDAB9; width: 28px; clip-path: polygon(20% 0, 80% 0, 95% 100%, 5% 100%); }
    .customer-figure.woman.curvy .torso { clip-path: polygon(25% 0, 75% 0, 100% 100%, 0 100%); }
    .customer-figure.woman .torso::before, .customer-figure.woman .torso::after { content: ''; position: absolute; background-color: #FFDAB9; border: 1px solid #d3a98d; box-sizing: border-box; z-index: -1; }
    .customer-figure.woman .torso.boobs-small::before, .customer-figure.woman .torso.boobs-small::after { width: 9px; height: 9px; border-radius: 50%; top: 6px; }
    .customer-figure.woman .torso.boobs-medium::before, .customer-figure.woman .torso.boobs-medium::after { width: 11px; height: 11px; border-radius: 50%; top: 5px; }
    .customer-figure.woman .torso.boobs-large::before, .customer-figure.woman .torso.boobs-large::after { width: 13px; height: 13px; border-radius: 50%; top: 4px; }
    .customer-figure.woman .torso.boobs-small::before, .customer-figure.woman .torso.boobs-medium::before, .customer-figure.woman .torso.boobs-large::before { left: 1px; }
    .customer-figure.woman .torso.boobs-small::after, .customer-figure.woman .torso.boobs-medium::after, .customer-figure.woman .torso.boobs-large::after { right: 1px; }
    .customer-figure.woman .arm.left { left: 4px; } .customer-figure.woman .arm.right { right: 4px; }
    .customer-figure.woman .leg.left { left: 8px; } .customer-figure.woman .leg.right { right: 8px; }

    .one-piece-suit { position: absolute; top: 25px; left: 6px; width: 28px; height: 35px; z-index: 1; clip-path: polygon(20% 0, 80% 0, 100% 80%, 80% 100%, 20% 100%, 0 80%); }
    .bikini-top, .bikini-bottom { position: absolute; z-index: 1; background-color: inherit; }
    .bikini-top { top: 28px; left: 8px; width: 24px; height: 12px; }
    .bikini-top.style-triangle { clip-path: polygon(10% 20%, 25% 0, 75% 0, 90% 20%, 50% 80%); top: 29px; }
    .bikini-top.style-bandeau { height: 8px; top: 30px; clip-path: none; border-radius: 2px; }
    .bikini-top.style-circles-connected::before, .bikini-top.style-circles-connected::after { content: ''; position: absolute; width: 10px; height: 10px; background-color: inherit; border-radius: 50%; top: 0px; }
    .bikini-top.style-circles-connected::before { left: 2px; } .bikini-top.style-circles-connected::after { right: 2px; }
    .bikini-top.style-circles-connected { background-color: transparent; border-bottom: 2px solid; border-color: inherit; top: 29px; height: 0; }
    .bikini-top.style-balls::before, .bikini-top.style-balls::after { content: ''; position: absolute; width: 10px; height: 10px; background-color: inherit; border-radius: 50%; top: 2px; }
    .bikini-top.style-balls::before { left: 2px; } .bikini-top.style-balls::after { right: 2px; }
    .bikini-bottom { top: 49px; left: 8px; width: 26px; height: 9px; }
    .bikini-bottom.style-a { clip-path: polygon(10% 0, 90% 0, 85% 100%, 15% 100%); }
    .bikini-bottom.style-b { clip-path: polygon(15% 0, 85% 0, 100% 100%, 0% 100%); width: 28px; left: 6px;}
    .bikini-bottom.style-thong { background: transparent; }
    .bikini-bottom.style-thong::before { content: ''; position: absolute; top:0; left: -2px; width: 30px; height: 1px; background-color: inherit; }
    .bikini-bottom.style-thong::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: inherit; clip-path: polygon(40% 0, 60% 0, 55% 100%, 45% 100%); }
    
    .customer-figure.obese .torso { width: 38px; transform: scaleY(0.9); }
    .customer-figure.obese.man .torso { clip-path: polygon(0 0, 100% 0, 90% 100%, 10% 100%); }
    .customer-figure.obese.woman .torso { width: 34px; clip-path: polygon(15% 0, 85% 0, 100% 100%, 0% 100%); }
    .customer-figure.obese .leg { width: 11px; }
    .customer-figure.obese .arm { width: 10px; }
    .customer-figure.obese .shorts, .customer-figure.obese.woman .bikini-bottom { width: 30px; left: 5px; }
    .customer-figure.obese .one-piece-suit { width: 34px; left: 3px; clip-path: polygon(15% 0, 85% 0, 100% 85%, 85% 100%, 15% 100%, 0 85%); }

    .speech-bubble { visibility: hidden; position: absolute; background: white; border-radius: .4em; padding: 10px; min-width: 150px; max-width: 200px; bottom: 80px; left: 50%; transform: translateX(-50%); z-index: 20; border: 2px solid black; font-size: 14px; opacity: 0; transition: opacity 0.5s; }
    .speech-bubble.visible { visibility: visible; opacity: 1; }
    .speech-bubble:after { content: ''; position: absolute; bottom: 0; left: 50%; width: 0; height: 0; border: 15px solid transparent; border-top-color: black; border-bottom: 0; margin-left: -15px; margin-bottom: -15px; }
    .wait-timer-container { position: absolute; top: -15px; left: 0; width: 100%; height: 6px; background-color: #555; border: 1px solid #000; border-radius: 3px; visibility: hidden; }
    .wait-timer-bar { width: 100%; height: 100%; background-color: #32CD32; border-radius: 2px; transition: width 0.5s linear; }
    #ui-container { position: absolute; top: 10px; right: 10px; z-index: 100; color: white; text-shadow: 2px 2px 4px #000; }
    #stress-bar-container { width: 200px; height: 30px; background-color: #ccc; border: 2px solid black; }
    #stress-bar { width: 0%; height: 100%; background-color: red; transition: width 0.5s; }
    #timer { margin-top: 10px; font-size: 24px; }
    .sausage-stack-item, .cheese-stack-item, .plate-stack-item, .bread-stack-item { position: absolute; pointer-events: none; }
    .sausage-stack-item { width: 48px; height: 12px; background-color: #FFC0CB; border-radius: 6px; border: 1px solid #8B4513; }
    .cheese-stack-item { width: 30px; height: 30px; background-color: #F5F5DC; border-radius: 50%; border: 1px solid #8B4513; }
    .plate-stack-item { width: 60px; height: 72px; background-color: #f0f0f0; border-radius: 3px; border: 1px solid #ccc; }
    .bread-stack-item { width: 25px; height: 25px; background-color: #D2B48C; border: 1px solid #8B4513; border-radius: 3px; }
    .milan-bubble { position: absolute; background: white; padding: 5px 10px; border: 1px solid black; border-radius: 5px; z-index: 100; font-weight: bold; }
    .cigarette-visual { position: absolute; width: 40px; height: 6px; background: white; border: 1px solid #aaa; z-index: 11; border-radius: 2px; transform-origin: left center; }
    .cigarette-visual::after { content:''; position: absolute; right: 0; top: 0; height: 100%; width: 5px; background: orange; animation: burn 5s linear forwards; }
    @keyframes burn { from { width: 5px; } to { width: 40px; } }
    .supply-table-container, .silver-table-container { z-index: 3; position: absolute; }
    .supply-table-top { position: absolute; background-color: #A0522D; border: 3px solid #8B4513; border-radius: 4px; z-index: 2; }
    .supply-table-leg { position: absolute; background-color: #8B4513; width: 10px; height: 20px; z-index: 1; }
    .silver-table-top { position: absolute; background-color: #c0c0c0; border: 3px solid #555; border-radius: 4px; z-index: 2; }
    .silver-table-leg { position: absolute; background-color: #555; width: 10px; height: 20px; z-index: 1; }
    .poop-particle { position: absolute; width: 8px; height: 8px; background: #5C4033; border-radius: 50%; animation: fade-out-fast 2.5s forwards; opacity: 0.8; }
    @keyframes fade-out-fast { to { opacity: 0; transform: scale(0.2); } }
    .dirt-particle { position: absolute; width: 7px; height: 7px; background: #8B4513; border-radius: 2px; animation: kick-up 0.8s ease-out forwards; }
    @keyframes kick-up { from { transform: translateY(0) scale(1); opacity: 0.9; } to { transform: translateY(-40px) translateX(20px) scale(0) rotate(360deg); opacity: 0; } }
    .drunk-particle { position: absolute; width: 15px; height: 15px; border-radius: 50%; pointer-events: none; animation: float-up 2s ease-out forwards; z-index: 200; }
    @keyframes float-up { from { transform: translateY(0) scale(1); opacity: 0.7; } to { transform: translateY(-200px) scale(0); opacity: 0; } }
    .poop-stain { position: absolute; background-color: #5a4d36; opacity: 0.6; z-index: 1; }
</style>
</head>
<body>
<div id="start-screen" class="screen">
<div class="screen-bg"></div>
<h1></h1>
<p id="start-screen-subtitle"></p>
<div id="milan-start-art">
<div id="milan-start-img"></div>
</div>
<div class="button-container">
<button id="start-btn"></button>
<button id="lang-switch-btn"></button>
</div>
</div>
<div id="game-world">
    <div id="river"></div>
    <div id="stall">
         <div id="sauce-warning-sign">
            <p id="sauce-warning-cs"></p>
            <p id="sauce-warning-en"></p>
         </div>
         <div id="grill"></div>
         <div id="trash-can"></div>
    </div>
    <div id="outhouse"><div id="outhouse-roof"></div><div id="outhouse-heart"></div></div>
    <div id="milan"></div>
</div>
<div id="ui-container">
    <div><span id="stress-label"></span>:</div>
    <div id="stress-bar-container"><div id="stress-bar"></div></div>
    <div id="timer"></div>
</div>
<div id="game-over" class="screen">
    <div class="screen-bg"></div>
    <h1 id="game-over-title"></h1>
    <p id="end-reason"></p>
    <p id="end-score"></p>
    <p id="end-orders"></p>
    <div class="button-container">
        <button id="play-again-btn"></button>
    </div>
</div>

<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

<script>
    (function() {
        const firebaseConfig = {
            apiKey: "AIzaSyDNzjX6dmx2fGPhLW-ZIADhNigsfwMY3Ng",
            authDomain: "tom-fun.firebaseapp.com",
            databaseURL: "https://tom-fun-default-rtdb.firebaseio.com",
            projectId: "tom-fun",
            storageBucket: "tom-fun.appspot.com",
            messagingSenderId: "710857129785",
            appId: "1:710857129785:web:5f2cdebe736577ea0e72e8"
        };
        
        try {
            const app = firebase.apps.length ? firebase.app() : firebase.initializeApp(firebaseConfig, "presenceApp");
            const auth = firebase.auth(app);
            const rtdb = firebase.database(app);

            auth.onAuthStateChanged(user => {
                let uid;
                if (user) {
                    uid = user.uid;
                    setupPresence(uid, rtdb);
                } else {
                    auth.signInAnonymously().catch(err => console.error("Anonymous sign-in for presence failed:", err));
                }
            });

            function setupPresence(uid, rtdb) {
                const userStatusDatabaseRef = rtdb.ref('/status/' + uid);
                const isOfflineForDatabase = { state: 'offline', last_changed: firebase.database.ServerValue.TIMESTAMP };
                const isOnlineForDatabase = { state: 'online', last_changed: firebase.database.ServerValue.TIMESTAMP };
                
                rtdb.ref('.info/connected').on('value', function(snapshot) {
                    if (snapshot.val() == false) return;
                    userStatusDatabaseRef.onDisconnect().set(isOfflineForDatabase).then(function() {
                        userStatusDatabaseRef.set(isOnlineForDatabase);
                    });
                });
            }

        } catch (e) {
            console.error("Firebase presence initialization failed in game:", e);
        }
    })();
</script>

<script>
    const firebaseConfig = {
        apiKey: "AIzaSyDNzjX6dmx2fGPhLW-ZIADhNigsfwMY3Ng",
        authDomain: "tom-fun.firebaseapp.com",
        projectId: "tom-fun",
        storageBucket: "tom-fun.appspot.com",
        messagingSenderId: "710857129785",
        appId: "1:710857129785:web:5f2cdebe736577ea0e72e8",
        measurementId: "G-6MHP8FHQ87"
    };

let db, auth;
try {
    firebase.initializeApp(firebaseConfig);
    db = firebase.firestore();
    auth = firebase.auth();
} catch (e) {
    console.error("Firebase initialization failed:", e);
}

const gameWorld = document.getElementById('game-world');
const milan = document.getElementById('milan');
const river = document.getElementById('river');
const stall = document.getElementById('stall');
const stressBar = document.getElementById('stress-bar');
const timerDisplay = document.getElementById('timer');
const gameOverScreen = document.getElementById('game-over');
const outhouse = document.getElementById('outhouse');
const startScreen = document.getElementById('start-screen');

let heldItem = null, keys = {}, items = [], customers = [], seatingAreas = [], staticObjects = [];
let stress = 0, survivalTime = 0, gameRunning = false, controlsImpaired = false, isConsuming = false, baseStressRate = 0.045, ordersCompleted = 0;
let grill, trashCan, queueSlots = [], milanSwearCooldown = false;
let intoxicationLevel = 0, nicotineLevel = 0;
let customerSpawnInterval = 9000;
let maxQueueSize = 3;
const COOK_STATES = { RAW: 0, GOLDEN: 1, WELLDONE: 2, BURNT: 3 };
const COOK_TIMES = { SAUSAGE: 6.5, CHEESE: 5 };
const MILAN_SPEED = 400;

let lastTime = 0;
let animationFrameId;
let riverLanes = { left: false, center: false, right: false };

let currentLanguage = 'cs';
const translations = {
    cs: {
        title: "Milanovy klob√°sy",
        subtitle: "P≈ôipravujte v√Ωteƒçn√° j√≠dla v oƒç√≠ch pr√©miov√©ho kucha≈ôe Milana. Pou≈æ√≠vejte kl√°vesy WASD a E a p≈ôed doruƒçen√≠m j√≠dla jej nezapome≈àte vylo≈æit na pap√≠rov√Ω t√°cek.",
        startButton: "Va≈ôit",
        langButton: "English",
        stressLabel: "Stres", timerLabel: "P≈ôe≈æ√≠v√°≈°",
        gameOverTitle: "KONEC HRY", gameOverReasonCollapse: "Tot√°ln√≠ nervov√© zhroucen√≠!", gameOverReasonAlcohol: "Otrava alkoholem.", gameOverScore: "P≈ôe≈æil jsi", gameOverSeconds: "sekund.", ordersCompleted: "Dokonƒçen√© objedn√°vky", playAgain: "Znovu hr√°t",
        sauceWarning: "Pozor, om√°ƒçka ≈°plouch√°!<br>Udr≈æujte pros√≠m odstup.",
        milanSwears: ["Do p*ƒçi!", "Hajzlov√©!", "U≈æ nem≈Ø≈æu!", "K*nda!", "Zm*di!", "P*ƒça!", "Do pr*ele!", "K*rva!", "To je den na h*vno!", "Sakra pr√°ce!", "Zbl√°zn√≠m se z toho!"], 
        milanRelief: ["K*rva!", "Do p*dele!", "Koneƒçnƒõ chvilka klidu.", "Tohle jsem pot≈ôeboval.", "Ah, sladk√° √∫leva."], 
        milanDrop: "Dopr*ele!",
        withKetchup: "S keƒçupem.", withMustard: "S ho≈ôƒçic√≠.", withBoth: "S oboj√≠m.", withCranberries: "S brusinkama.", andBread: "A {count} chleba.",
        nice_man: ["Dobr√Ω den, prosil bych ", "M≈Ø≈æu poprosit o ", "Dobr√Ω den, dal bych si ", "Zdrav√≠m, mƒõl bych chu≈• na ", "Dobr√Ω den, vypad√° to skvƒõle. D√°m si ", "Pros√≠m v√°s, p≈ôipravte mi "], 
        nice_woman: ["Dobr√Ω den, prosila bych ", "M≈Ø≈æu poprosit o ", "Dobr√Ω den, dala bych si ", "Pƒõkn√Ω den, chtƒõla bych ochutnat ", "Vypad√° to √∫≈æasnƒõ! Pro—Å–∏–ª–∞ bych ", "M≈Ø≈æete mi pros√≠m udƒõlat "], 
        neutral_man: ["D√°m si ", "Chtƒõl bych ", "P≈ôipravte mi ", "Chci ", "D√°m si ", "Objedn√°v√°m "], 
        neutral_woman: ["D√°m si ", "Chtƒõla bych ", "P≈ôipravte mi ", "Chci ", "D√°m si ", "Objedn√°v√°m "], 
        rude: ["Hej, dƒõlej, chci ", "No tak, bude to? Chci ", "ƒåek√°m na ", "Hni sebou, m√°m hlad na ", "Douf√°m, ≈æe to nebude trvat vƒõƒçnost. Chci ", "Hej ty! Chci "],
        customerCurses: ["Co to je za sra*ku?!", "Tohle si strƒç do pr*ele!", "Tohle se ned√° ≈ær√°t!", "Fuj, to je hnus!", "ƒåekal jsem kvalitu, ne tenhle bl*f!", "Zm*de!", "Si dƒõl√°≈° k*zy?!", "ƒå*r√°ku!", "Dƒõ*ko!", "P*ƒço!", "Jdi do h*jzlu!", "Ty dƒõdku zas*anej!", "Tohle by ne≈æral ani pes!", "Za tohle platit nebudu!"], 
        customerImpatient: "Na tohle se ti m≈Ø≈æu vys*at!", 
        customerRudeComments: ["Nic moc teda.", "ƒåekal jsem v√≠c.", "U≈æ se nevr√°t√≠m.", "Bylo to... jedl√Ω.", "Hmm.", "No, aspo≈à jsem se najedl.", "P≈ô√≠≈°tƒõ zkus√≠m nƒõco jin√©ho.", "Za ty pen√≠ze nic extra."], 
        outhouseCurses: ["Ta kadibudka je peklo!", "Hr≈Øza, ten smrad!", "Stra≈°nƒõ to p√°l√≠!", "U≈æ sem nikdy nepudu!", "Pot≈ôebuju doktora, hned!", "Proboha, co to bylo?!", "Moje √∫troby ho≈ô√≠!", "To je biologick√° zbra≈à!", "Okam≈æitƒõ dezinfekci!", "Nikdy v√≠c!"],
        sausage_adj: { singular: { [COOK_STATES.GOLDEN]: "zlatavou", [COOK_STATES.WELLDONE]: "propeƒçenou" }, plural: { [COOK_STATES.GOLDEN]: "zlatav√©", [COOK_STATES.WELLDONE]: "propeƒçen√©" }, genitive: { [COOK_STATES.GOLDEN]: "zlatav√Ωch", [COOK_STATES.WELLDONE]: "propeƒçen√Ωch" } },
        cheese_adj: { singular: { [COOK_STATES.GOLDEN]: "zlatav√Ω", [COOK_STATES.WELLDONE]: "propeƒçen√Ω" }, plural: { [COOK_STATES.GOLDEN]: "zlatav√©", [COOK_STATES.WELLDONE]: "propeƒçen√©" }, genitive: { [COOK_STATES.GOLDEN]: "zlatav√Ωch", [COOK_STATES.WELLDONE]: "propeƒçen√Ωch" } },
        sausage_plural: { 1: "klob√°su", 2: "klob√°sy", 5: "klob√°s" },
        cheese_plural: { 1: "hermel√≠n", 2: "hermel√≠ny", 5: "hermel√≠n≈Ø" },
        numbers: { 1: "jednu", 2: "dvƒõ", 3: "t≈ôi", 4: "ƒçty≈ôi", 5: "pƒõt" },
        numbers_male: { 1: "jeden", 2: "dva", 3: "t≈ôi", 4: "ƒçty≈ôi", 5: "pƒõt" }
    },
    en: {
        title: "Milan's Sausages",
        subtitle: "Prepare delicious meals under the watchful eye of premium chef Milan. Use WASD and E keys, and don't forget to place the food on a paper plate before delivery.",
        startButton: "Cook",
        langButton: "ƒåesky",
        stressLabel: "Stress", timerLabel: "Surviving",
        gameOverTitle: "GAME OVER", gameOverReasonCollapse: "Total mental breakdown!", gameOverReasonAlcohol: "Alcohol poisoning.", gameOverScore: "You survived", gameOverSeconds: "seconds.", ordersCompleted: "Orders Completed", playAgain: "Play Again",
        sauceWarning: "Caution, sauce splashes!<br>Please keep your distance.",
        milanSwears: ["F**k!", "A**holes!", "I can't take it!", "Son of a b**ch!", "D*mn it!", "This day sucks!", "For f**k's sake!", "I'm losing my mind!"], 
        milanRelief: ["Ah, f**k it!", "Here we go...", "Finally, a moment of peace.", "I needed this.", "Ah, sweet relief."], 
        milanDrop: "Oh, sh*t!",
        withKetchup: "With ketchup.", withMustard: "With mustard.", withBoth: "With both.", withCranberries: "With cranberries.", andBread: "And {count} bread.",
        nice_man: ["Hello, I would like ", "Could I please have ", "Hi, I'll take ", "Greetings, I'm in the mood for ", "Hello, that looks delicious. I'll have ", "Could you prepare me "], 
        nice_woman: ["Hello, I would like ", "Could I please have ", "Hi, I'll take ", "Good day, I'd love to try ", "That looks amazing! I would like ", "Could you please make me "], 
        neutral_man: ["I'll have ", "I want ", "Get me ", "One of those.", "I'll take the usual.", "Just give me "], 
        neutral_woman: ["I'll have ", "I want ", "Get me ", "One of those.", "I'll take the usual.", "Just give me "], 
        rude: ["Hey, hurry up, I want ", "Come on, will ya? I want ", "I'm waiting for ", "Move it, I'm starving for ", "I hope this doesn't take all day. I want ", "Hey you! I want "],
        customerCurses: ["What is this crap?!", "You can shove this up your a**!", "This is inedible!", "Ugh, disgusting!", "I expected quality, not this garbage!", "You moron!", "You old fart!", "Even my dog wouldn't eat this!", "I'm not paying for this filth!"], 
        customerImpatient: "I'm not waiting for this sh*t!", 
        customerRudeComments: ["Not great.", "I expected more.", "I'm not coming back.", "It was... edible.", "Hmm.", "Well, at least it's food.", "I'll try something else next time.", "Not worth the money."], 
        outhouseCurses: ["That outhouse is hell!", "Horrible, the stench!", "God, it burns!", "I'm never coming here again!", "I need a doctor, now!", "Oh god, what was that?!", "My insides are on fire!", "That's a biological weapon!", "I need a shower, immediately!", "Never again!"],
        sausage_adj: { [COOK_STATES.GOLDEN]: "golden-brown", [COOK_STATES.WELLDONE]: "well-done" },
        cheese_adj: { [COOK_STATES.GOLDEN]: "golden-brown", [COOK_STATES.WELLDONE]: "well-done" },
        sausage_plural: { 1: "sausage", 2: "sausages" },
        cheese_plural: { 1: "camembert", 2: "camemberts" },
    }
};

function updateAllText() {
    const t = translations[currentLanguage];
    document.documentElement.lang = currentLanguage;
    document.getElementById('start-screen').querySelector('h1').textContent = t.title;
    document.getElementById('start-screen-subtitle').innerHTML = t.subtitle;
    document.getElementById('start-btn').textContent = t.startButton;
    document.getElementById('lang-switch-btn').textContent = t.langButton;
    document.getElementById('stress-label').textContent = t.stressLabel;
    document.getElementById('game-over-title').textContent = t.gameOverTitle;
    document.getElementById('play-again-btn').textContent = t.playAgain;
    
    const czechWarning = document.getElementById('sauce-warning-cs');
    const englishWarning = document.getElementById('sauce-warning-en');

    czechWarning.innerHTML = translations.cs.sauceWarning;
    englishWarning.innerHTML = translations.en.sauceWarning;

    if (currentLanguage === 'cs') {
        czechWarning.style.display = 'block';
        englishWarning.style.display = 'none';
    } else {
        czechWarning.style.display = 'none';
        englishWarning.style.display = 'block';
    }
}

document.addEventListener('keydown', e => { if (gameRunning) keys[e.key.toLowerCase()] = true; });
document.addEventListener('keyup', e => {
    if (!gameRunning) return;
    const key = e.key.toLowerCase();
    if (key === 'e') handleInteraction();
    delete keys[key];
});

function getDistance(e1,e2){const r1=e1.getBoundingClientRect(),r2=e2.getBoundingClientRect();return Math.sqrt(Math.pow(r1.left+r1.width/2-(r2.left+r2.width/2),2)+Math.pow(r1.top+r1.height/2-(r2.top+r2.height/2),2))}

function handleInteraction() {
    if (!gameRunning || isConsuming) return;
    if (heldItem) {
        if (heldItem.type === 'plate' && heldItem.contents.length > 0) {
            let interactedWithSauce = false;
            staticObjects.forEach(obj => {
                if (obj.isSauce && getDistance(milan, obj.element) < 120) {
                    const plate = heldItem;
                    plate.contents.forEach(food => {
                        if (obj.sauceType === 'ketchup' && food.type === 'sausage' && !plate.hasKetchup) { plate.hasKetchup = true; const s = document.createElement('div'); s.className = 'ketchup-splash'; food.element.appendChild(s); interactedWithSauce = true; }
                        else if (obj.sauceType === 'mustard' && food.type === 'sausage' && !plate.hasMustard) { plate.hasMustard = true; const s = document.createElement('div'); s.className = 'mustard-splash'; food.element.appendChild(s); interactedWithSauce = true; }
                        else if (obj.sauceType === 'cranberries' && food.type === 'cheese' && !plate.hasCranberries) { plate.hasCranberries = true; const s = document.createElement('div'); s.className = 'cranberries-splash'; food.element.appendChild(s); interactedWithSauce = true; }
                    });
                }
            });
            if (interactedWithSauce) return;
        }
        if (heldItem.type === 'plate' && heldItem.contents.length > 0) {
            let closestCustomer = null, minDistance = 150;
            customers.filter(c => c.state === 'waiting_in_queue').forEach(cust => {
                const dist = getDistance(milan, cust.figureElement);
                if (dist < minDistance) { minDistance = dist; closestCustomer = cust; }
            });
            if (closestCustomer) {
                if (checkOrder(heldItem, closestCustomer.order)) {
                    ordersCompleted++;
                    closestCustomer.state = 'walking_to_table';
                    closestCustomer.speechBubble.classList.remove('visible');
                    closestCustomer.waitTimerContainer.style.visibility = 'hidden';
                    moveCustomerToTable(closestCustomer, heldItem);
                } else {
                    updateStress(closestCustomer.personality === 'rude' ? 40 : 30);
                    customerCusses(closestCustomer);
                }
                while (heldItem.element.firstChild) { heldItem.element.removeChild(heldItem.element.firstChild); }
                heldItem.element.remove();
                items.splice(items.indexOf(heldItem), 1);
                heldItem = null;
                return;
            }
        }
        let placedOnPlate = false;
        if (['sausage', 'cheese', 'bread'].includes(heldItem.type)) {
            items.filter(i => i.type === 'plate').forEach(plate => {
                if (!placedOnPlate && isOverlapping(heldItem.element, plate.element)) {
                    if (heldItem.type === 'bread') {
                        if (plate.breadCount < 4) { plate.breadCount = (plate.breadCount || 0) + 1; heldItem.element.style.top = (5 + plate.breadCount * 12) + 'px'; } else return;
                    } else if (plate.contents.length < 2) {
                        plate.contents.push(heldItem);
                    } else return;
                    if(heldItem.type !== 'bread') {
                        heldItem.element.style.left = (plate.contents.length === 1 ? '5px' : '30px');
                        heldItem.element.style.top = (heldItem.type === 'sausage' ? '25px' : '20px');
                    } else {
                        heldItem.element.style.left = '5px';
                    }
                    heldItem.onPlate = plate; placedOnPlate = true; heldItem.isHeld = false; heldItem.element.style.zIndex = 6;
                    plate.element.appendChild(heldItem.element); 
                    items.splice(items.indexOf(heldItem), 1);
                    heldItem = null;
                }
            });
        }
        if (heldItem) { heldItem.isHeld = false; heldItem.element.style.zIndex = 5; heldItem = null; }
    } else {
        let closestItem = null, minDistance = 100;
        items.sort((a, b) => (a.type === 'plate' && a.contents.length > 0) ? -1 : 1);
        items.forEach(item => { 
            const distance = getDistance(milan, item.element); 
            if (distance < minDistance) { minDistance = distance; closestItem = item; } 
        });
        if (closestItem) {
            heldItem = closestItem; 
            heldItem.isHeld = true; 
            heldItem.element.style.zIndex = 11;
            return;
        }
        let closestStatic = null, minStaticDist = 120;
        staticObjects.forEach(obj => { const dist = getDistance(milan, obj.element); if (dist < minStaticDist) { minStaticDist = dist; closestStatic = obj; } });
        if (closestStatic) {
            if (closestStatic.isSupply) { const newItem = createItem(closestStatic.supplyType, milan.offsetLeft, milan.offsetTop); heldItem = newItem; heldItem.isHeld = true; heldItem.element.style.zIndex = 11; }
            else if (closestStatic.isRelief) { useStressRelief(closestStatic.reliefType); }
        }
    }
}
function isOverlapping(e1,e2){const r1=e1.getBoundingClientRect(),r2=e2.getBoundingClientRect();return!(r1.right<r2.left||r1.left>r2.right||r1.bottom<r2.top||r1.top>r2.bottom)}
function updateStress(c){stress+=c;if(stress<0)stress=0;if(stress>100)stress=100;stressBar.style.width=stress+'%';if(stress>=100)endGame(translations[currentLanguage].gameOverReasonCollapse)}
function createMilanBubble(t){const b=document.createElement('div');b.className='milan-bubble';b.textContent=t;b.style.left=milan.offsetLeft+milan.offsetWidth+'px';b.style.top=milan.offsetTop-20+'px';gameWorld.appendChild(b);setTimeout(()=>b.remove(),2000)}

function startSmoking(isInitial = false) {
    if (!isInitial) {
        if (isConsuming) return;
        updateStress(-15);
        nicotineLevel += 40;
        if (nicotineLevel > 100) nicotineLevel = 100;
    }
    isConsuming = true;
    const cig = document.createElement('div');
    cig.className = 'cigarette-visual';
    milan.appendChild(cig);
    cig.style.left = (milan.offsetWidth - 20) + 'px';
    cig.style.top = '25px';
    cig.style.transform = 'rotate(-20deg)';
    const smokeInterval = setInterval(() => {
        if (!gameRunning || !cig.parentElement) return;
        for(let i=0; i<3; i++) {
            const smoke = document.createElement('div');
            smoke.className = 'smoke';
            const cigRect = cig.getBoundingClientRect();
            smoke.style.left = cigRect.right - 10 + 'px';
            smoke.style.top = cigRect.top + 'px';
            smoke.style.animationDelay = `${Math.random() * 0.5}s`;
            smoke.style.animationDuration = `${Math.random() * 1 + 2}s`
            gameWorld.appendChild(smoke);
            setTimeout(() => smoke.remove(), 3000);
        }
    }, 500);
    setTimeout(() => {
        clearInterval(smokeInterval);
        if (cig.parentElement) cig.remove();
        isConsuming = false;
    }, 5000);
}

function useStressRelief(type) {
    if (isConsuming || !gameRunning) return;
    const t = translations[currentLanguage];
    createMilanBubble(t.milanRelief[Math.floor(Math.random()*t.milanRelief.length)]);
    if (type === 'vodka') {
        isConsuming = true;
        updateStress(-30); 
        intoxicationLevel += 40;
        if (intoxicationLevel > 100) intoxicationLevel = 100;
        for (let i = 0; i < 15; i++) {
            const p = document.createElement('div');
            p.className = 'drunk-particle';
            p.style.left = Math.random() * window.innerWidth + 'px';
            p.style.top = Math.random() * window.innerHeight + 'px';
            p.style.backgroundColor = `hsla(${Math.random() * 360}, 100%, 70%, 0.6)`;
            p.style.animationDelay = `${Math.random() * 0.5}s`;
            gameWorld.appendChild(p);
            setTimeout(() => p.remove(), 2000);
        }
        setTimeout(() => { isConsuming = false; }, 1500); 
        if (intoxicationLevel > 95) endGame(translations[currentLanguage].gameOverReasonAlcohol);
    } else if (type === 'cigarettes') {
        startSmoking();
    }
}

function customerLeaves(cust, isAngry) {
    if(cust.state === 'leaving') return;
    cust.state = 'leaving';
    if (cust.queueSlot) { cust.queueSlot.occupied = false; cust.queueSlot = null; }
    if (cust.figureElement) {
        cust.speechBubble.classList.remove('visible');
        cust.waitTimerContainer.style.visibility = 'hidden';
        if (!isAngry && cust.table && Math.random() < 0.35) {
            const rudeComments = translations[currentLanguage].customerRudeComments;
            cust.speechBubble.innerHTML = rudeComments[Math.floor(Math.random() * rudeComments.length)];
            cust.speechBubble.style.color = 'gray';
            cust.speechBubble.classList.add('visible');
            setTimeout(() => { if (cust.speechBubble) cust.speechBubble.classList.remove('visible'); }, 2500);
        }
        const fig = cust.figureElement;
        fig.style.top = gameWorld.clientHeight + 50 + 'px';
        fig.style.left = (Math.random() * (gameWorld.clientWidth / 2 - 100) + river.clientWidth + 50) + 'px';
        setTimeout(() => { 
            if(fig.parentElement) fig.remove(); 
            const index = customers.indexOf(cust);
            if (index > -1) customers.splice(index, 1);
        }, 3000);
    } else {
        const index = customers.indexOf(cust);
        if (index > -1) customers.splice(index, 1);
    }
}

function customerCusses(cust) {
    const curses = translations[currentLanguage].customerCurses;
    cust.speechBubble.innerHTML = curses[Math.floor(Math.random() * curses.length)];
    cust.speechBubble.style.color = 'red'; cust.speechBubble.classList.add('visible');
    setTimeout(() => { customerLeaves(cust, true); }, 2500);
}

function gameLoop(timestamp){
    if (!gameRunning) return;
    animationFrameId = requestAnimationFrame(gameLoop);
    
    if (!lastTime) lastTime = timestamp;
    const deltaTime = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    
    if (intoxicationLevel > 0) intoxicationLevel -= (1.5 * deltaTime); else intoxicationLevel = 0;
    if (nicotineLevel > 0) nicotineLevel -= (3 * deltaTime); else nicotineLevel = 0;

    const stressShake = stress > 70 ? (stress - 70) / 15 : 0;
    const drunkShake = intoxicationLevel / 8;
    const nicotineShake = nicotineLevel / 25;
    const totalShake = stressShake + drunkShake + nicotineShake;
    if (totalShake > 0) {
        const sX = (Math.random() - 0.5) * totalShake;
        const sY = (Math.random() - 0.5) * totalShake;
        gameWorld.style.transform = `translate(${sX}px, ${sY}px)`;
    } else {
        gameWorld.style.transform = 'none';
    }
    const stressBlur = stress > 85 ? (stress - 85) / 10 : 0;
    const drunkBlur = intoxicationLevel > 20 ? (intoxicationLevel - 20) / 10 : 0;
    const nicotineBlur = nicotineLevel > 40 ? (nicotineLevel - 40) / 50 : 0;
    const totalBlur = stressBlur + drunkBlur + nicotineBlur;
    const drunkHue = intoxicationLevel > 30 ? (intoxicationLevel - 30) / 3 : 0;
    const nicotineSaturation = 100 + (nicotineLevel > 20 ? (nicotineLevel - 20) / 2 : 0);
    gameWorld.style.filter = `blur(${totalBlur}px) hue-rotate(${drunkHue}deg) saturate(${nicotineSaturation}%)`;
    controlsImpaired = intoxicationLevel > 40;
    if (controlsImpaired && heldItem && Math.random() < (intoxicationLevel / 500 * deltaTime)) {
        createMilanBubble(translations[currentLanguage].milanDrop);
        heldItem.isHeld = false;
        heldItem.element.style.zIndex = 5;
        heldItem = null;
    }
    customers.forEach(cust => {
        if (cust.state === 'waiting_in_queue') {
            cust.waitTime += deltaTime; 
            const waitPercentage = (cust.waitTime / cust.maxWaitTime) * 100;
            cust.waitTimerBar.style.width = (100 - waitPercentage) + '%';
            if (waitPercentage < 40) cust.waitTimerBar.style.backgroundColor = '#32CD32';
            else if (waitPercentage < 75) cust.waitTimerBar.style.backgroundColor = '#FFD700';
            else cust.waitTimerBar.style.backgroundColor = '#DC143C';
            if (cust.waitTime >= cust.maxWaitTime) {
                updateStress(25);
                cust.speechBubble.innerHTML = translations[currentLanguage].customerImpatient;
                cust.speechBubble.style.color = 'orange';
                cust.speechBubble.classList.add('visible');
                customerLeaves(cust, true);
            }
        }
    });
    updateStress((baseStressRate+customers.filter(c=>c.state==='waiting_in_queue').length*0.1)*deltaTime);
    if(stress > 50 && !milanSwearCooldown) {
        const swears = translations[currentLanguage].milanSwears;
        createMilanBubble(swears[Math.floor(Math.random()*swears.length)]);
        milanSwearCooldown = true;
        setTimeout(() => { milanSwearCooldown = false }, 5000);
    }
    const slowDownFactor = 1 + (intoxicationLevel / 200) + (nicotineLevel / 400);
    const currentSpeed = MILAN_SPEED / slowDownFactor;
    let mX=0,mY=0;if(keys.w)mY-=1;if(keys.s)mY+=1;if(keys.a)mX-=1;if(keys.d)mX+=1;if(controlsImpaired)[mX,mY]=[-mY,mX];let cX=milan.offsetLeft+mX*currentSpeed*deltaTime,cY=milan.offsetTop+mY*currentSpeed*deltaTime;if(cX<0)cX=0;if(cX>gameWorld.clientWidth-milan.clientWidth)cX=gameWorld.clientWidth-milan.clientWidth;if(cY<0)cY=0;if(cY>gameWorld.clientHeight-milan.clientHeight)cY=gameWorld.clientHeight-milan.clientHeight;milan.style.left=cX+'px';milan.style.top=cY+'px';
    if(heldItem){ heldItem.element.style.left=milan.offsetLeft+milan.clientWidth/2-heldItem.element.clientWidth/2+'px'; heldItem.element.style.top=milan.offsetTop-heldItem.element.clientHeight+'px'; }
    items.forEach((item,index)=>{
        if (item.onPlate) return;
        if(!item.isHeld && ['sausage','cheese'].includes(item.type)){
            if(isOverlapping(item.element,grill)&&item.cookState<COOK_STATES.BURNT){
                item.cookTime += deltaTime;
                const tPS=item.type==='sausage'?COOK_TIMES.SAUSAGE:COOK_TIMES.CHEESE;
                const nS=Math.floor(item.cookTime/tPS);
                if(nS>item.cookState){ item.cookState=nS>3?3:nS; updateItemVisuals(item) }
                if(Math.random() > 0.98) createSmoke(item.element)
            }
        }
        if(!item.isHeld&&isOverlapping(item.element,trashCan)){
            while (item.element.firstChild) { item.element.removeChild(item.element.firstChild); }
            item.element.remove(); items.splice(index,1);
        }
    });
}
function updateItemVisuals(item){const t=item.type==='sausage'?'sausage':'cheese';item.element.className=`item ${t}`;switch(item.cookState){case COOK_STATES.RAW:item.element.classList.add(`raw-${t}`);break;case COOK_STATES.GOLDEN:item.element.classList.add(`golden-${t}`);break;case COOK_STATES.WELLDONE:item.element.classList.add(`welldone-${t}`);break;case COOK_STATES.BURNT:item.element.classList.add(`burnt-${t}`);break;}}
function checkOrder(plate, order) {
    if ((plate.breadCount || 0) !== order.bread) return false;
    if (order.ketchup !== plate.hasKetchup || order.mustard !== plate.hasMustard || order.cranberries !== plate.hasCranberries) return false;
    const plateContents = plate.contents.map(i => ({ type: i.type, cookState: i.cookState })).sort((a, b) => a.type.localeCompare(b.type));
    const orderItems = order.items.sort((a, b) => a.type.localeCompare(b.type));
    if (plateContents.length !== orderItems.length) return false;
    for (let i = 0; i < orderItems.length; i++) {
        if (plateContents[i].type !== orderItems[i].type || plateContents[i].cookState !== orderItems[i].cookState) return false;
    }
    return true;
}

function createPoopParticle(x, y) { const p = document.createElement('div'); p.className = 'poop-particle'; p.style.left = x + (Math.random() * 20 - 10) + 'px'; p.style.top = y + 60 + (Math.random() * 10 - 5) + 'px'; gameWorld.appendChild(p); setTimeout(() => p.remove(), 2500); }
function createDirtParticle(x, y) { const p = document.createElement('div'); p.className = 'dirt-particle'; p.style.left = x + 10 + (Math.random() * 20 - 10) + 'px'; p.style.top = y + 65 + (Math.random() * 10 - 5) + 'px'; p.style.animationDelay = `${Math.random() * 0.2}s`; gameWorld.appendChild(p); setTimeout(() => p.remove(), 800); }
function createSmoke(el){ const smoke = document.createElement('div'); smoke.className = 'smoke'; const rect = el.getBoundingClientRect(); smoke.style.left = rect.left + Math.random() * rect.width + 'px'; smoke.style.top = rect.top + 'px'; smoke.style.animationDelay = `${Math.random() * 0.5}s`; smoke.style.animationDuration = `${Math.random() * 1 + 2}s`; gameWorld.appendChild(smoke); setTimeout(() => smoke.remove(), 3000); }

function moveCustomerToTable(cust, plate) {
    const eT = seatingAreas.find(sa => !sa.occupied);
    if (eT) {
        eT.occupied = true; cust.table = eT;
        const fig = cust.figureElement, tR = eT.element.querySelector('.table').getBoundingClientRect();
        const bench = eT.element.querySelector(Math.random() > 0.5 ? '.bench.top' : '.bench.bottom');
        const bR = bench.getBoundingClientRect();
        fig.style.left = bR.left + 50 + 'px'; fig.style.top = bR.top - 50 + 'px';
        const tablePlate = plate.element.cloneNode(true);
        tablePlate.style.position = 'absolute'; tablePlate.style.left = tR.left + 30 + 'px'; tablePlate.style.top = tR.top - 10 + 'px'; tablePlate.style.zIndex = 5;
        gameWorld.appendChild(tablePlate);

        setTimeout(() => {
            tablePlate.remove();
            if (Math.random() < 0.4) { sendCustomerToOuthouse(cust); } 
            else { if (cust.table) cust.table.occupied = false; customerLeaves(cust, false); }
        }, 15000);
    } else { customerLeaves(cust, true); }
}

function sendCustomerToOuthouse(cust) {
    cust.state = 'walking_to_outhouse'; const fig = cust.figureElement;
    const outhouseRect = outhouse.getBoundingClientRect();
    fig.style.left = outhouseRect.left + 'px'; fig.style.top = outhouseRect.top + outhouseRect.height + 'px';
    setTimeout(() => {
        cust.state = 'using_outhouse'; fig.style.display = 'none'; outhouse.classList.add('shake');
        setTimeout(() => {
            outhouse.classList.remove('shake'); fig.style.display = 'block'; customerLeavesOuthouse(cust);
        }, 3000);
    }, 3000);
}

function customerLeavesOuthouse(cust) {
    cust.state = 'leaving_in_distress'; 
    const fig = cust.figureElement;
    const curses = translations[currentLanguage].outhouseCurses;
    cust.speechBubble.innerHTML = curses[Math.floor(Math.random() * curses.length)];
    cust.speechBubble.style.color = 'brown'; cust.speechBubble.classList.add('visible');
    const particleInterval = setInterval(() => {
        if (cust.state !== 'leaving_in_distress' || !fig.parentElement) {
            clearInterval(particleInterval);
            return;
        }
        createPoopParticle(fig.offsetLeft, fig.offsetTop);
        createDirtParticle(fig.offsetLeft, fig.offsetTop);
        createDirtParticle(fig.offsetLeft, fig.offsetTop);
        createDirtParticle(fig.offsetLeft, fig.offsetTop);
    }, 100);
    if (cust.table) cust.table.occupied = false;
    fig.style.transition = 'left 2.5s linear, top 2.5s linear';
    customerLeaves(cust, false);
    setTimeout(() => { 
        clearInterval(particleInterval); 
        fig.style.transition = 'left 3s ease-in-out, top 3s ease-in-out'; 
    }, 2600);
}

function createItem(type,x,y){const el=document.createElement('div');el.classList.add('item',type);if(type==='sausage')el.classList.add('raw-sausage');if(type==='cheese')el.classList.add('raw-cheese');el.style.left=x+'px';el.style.top=y+'px';const itemObj={element:el,type:type,isHeld:!1};if(['sausage','cheese'].includes(type)){itemObj.cookTime=0;itemObj.cookState=COOK_STATES.RAW;itemObj.onPlate=null}if(type==='plate'){itemObj.contents=[];itemObj.hasKetchup=!1;itemObj.hasMustard=!1;itemObj.hasCranberries=!1;itemObj.breadCount=0}items.push(itemObj);gameWorld.appendChild(el);return itemObj}

const hairColorPool = [
    '#3d2d1b', '#3d2d1b', '#111', '#111', '#e0b452', '#e0b452', '#e0b452', 
    '#c7864f', '#c7864f', '#dddddd', 
    '#af3333', '#4169e1' 
];
function getRandomHairColor() {
    return hairColorPool[Math.floor(Math.random() * hairColorPool.length)];
}

function createCustomer() {
    const occupiedSlots = queueSlots.filter(s => s.occupied).length;
    if (occupiedSlots >= maxQueueSize) return;
    const availableSlot = queueSlots.find(s => !s.occupied);
    if (!availableSlot) return;
    
    const g = Math.random() > 0.5 ? 'man' : 'woman';
    const f = document.createElement('div');
    f.className = `customer-figure ${g}`;

    if (Math.random() < 0.15) { f.classList.add('obese'); }

    const hairRoll = Math.random();
    let hairHTML = '';
    if ((g === 'woman' && hairRoll > 0.02) || (g === 'man' && hairRoll > 0.15)) {
        const availableStyles = (g === 'woman') ? ['style1', 'style2', 'style4'] : ['style1', 'style2', 'style4'];
        const hairStyle = availableStyles[Math.floor(Math.random() * availableStyles.length)];
        const hairColor = getRandomHairColor();
        hairHTML = `<div class="hair ${hairStyle}" style="color: ${hairColor}"></div>`;
    }

    let genderSpecificHTML = '';
    const clothingColor = ['#DC143C', '#008000', '#0000CD', '#FF69B4', '#FFA500'][Math.floor(Math.random()*5)];

    if (g === 'woman') {
        if (Math.random() < 0.3) { f.classList.add('curvy'); }
        
        const boobsRoll = Math.random();
        let boobsClass = 'boobs-medium';
        if (boobsRoll < 0.33) boobsClass = 'boobs-small';
        else if (boobsRoll > 0.66) boobsClass = 'boobs-large';
        
        let clothingHTML = '';
        if (Math.random() < 0.2) { 
            clothingHTML = `<div class="one-piece-suit" style="background-color: ${clothingColor}"></div>`;
        } else {
            const bikiniTopStyles = ['style-triangle', 'style-bandeau', 'style-circles-connected', 'style-balls'];
            const bikiniTopClass = bikiniTopStyles[Math.floor(Math.random() * bikiniTopStyles.length)];
            
            const bikiniBottomStyles = ['style-a', 'style-b', 'style-thong'];
            const bikiniBottomClass = bikiniBottomStyles[Math.floor(Math.random() * bikiniBottomStyles.length)];
            
            clothingHTML = `
                <div class="bikini-top ${bikiniTopClass}" style="background-color: ${clothingColor}; border-color: ${clothingColor}"></div>
                <div class="bikini-bottom ${bikiniBottomClass}" style="background-color: ${clothingColor}"></div>
            `;
        }

        genderSpecificHTML = `
            <div class="torso ${boobsClass}"></div>
            <div class="arm left"></div><div class="arm right"></div>
            ${clothingHTML}
            <div class="leg left"></div><div class="leg right"></div>`;

    } else {
        const shortsStyles = ['style-a', 'style-boardshorts', 'style-speedo'];
        const shortsClass = shortsStyles[Math.floor(Math.random() * shortsStyles.length)];
        genderSpecificHTML = `
            <div class="torso"></div>
            <div class="arm left"></div><div class="arm right"></div>
            <div class="shorts ${shortsClass}" style="background-color: ${clothingColor}"></div>
            <div class="leg left"></div><div class="leg right"></div>`;
    }

    f.innerHTML = `
        <div class="head">
            ${hairHTML}
            <div class="face"><div class="eye left"></div><div class="eye right"></div><div class="mouth"></div></div>
        </div>
        ${genderSpecificHTML}
        <div class="wait-timer-container"><div class="wait-timer-bar"></div></div>`;

    Array.from(f.children).forEach(child => { if(child.classList.contains('arm') || child.classList.contains('leg')) { child.style.backgroundColor = '#FFDAB9'; } });
    gameWorld.appendChild(f);
    
    f.style.top = gameWorld.clientHeight + 50 + 'px'; f.style.left = (Math.random() * (gameWorld.clientWidth / 2 - 100) + river.clientWidth + 50) + 'px';
    
    const o = generateOrder(); const b = document.createElement('div'); b.className = 'speech-bubble'; b.innerHTML = formatOrder(o, g);
    f.appendChild(b);
    const timerContainer = f.querySelector('.wait-timer-container');
    const timerBar = f.querySelector('.wait-timer-bar');
    const c = { figureElement: f, speechBubble: b, order: o, state: 'walking_to_queue', waitTime: 0, angry: !1, queueSlot: null, personality: o.personality, waitTimerContainer: timerContainer, waitTimerBar: timerBar, maxWaitTime: 90 + (o.personality === 'nice' ? 40 : (o.personality === 'rude' ? -40 : 0)) };
    customers.push(c);

    setTimeout(() => {
        const availableSlot = queueSlots.find(s => !s.occupied);
        if (availableSlot) {
            availableSlot.occupied = true;
            c.queueSlot = availableSlot;
            f.style.left = availableSlot.x + 'px'; f.style.top = availableSlot.y + 'px';
            setTimeout(() => { c.state = 'waiting_in_queue'; c.speechBubble.classList.add('visible'); c.waitTimerContainer.style.visibility = 'visible'; }, 3000);
        }
    }, 100);
}

function generateOrder() { const order = { items: [], ketchup: false, mustard: false, cranberries: false, bread: 0, personality: 'neutral' }; const p = Math.random(); if (p < 0.25) order.personality = 'rude'; else if (p < 0.6) order.personality = 'nice'; if (survivalTime < 45) { order.items.push({type: Math.random() > 0.5 ? 'sausage' : 'cheese', cookState: COOK_STATES.GOLDEN}); return order; } const mainItemCount = (survivalTime > 90 && Math.random() > 0.5) ? 2 : 1; for (let i = 0; i < mainItemCount; i++) { const item = { type: Math.random() > 0.5 ? 'sausage' : 'cheese', cookState: [COOK_STATES.GOLDEN, COOK_STATES.WELLDONE][Math.floor(Math.random() * 2)] }; if(i > 0 && item.type === 'cheese' && order.items.type === 'cheese') { item.type = 'sausage'; } order.items.push(item); } if (order.items.some(i => i.type === 'sausage')) { const s = Math.random(); if (s < 0.33) order.ketchup = true; else if (s < 0.66) order.mustard = true; else { order.ketchup = true; order.mustard = true; } } if (order.items.some(i => i.type === 'cheese')) { if (Math.random() > 0.5) order.cranberries = true; } order.bread = survivalTime > 45 ? Math.floor(Math.random() * 5) : Math.floor(Math.random() * 3); return order; }

function formatOrder(order, gender) {
    const t = translations[currentLanguage];
    let text = "";
    switch(order.personality) {
        case 'nice': text = (gender === 'woman' ? t.nice_woman : t.nice_man)[Math.floor(Math.random()*t.nice_man.length)]; break;
        case 'rude': text = t.rude[Math.floor(Math.random()*t.rude.length)]; break;
        default: text = (gender === 'woman' ? t.neutral_woman : t.neutral_man)[Math.floor(Math.random()*t.neutral_man.length)];
    }
    const itemCounts = order.items.reduce((acc, item) => {
        const key = `${item.type}-${item.cookState}`;
        acc[key] = (acc[key] || 0) + 1;
        return acc;
    }, {});
    const itemStrings = Object.entries(itemCounts).map(([key, count]) => {
        const [type, cookState] = key.split('-');
        if (currentLanguage === 'cs') {
            const adjKey = count === 1 ? 'singular' : (count >= 2 && count <= 4 ? 'plural' : 'genitive');
            const adj = type === 'sausage' ? t.sausage_adj[adjKey][cookState] : t.cheese_adj[adjKey][cookState];
            const nounKey = count === 1 ? 1 : (count >= 2 && count <= 4 ? 2 : 5);
            const noun = type === 'sausage' ? t.sausage_plural[nounKey] : t.cheese_plural[nounKey];
            const num = type === 'sausage' ? t.numbers[count] : t.numbers_male[count];
            if (count === 1) return `${adj} ${noun}`;
            return `${num} ${adj} ${noun}`;
        } else {
            const adj = type === 'sausage' ? t.sausage_adj[cookState] : t.cheese_adj[cookState];
            const nounKey = count === 1 ? 1 : 2;
            const noun = type === 'sausage' ? t.sausage_plural[nounKey] : t.cheese_plural[nounKey];
            if (count === 1) return `a ${adj} ${noun}`;
            return `${count} ${adj} ${noun}`;
        }
    });
    text += itemStrings.join(currentLanguage === 'cs' ? ' a ' : ' and ') + ". ";
    if (order.ketchup && order.mustard) text += t.withBoth + ' '; else if (order.ketchup) text += t.withKetchup + ' '; else if (order.mustard) text += t.withMustard + ' ';
    if (order.cranberries) text += t.withCranberries + ' ';
    if (order.bread > 0) text += t.andBread.replace('{count}', order.bread);
    return text;
}

function createStaticObject(config){ const o=document.createElement('div'); o.className='static-object'; o.style.left=config.x+'px'; o.style.top=config.y+'px'; o.style.width=(config.w||0)+'px'; o.style.height=(config.h||0)+'px'; if(config.visuals){config.visuals.forEach(vis=>{const e=document.createElement('div'); e.className=vis.class; e.style.left=(vis.x||0)+'px'; e.style.top=(vis.y||0)+'px'; if(vis.rot)e.style.transform=`rotate(${vis.rot}deg)`; if(vis.html)e.innerHTML=vis.html; o.appendChild(e)})} stall.appendChild(o); staticObjects.push({element:o,...config}); }
function createSupplyTable(config) { const container = document.createElement('div'); container.className = 'supply-table-container'; container.style.left = config.x + 'px'; container.style.top = config.y + 'px'; container.style.width = config.w + 'px'; container.style.height = config.h + 20 + 'px'; const top = document.createElement('div'); top.className = 'supply-table-top'; top.style.width = config.w + 'px'; top.style.height = config.h + 'px'; container.appendChild(top); const legPositions = [{top: config.h-3, left: 3}, {top: config.h-3, right: 3}, {top: 0, left: 3, zIndex: 0}, {top: 0, right: 3, zIndex: 0}]; legPositions.forEach(pos => { const leg = document.createElement('div'); leg.className = 'supply-table-leg'; leg.style.top = pos.top + 'px'; if (pos.left !== undefined) leg.style.left = pos.left + 'px'; if (pos.right !== undefined) leg.style.right = pos.right + 'px'; if (pos.zIndex !== undefined) leg.style.zIndex = 0; container.appendChild(leg); }); stall.appendChild(container); }
function createSilverTable(config) { const container = document.createElement('div'); container.className = 'silver-table-container'; container.style.left = config.x + 'px'; container.style.top = config.y + 'px'; container.style.width = config.w + 'px'; container.style.height = config.h + 20 + 'px'; const top = document.createElement('div'); top.className = 'silver-table-top'; top.style.width = config.w + 'px'; top.style.height = config.h + 'px'; container.appendChild(top); const legPositions = [{top: config.h-3, left: 3}, {top: 0, left: 3, zIndex: 0}, {top: config.h-3, right: 3}, {top: 0, right: 3, zIndex: 0}]; legPositions.forEach(pos => { const leg = document.createElement('div'); leg.className = 'silver-table-leg'; leg.style.top = pos.top + 'px'; if (pos.left !== undefined) leg.style.left = pos.left + 'px'; if (pos.right !== undefined) leg.style.right = pos.right + 'px'; if (pos.zIndex !== undefined) leg.style.zIndex = 0; container.appendChild(leg); }); stall.appendChild(container); }

function createDecorativeVessel() {
    if (!gameRunning) return;

    const spawnRoll = Math.random();
    let choice, lane;

    if (spawnRoll < 0.70) { 
        choice = { type: 'kayak', speedMin: 10, speedMax: 15, width: 50 };
        lane = Math.random() < 0.5 ? 'left' : 'right';
        if (riverLanes[lane]) { lane = lane === 'left' ? 'right' : 'left'; }
    } else if (spawnRoll < 0.90) {
        choice = { type: 'raft', speedMin: 18, speedMax: 25, width: 70 };
        lane = Math.random() < 0.5 ? 'left' : 'right';
         if (riverLanes[lane]) { lane = lane === 'left' ? 'right' : 'left'; }
    } else {
        choice = { type: 'big-ship', speedMin: 25, speedMax: 35, width: 100 };
        lane = 'center';
    }

    if (riverLanes[lane]) return; 

    riverLanes[lane] = true;

    const v = document.createElement('div');
    v.className = `deco-vessel ${choice.type}`;
    
    let contentHTML = '';
    if(choice.type === 'kayak') {
        v.classList.add(['red', 'green', 'blue'][Math.floor(Math.random() * 3)]);
        const numPeople = Math.floor(Math.random() * 3) + 2;
        const baseHeight = 100; const extraHeightPerPerson = 40;
        v.style.height = baseHeight + (numPeople - 1) * extraHeightPerPerson + 'px';
        let peopleHTML = '';
        for (let i = 0; i < numPeople; i++) {
            peopleHTML += `<div class="kayak-person" style="top: ${30 + i * 35}px; left: 15px;"></div>`;
        }
        contentHTML = `<div class="kayak-body">${peopleHTML}</div>`;
    } else if (choice.type === 'raft') {
        contentHTML = `<div class="raft-person"></div>`;
    }
    
    if (lane === 'left') v.style.left = '10px';
    else if (lane === 'center') v.style.left = (river.clientWidth / 2) - (choice.width / 2) + 'px';
    else if (lane === 'right') v.style.left = (river.clientWidth - choice.width - 10) + 'px';

    v.innerHTML = contentHTML;
    v.style.top = gameWorld.clientHeight + 50 + 'px';
    
    const duration = Math.random() * (choice.speedMax - choice.speedMin) + choice.speedMin;
    v.style.transitionDuration = `${duration}s`;
    
    river.appendChild(v);
    setTimeout(() => { v.style.top = -250 + 'px'; }, 100);
    setTimeout(() => { 
        if(v.parentElement) v.remove();
        riverLanes[lane] = false;
    }, (duration * 1000) + 1000);
}

function scheduleNextCustomer() { const nextSpawn = () => { if (gameRunning) { createCustomer(); setTimeout(nextSpawn, customerSpawnInterval); } }; nextSpawn(); }

function startGame(){
    startScreen.style.display = 'none';
    gameRunning = true;
    updateAllText();

    grill = document.getElementById('grill'); trashCan = document.getElementById('trash-can');
    grill.style.left='20px'; grill.style.top='20px';
    trashCan.style.left=stall.offsetWidth-70+'px'; trashCan.style.top=`${stall.offsetHeight-100}px`;
    const sauceWarningSign = document.getElementById('sauce-warning-sign');
    sauceWarningSign.style.left = (stall.offsetWidth - 170) + 'px';
    sauceWarningSign.style.top = '40px';
    const stallRect = stall.getBoundingClientRect();
    queueSlots = [ { x: stallRect.left + 150, y: stallRect.bottom + 20, occupied: false }, { x: stallRect.left + 250, y: stallRect.bottom + 20, occupied: false }, { x: stallRect.left + 350, y: stallRect.bottom + 20, occupied: false }, ];
    
    const treeData=[{x:350,y:20,s:1.1,type:'deciduous'},{x:950,y:30,s:1,type:'pine'},{x:480,y:850,s:0.9,type:'deciduous'},{x:330,y:500,s:1.2,type:'pine'},{x:600,y:20,s:1,type:'deciduous'},{x:1250,y:90,s:1.3,type:'deciduous'},{x:1150,y:800,s:1,type:'pine'},{x:1450,y:180,s:0.8,type:'pine'},{x:1380,y:790,s:1.1,type:'deciduous'},{x:1520,y:60,s:1.2,type:'deciduous'},{x:1600,y:620,s:1,type:'pine'},{x:1050,y:40,s:1.1,type:'deciduous'},{x:1180,y:820,s:0.9,type:'deciduous'},{x:1820,y:450,s:1.2,type:'pine'},{x:830,y:820,s:0.9,type:'pine'},{x:900,y:850,s:1.2,type:'deciduous'},{x:1850,y:80,s:1,type:'pine'},{x:1800,y:800,s:0.8,type:'deciduous'},{x:850,y:50,s:1.1,type:'pine'},{x:600,y:800,s:1,type:'deciduous'},{x:1000,y:790,s:0.9,type:'pine'}];
    treeData.forEach(d => { d.y += 120; });
    treeData.forEach(d=>{ const t=document.createElement('div'); t.className=`tree ${d.type}`; const crownStyle = `transform: scale(${d.s}); ${d.type === 'deciduous' ? 'background-color:hsl(120, 60%, ' + (Math.random()*15+25) + '%)' : ''}`; t.innerHTML=`<div class="trunk" style="height:${(d.type === 'pine' ? 120 : 80)*d.s}px;width:${(d.type === 'pine' ? 15 : 20)*d.s}px;"></div><div class="crown" style="${crownStyle}"></div>`; t.style.left=d.x+'px'; t.style.top=d.y+'px'; gameWorld.insertBefore(t,stall) });
    for(let i=0;i<50;i++){const s=document.createElement('div');s.className='stone';const z=Math.random()*50+20;s.style.width=z+'px';s.style.height=z*(Math.random()*.4+.8)+'px';s.style.left=Math.random() > 0.5 ? river.clientWidth+5+Math.random()*20+'px' : Math.random() * (gameWorld.clientWidth - river.clientWidth - z) + river.clientWidth + 'px'; s.style.top=Math.random()*(gameWorld.clientHeight-z)+'px'; s.style.backgroundColor = `hsl(0, 0%, ${Math.random()*20+40}%)`; gameWorld.appendChild(s);}
    for(let i=0; i<30; i++) { const g = document.createElement('div'); g.className='grass-patch'; const z = Math.random()*80+40; g.style.width=z+'px'; g.style.height=z*(Math.random()*.5+.5)+'px'; g.style.left = Math.random() * (gameWorld.clientWidth - river.clientWidth - z) + river.clientWidth + 'px'; g.style.top = Math.random()*(gameWorld.clientHeight-z)+'px'; g.style.transform = `rotate(${Math.random()*180}deg)`; gameWorld.appendChild(g); }
    for(let i=0; i<25; i++) { const f = document.createElement('div'); f.className='flower'; const flowerColor = ['#ffc0cb', '#ffffff', '#e6e6fa', '#add8e6'][Math.floor(Math.random()*4)]; f.innerHTML = `<div class="flower-petal p1" style="background-color:${flowerColor}"></div><div class="flower-petal p2" style="background-color:${flowerColor}"></div><div class="flower-petal p3" style="background-color:${flowerColor}"></div><div class="flower-petal p4" style="background-color:${flowerColor}"></div><div class="flower-center"></div>`; f.style.left = Math.random() * (gameWorld.clientWidth - river.clientWidth - 20) + river.clientWidth + 'px'; f.style.top = Math.random()*(gameWorld.clientHeight-20)+'px'; gameWorld.appendChild(f); }
    for(let i=0;i<40;i++){const w=document.createElement('div');w.className='wave';w.style.left=Math.random()*(river.clientWidth-10)+'px';w.style.animationDelay=Math.random()*5+'s';river.appendChild(w);}
    for(let i=0;i<3;i++){for(let j=0;j<2;j++){const a=document.createElement('div');a.className='seating-area';a.innerHTML=`<div class="table"></div><div class="bench top"></div><div class="bench bottom"></div>`;a.style.right=(80+j*220)+'px';a.style.top=(100+i*180)+'px';gameWorld.appendChild(a);seatingAreas.push({element:a,occupied:!1});}}
    const outhouseRect = outhouse.getBoundingClientRect();
    for (let i = 0; i < 5; i++) { const stain = document.createElement('div'); stain.className = 'poop-stain'; const size = Math.random() * 25 + 10; stain.style.width = size + 'px'; stain.style.height = size * (Math.random() * 0.5 + 0.7) + 'px'; stain.style.borderRadius = `${Math.random()*50}% ${Math.random()*50}% ${Math.random()*50}% ${Math.random()*50}%`; stain.style.left = outhouseRect.left - 20 + (Math.random() * (outhouseRect.width + 40)) + 'px'; stain.style.top = outhouseRect.bottom - 20 + (Math.random() * 40) + 'px'; gameWorld.insertBefore(stain, outhouse); }
    for (let i = 0; i < 30; i++) { const p = document.createElement('div'); p.className='path-stone'; const s = Math.random() * 15 + 10; p.style.width=s+'px'; p.style.height=s*0.7+'px'; p.style.transform=`rotate(${Math.random()*180}deg)`; p.style.left=outhouse.offsetLeft - 60 + Math.random() * 80 + 'px'; p.style.top=outhouse.offsetTop + 120 + Math.random() * 100 + 'px'; gameWorld.insertBefore(p, stall); }
    for (let i = 0; i < 60; i++) { const p = document.createElement('div'); p.className='path-stone'; const s = Math.random() * 25 + 15; p.style.width=s+'px'; p.style.height=s*(Math.random()*0.3 + 0.6)+'px'; p.style.transform=`rotate(${Math.random()*180}deg)`; p.style.left=stallRect.left + stallRect.width/2 - 125 + Math.random() * 250 + 'px'; p.style.top=stallRect.bottom + Math.random() * (window.innerHeight - stallRect.bottom - s) + 'px'; gameWorld.insertBefore(p, stall); }
    createSupplyTable({x:280,y:90,w:100,h:40}); createStaticObject({x:290,y:80,w:80,h:50,isSupply:true,supplyType:'sausage',visuals:[{class:'sausage-stack-item',x:0,y:0,rot:10},{class:'sausage-stack-item',x:5,y:10,rot:-5},{class:'sausage-stack-item',x:-5,y:20,rot:5}]});
    createSupplyTable({x:410,y:90,w:100,h:40}); createStaticObject({x:430,y:75,w:50,h:50,isSupply:true,supplyType:'cheese',visuals:[{class:'cheese-stack-item',x:0,y:0},{class:'cheese-stack-item',x:8,y:8},{class:'cheese-stack-item',x:-4,y:16}]});
    createSupplyTable({x:360, y:300, w:100, h:40}); createStaticObject({x:380,y:285,w:60,h:50,isSupply:true,supplyType:'bread',visuals:[{class:'bread-stack-item',x:0,y:0},{class:'bread-stack-item',x:20,y:5},{class:'bread-stack-item',x:5,y:20}]});
    createSupplyTable({x:stall.offsetWidth-140, y:stall.offsetHeight-240, w:100, h:60}); createStaticObject({x:stall.offsetWidth-130,y:stall.offsetHeight-270,w:60,h:80,isSupply:true,supplyType:'plate',visuals:[{class:'plate-stack-item',x:0,y:0},{class:'plate-stack-item',x:0,y:4},{class:'plate-stack-item',x:0,y:8}]});
    createSilverTable({x:stall.offsetWidth-165,y:100,w:120,h:40}); createStaticObject({x:stall.offsetWidth-155,y:90,w:20,h:40,isSauce:true,sauceType:'ketchup',visuals:[{class:'ketchup-bottle'}]});
    createStaticObject({x:stall.offsetWidth-120,y:90,w:20,h:40,isSauce:true,sauceType:'mustard',visuals:[{class:'mustard-bottle'}]});
    createStaticObject({x:stall.offsetWidth-80,y:105,w:28,h:20,isSauce:true,sauceType:'cranberries',visuals:[{class:'cranberries-pot'}]});
    createSupplyTable({x: 20, y: 320, w: 80, h: 30});
    createStaticObject({x:25,y:280,w:30,h:75,isRelief:true,reliefType:'vodka',visuals:[{class:'vodka-bottle',html:'<div class="vodka-label">VODKA</div>'}]});
    createStaticObject({x:65,y:295,w:35,h:45,isRelief:true,reliefType:'cigarettes',visuals:[{class:'cigarettes-box'}]});
    
    const chair = document.createElement('div'); chair.className = 'chair';
    chair.innerHTML = '<div class="back"></div><div class="seat"></div><div class="leg front-left"></div><div class="leg front-right"></div><div class="leg back-left"></div><div class="leg back-right"></div>';
    
    chair.style.left = '20px'; 
    chair.style.top = (stall.offsetHeight - 90) + 'px';
    stall.appendChild(chair);

    milan.style.left = stall.offsetLeft + chair.offsetLeft + (chair.offsetWidth / 2) - (milan.offsetWidth / 2) - 365 + 'px';
    milan.style.top = stall.offsetTop + chair.offsetTop + (chair.offsetHeight / 2) - (milan.offsetHeight / 2) - 223 + 'px';
    startSmoking(true);

    setInterval(()=>{
        if(!gameRunning) return;
        survivalTime += 1;
        const t = translations[currentLanguage];
        timerDisplay.textContent=`${t.timerLabel}: ${Math.floor(survivalTime)}s`;
        if(Math.floor(survivalTime) > 0 && Math.floor(survivalTime) % 12 === 0) { if(customerSpawnInterval > 4000) customerSpawnInterval -= 600; baseStressRate += 0.012; }
    },1000);
    setInterval(() => { if(gameRunning) createDecorativeVessel(); }, 4000);
    
    scheduleNextCustomer();
    animationFrameId = requestAnimationFrame(gameLoop);
}

async function saveScore(gameId, newScoreData) {
    if (typeof auth === 'undefined' || typeof db === 'undefined') {
        console.log("Firebase not ready.");
        return;
    }
    const user = auth.currentUser;
    if (!user || !user.displayName) {
        console.log("User not logged in. Score not saved.");
        return;
    }

    const userName = user.displayName;
    const gameConfigs = {
        'milan': {
            collection: 'milan_leaderboard',
            isBetter: (newS, oldS) => newS.orders > oldS.orders || (newS.orders === oldS.orders && newS.time > oldS.time)
        }
    };

    const config = gameConfigs[gameId];
    if (!config) {
        console.error("Invalid gameId for saving score:", gameId);
        return;
    }

    const scoreDocRef = db.collection(config.collection).doc(userName);

    try {
        const doc = await scoreDocRef.get();
        if (!doc.exists || config.isBetter(newScoreData, doc.data())) {
            await scoreDocRef.set({ user: userName, ...newScoreData });
            console.log("High score saved for:", userName);
        } else {
            console.log("Score was not better. Not updating.");
        }
    } catch (error) {
        console.error("Error saving score: ", error);
    }
}


function endGame(reason) {
    gameRunning = false;
    cancelAnimationFrame(animationFrameId);
    
    saveScore('milan', { orders: ordersCompleted, time: Math.floor(survivalTime) });

    const t = translations[currentLanguage];
    document.getElementById('end-reason').textContent = reason;
    document.getElementById('end-score').textContent = `${t.gameOverScore} ${Math.floor(survivalTime)} ${t.gameOverSeconds}`;
    document.getElementById('end-orders').textContent = `${t.ordersCompleted}: ${ordersCompleted}`;
    gameOverScreen.style.display='flex'; 
}

window.onload = () => {
    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('lang-switch-btn').addEventListener('click', () => { currentLanguage = currentLanguage === 'cs' ? 'en' : 'cs'; updateAllText(); });
    document.getElementById('play-again-btn').addEventListener('click', () => window.location.reload());
    updateAllText();
};
</script>
</body>
</html>