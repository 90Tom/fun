<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Milanovy klobásy</title>
<style>
body, html { margin: 0; padding: 0; overflow: hidden; height: 100%; width: 100%; background-color: #3a8f2e; font-family: 'Courier New', Courier, monospace; }

.screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        z-index: 1000; display: flex; flex-direction: column;
        justify-content: center; align-items: center; text-align: center; color: white;
        overflow: hidden;
    }
    .screen-bg {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background-image: url('hospoda.png');
        background-size: cover; background-position: center;
        filter: blur(8px);
        transform: scale(1.1);
        z-index: -1;
    }
    .screen h1 { font-size: 5vw; text-shadow: 4px 4px 8px #000; margin-bottom: 10px; }
    .screen p { font-size: 1.2vw; max-width: 600px; margin: 0 auto 20px; text-shadow: 2px 2px 4px #000; }

    #milan-start-art { position: relative; width: 400px; height: 300px; display: flex; justify-content: center; align-items: center; }
    #milan-start-img { width: 200px; height: 200px; background-image: url('milan.png'); background-size: cover; animation: dance 2s ease-in-out infinite; z-index: 10; }
    @keyframes dance { 0%, 100% { transform: rotate(-5deg) scale(1); } 50% { transform: rotate(5deg) scale(1.05); } }

    .button-container {
        margin-top: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }
    .button-container button { font-family: 'Courier New', Courier, monospace; font-size: 24px; padding: 10px 20px; cursor: pointer; border: 3px solid white; background-color: #8B4513; color: white; border-radius: 5px; width: 200px; }
    #lang-switch-btn { font-size: 16px; background-color: #5C4033; }
    
    #game-over { display: none; }
    #game-over p { font-size: 1.5vw; }

    #game-world { position: relative; width: 100%; height: 100%; overflow: hidden; transition: filter 0.5s ease, transform 0.1s; }
    #river { position: absolute; left: 0; top: 0; width: 280px; height: 100%; background-color: #4682B4; overflow: hidden; }
    .wave { position: absolute; width: 15px; height: 3px; background-color: rgba(255, 255, 255, 0.6); border-radius: 50%; animation: flow 5s linear infinite; }
    @keyframes flow { from { transform: translateY(110vh); } to { transform: translateY(-10vh); } }
    .tree { position: absolute; z-index: 15; }
    .tree .trunk { position: absolute; bottom: 0; background-color: #5C4033; }
    .tree .crown { position: absolute; }
    .tree.deciduous .trunk { width: 20px; height: 80px; }
    .tree.deciduous .crown { bottom: 60px; left: -40px; width: 100px; height: 100px; border-radius: 40% 60% 45% 55% / 50% 45% 55% 50%; }
    .tree.pine .trunk { width: 15px; height: 120px; }
    .tree.pine .crown { position: absolute; bottom: 80px; left: -33px; width: 80px; height: 120px; }
    .tree.pine .crown::before, .tree.pine .crown::after { content: ''; position: absolute; width: 0; height: 0; border-left: 40px solid transparent; border-right: 40px solid transparent; left: 0; }
    .tree.pine .crown::before { border-bottom: 80px solid #1a4325; top: 0; transform: scale(1.1); }
    .tree.pine .crown::after { border-bottom: 60px solid #1e5631; top: 40px; }
    .stone { position: absolute; background-color: #808080; border-radius: 40% 60% 45% 55% / 50% 45% 55% 50%; z-index: 1; }
    .path-stone { position: absolute; background-color: #6b6b6b; border-radius: 30% 70% 25% 75% / 50% 40% 60% 50%; z-index: 1; }
    .grass-patch { position: absolute; background-color: #348029; border-radius: 40% 60% 45% 55% / 50% 45% 55% 50%; z-index: 1; opacity: 0.8; }
    .flower { position: absolute; z-index: 1; width: 20px; height: 20px; }
    .flower-center { position: absolute; width: 8px; height: 8px; background: yellow; border-radius: 50%; top: 6px; left: 6px; }
    .flower-petal { position: absolute; width: 10px; height: 10px; background: white; border-radius: 50%; border: 1px solid #ddd; }
    .p1 { top: 0; left: 5px; } .p2 { top: 5px; left: 0; } .p3 { top: 10px; left: 5px; } .p4 { top: 5px; left: 10px; }
    #stall { 
        position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); 
        width: 750px; height: 450px; 
        background: #DEB887;
        background-image: repeating-linear-gradient(to bottom, transparent, transparent 28px, rgba(0,0,0,0.1) 30px),
                          repeating-linear-gradient(to right, #DEB887, #DEB887 100px, #d1a974 102px);
        border: 8px solid #5C4033; 
        z-index: 3; 
        box-sizing: border-box;
    }
    #sauce-warning-sign {
        position: absolute;
        width: 150px;
        background-color: #FFFACD;
        border: 2px solid #8B4513;
        padding: 5px;
        text-align: center;
        z-index: 4;
        font-family: 'Courier New', Courier, monospace;
        font-size: 11px;
        box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    #sauce-warning-sign p {
        margin: 2px 0;
        font-weight: bold;
    }
    .cooler { position: absolute; background-color: #c0c0c0; border: 3px solid #555; width: 80px; height: 50px; } .cooler::before { content:''; position: absolute; top: 5px; left: 0; width: 100%; height: 2px; background: #555; }
    .chair { position: absolute; width: 30px; height: 50px; z-index: 4; }
    .chair .back { width: 100%; height: 30px; background: linear-gradient(#a55a30, #8B4513); position: absolute; top: 0; border-radius: 3px 3px 0 0; border: 1px solid #5C4033; box-sizing: border-box; }
    .chair .seat { width: 100%; height: 20px; background: #A0522D; position: absolute; bottom: 0; border: 2px solid #5C4033; box-sizing: border-box; border-top: none; }
    .chair .leg { position: absolute; width: 5px; height: 15px; background: #8B4513; bottom: -15px; }
    .chair .leg.front-left { left: 2px; } .chair .leg.front-right { right: 2px; }
    .chair .leg.back-left { left: 2px; bottom: -15px; z-index: -1; background: #6a340f; } .chair .leg.back-right { right: 2px; bottom: -15px; z-index: -1; background: #6a340f; }
    .relax-table { position: absolute; width: 40px; height: 30px; background: #A0522D; border: 2px solid #8B4513; border-radius: 2px;} .relax-table::after { content:''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%); width: 8px; height: 8px; background: #8B4513;}
    #grill { position: absolute; width: 220px; height: 120px; background-color: #36454F; border: 3px solid #000; border-radius: 5px; z-index: 4; }
    #outhouse { position: absolute; right: 80px; top: 60%; width: 80px; height: 120px; background: linear-gradient(90deg, #8B4513 80%, #7a3d11 80%); border: 2px solid #5C4033; z-index: 2; transition: transform 0.1s ease-in-out; }
    #outhouse::before { content:''; position:absolute; left:0; top:0; width:100%; height:100%; background: repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(0,0,0,0.2) 20px); }
    #outhouse.shake { animation: shake-it 0.5s infinite; }
    @keyframes shake-it { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px) rotate(-2deg); } 75% { transform: translateX(5px) rotate(2deg); } }
    #outhouse-roof { position: absolute; top: -20px; left: -10px; width: 100px; height: 20px; background-color: #5C4033; transform: skew(-20deg); }
    #outhouse-heart { position: absolute; top: 30px; left: 30px; width: 20px; height: 20px; background-color: #3a8f2e; }
    #outhouse-heart::before, #outhouse-heart::after { content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; background-color: #3a8f2e; } #outhouse-heart::before { top: -10px; left: 0; } #outhouse-heart::after { top: 0; left: 10px; }
    .seating-area { position: absolute; } .table { width: 120px; height: 50px; background-color: #A0522D; border: 3px solid #5C4033; } .bench { width: 140px; height: 20px; background-color: #A0522D; position: absolute; left: -10px; } .bench.top { top: -25px; } .bench.bottom { bottom: -25px; }
    #milan { position: absolute; width: 50px; height: 50px; background-image: url('milan.png'); background-size: cover; z-index: 10; }
    .item { position: absolute; z-index: 5; }
    .sausage { width: 48px; height: 12px; border-radius: 6px; border: 1px solid #8B4513; }
    .cheese { width: 30px; height: 30px; border-radius: 50%; border: 1px solid #8B4513; }
    .plate { width: 60px; height: 72px; background-color: #f0f0f0; border-radius: 3px; border: 1px solid #ccc; }
    .bread { width: 25px; height: 25px; background-color: #D2B48C; border: 1px solid #8B4513; border-radius: 3px; }
    .static-object { position: absolute; z-index: 4; }
    .ketchup-bottle, .mustard-bottle, .cranberries-pot, .vodka-bottle, .cigarettes-box { position: absolute; }
    .ketchup-bottle { width: 15px; height: 36px; background-color: red; border-radius: 3px 3px 0 0; }
    .mustard-bottle { width: 15px; height: 36px; background-color: #FFDB58; border-radius: 3px 3px 0 0; }
    .cranberries-pot { width: 24px; height: 18px; background-color: #d94468; border-radius: 3px; }
    .vodka-bottle { position: relative; width: 25px; height: 70px; background: linear-gradient(to right, rgba(200, 200, 255, 0.5), rgba(255,255,255,0.8), rgba(200, 200, 255, 0.5)); border: 1px solid #88a; clip-path: polygon(0 100%, 0 25%, 30% 10%, 30% 0, 70% 0, 70% 10%, 100% 25%, 100% 100%); }
    .vodka-bottle::before { content:''; position: absolute; top: 0; left: 30%; width: 40%; height: 5px; background: #444; }
    .vodka-label { z-index: 1; font-size: 8px; color: #fff; background: #c00; padding: 1px 0; border: 1px solid #fff; text-shadow: 1px 1px 1px #000; user-select: none; position: absolute; top: 30px; left: -10px; width: 45px; transform: rotate(-90deg); text-align: center; }
    .cigarettes-box { width: 30px; height: 40px; background: linear-gradient(#eee, #fff); border: 1px solid #999; box-shadow: 1px 1px 3px rgba(0,0,0,0.3); }
    .cigarettes-box::before { content: 'Marlboro'; font-size: 7px; text-align: center; color: white; font-weight: bold; position: absolute; top: 0; left: 0; width: 100%; height: 15px; background-color: #d42121; line-height: 15px; letter-spacing: -0.5px; }
    .raw-sausage { background-color: #FFC0CB; } .golden-sausage { background-color: #DAA520; } .welldone-sausage { background-color: #A0522D; } .burnt-sausage { background-color: #3b2707; }
    .raw-cheese { background-color: #F5F5DC; } .golden-cheese { background-color: #F0E68C; } .welldone-cheese { background-color: #D2B48C; } .burnt-cheese { background-color: #5a4d36; }
    .ketchup-splash { position: absolute; width: 100%; height: 3px; background-color: red; top: 45%; }
    .mustard-splash { position: absolute; width: 100%; height: 3px; background-color: #FFDB58; top: 55%; }
    .cranberries-splash { position: absolute; width: 18px; height: 18px; background-color: #d94468; border-radius: 50%; top: 6px; left: 6px; }
    .smoke { position: absolute; width: 6px; height: 6px; background-color: rgba(200, 200, 200, 0.6); border-radius: 50%; animation: smoke-drift 3s ease-out forwards; pointer-events: none; z-index: 12; }
    @keyframes smoke-drift { from { transform: translateY(0) scale(1); opacity: 0.8; } to { transform: translateY(-100px) translateX(40px) scale(3.5); opacity: 0; } }
    #trash-can { position: absolute; width: 50px; height: 70px; background-color: #696969; border-bottom-left-radius: 10px; border-bottom-right-radius: 10px; z-index: 4; }
    
    .deco-vessel { position: absolute; transition-property: top; transition-timing-function: linear; z-index: 2; }
    .kayak { width: 50px; position: relative; }
    .kayak-body { width: 100%; height: 100%; clip-path: polygon(50% 0%, 100% 15%, 100% 85%, 50% 100%, 0 85%, 0 15%); position: relative; }
    .kayak.red .kayak-body { background-color: #DC143C; } .kayak.green .kayak-body { background-color: #008000; } .kayak.blue .kayak-body { background-color: #0000CD; }
    .kayak-person { position: absolute; width: 20px; height: 20px; background-color: #FFDAB9; border-radius: 50%; border: 2px solid #d3a98d; box-sizing: border-box;}
    .big-ship { width: 100px; height: 200px; background-color: #708090; }
    .big-ship::before { content: ''; position: absolute; width: 70px; height: 40px; background: #D3D3D3; top: 15px; left: 15px; }
    .big-ship::after { content: ''; position: absolute; width: 0; height: 0; border-left: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 20px solid #A9A9A9; top: -5px; left: 30px; }
    .raft { width: 70px; height: 100px; }
    .raft::before { content: ''; position: absolute; width: 100%; height: 100%; background: repeating-linear-gradient(to right, #8B4513, #8B4513 15px, #6a340f 16px, #6a340f 18px); }
    .raft-person { position: absolute; top: 40px; left: 25px; width: 20px; height: 20px; background-color: #FFDAB9; border-radius: 50%; border: 2px solid #d3a98d; box-sizing: border-box;}

    .customer-figure { position: absolute; width: 40px; height: 70px; transition: left 3s ease-in-out, top 3s ease-in-out; z-index: 9; }
    .customer-figure .head { width: 22px; height: 22px; background-color: #FFDAB9; border-radius: 50%; margin: 0 auto; position: relative; border: 1px solid #d3a98d; z-index: 2; }
    .customer-figure .face .eye { position: absolute; width: 3px; height: 3px; background: black; border-radius: 50%; top: 9px; }
    .customer-figure .face .eye.left { left: 5px; } .customer-figure .face .eye.right { right: 5px; }
    .customer-figure .face .mouth { position: absolute; bottom: 4px; left: 50%; transform: translateX(-50%); width: 8px; height: 3px; border-bottom: 2px solid #a56851; border-radius: 0 0 4px 4px; }
    .customer-figure .hair { position: absolute; top: -8px; left: 50%; transform: translateX(-50%); color: #3d2d1b; z-index: 3; }
    .hair.style1 { width: 26px; height: 14px; background: currentColor; border-radius: 50% 50% 20% 20% / 80% 80% 20% 20%; top: -10px; }
    .hair.style2 { width: 28px; height: 18px; background: currentColor; border-radius: 40% 40% 0 0; top: -10px; }
    .hair.style4 { width: 2px; height: 10px; background: currentColor; top: -6px; box-shadow: -7px 1px 0 0.5px currentColor, 7px 1px 0 0.5px currentColor, -3.5px -1px 0 0.5px currentColor, 3.5px -1px 0 0.5px currentColor, 10.5px 3px 0 0.5px currentColor, -10.5px 3px 0 0.5px currentColor, 0 -2px 0 0.5px currentColor; }
    .customer-figure .torso { width: 32px; height: 28px; margin: 0 auto; position: relative; top: -2px; border-radius: 15px 15px 5px 5px; }
    .customer-figure .arm { width: 8px; height: 26px; position: absolute; top: 23px; border-radius: 4px; z-index: 0; }
    .customer-figure .leg { width: 9px; height: 22px; position: absolute; top: 48px; border-radius: 5px; z-index: 0; }
    
    .customer-figure.man .torso { background-color: #FFDAB9; clip-path: polygon(0 0, 100% 0, 85% 100%, 15% 100%); }
    .customer-figure.man .shorts { width: 26px; height: 14px; background-color: #0000FF; margin: 0 auto; position: absolute; top: 49px; left: 7px; border-top: 2px solid rgba(0,0,0,0.2); box-sizing: border-box; z-index: 1; }
    .shorts.style-a { clip-path: polygon(0 0, 100% 0, 100% 100%, 60% 100%, 50% 85%, 40% 100%, 0 100%); }
    .shorts.style-boardshorts { height: 18px; }
    .shorts.style-speedo { height: 10px; top: 48px; clip-path: polygon(10% 0, 90% 0, 100% 100%, 0 100%);}
    .customer-figure.man .arm.left { left: 2px; } .customer-figure.man .arm.right { right: 2px; }
    .customer-figure.man .leg.left { left: 6px; } .customer-figure.man .leg.right { right: 6px; }
    
    .customer-figure.woman .torso { background: #FFDAB9; width: 28px; clip-path: polygon(20% 0, 80% 0, 95% 100%, 5% 100%); }
    .customer-figure.woman.curvy .torso { clip-path: polygon(25% 0, 75% 0, 100% 100%, 0 100%); }
    .customer-figure.woman .torso::before, .customer-figure.woman .torso::after { content: ''; position: absolute; background-color: #FFDAB9; border: 1px solid #d3a98d; box-sizing: border-box; z-index: -1; }
    .customer-figure.woman .torso.boobs-small::before, .customer-figure.woman .torso.boobs-small::after { width: 9px; height: 9px; border-radius: 50%; top: 6px; }
    .customer-figure.woman .torso.boobs-medium::before, .customer-figure.woman .torso.boobs-medium::after { width: 11px; height: 11px; border-radius: 50%; top: 5px; }
    .customer-figure.woman .torso.boobs-large::before, .customer-figure.woman .torso.boobs-large::after { width: 13px; height: 13px; border-radius: 50%; top: 4px; }
    .customer-figure.woman .torso.boobs-small::before, .customer-figure.woman .torso.boobs-medium::before, .customer-figure.woman .torso.boobs-large::before { left: 1px; }
    .customer-figure.woman .torso.boobs-small::after, .customer-figure.woman .torso.boobs-medium::after, .customer-figure.woman .torso.boobs-large::after { right: 1px; }
    .customer-figure.woman .arm.left { left: 4px; } .customer-figure.woman .arm.right { right: 4px; }
    .customer-figure.woman .leg.left { left: 8px; } .customer-figure.woman .leg.right { right: 8px; }

    .one-piece-suit { position: absolute; top: 25px; left: 6px; width: 28px; height: 35px; z-index: 1; clip-path: polygon(20% 0, 80% 0, 100% 80%, 80% 100%, 20% 100%, 0 80%); }
    .bikini-top, .bikini-bottom { position: absolute; z-index: 1; background-color: inherit; }
    .bikini-top { top: 28px; left: 8px; width: 24px; height: 12px; }
    .bikini-top.style-triangle { clip-path: polygon(10% 20%, 25% 0, 75% 0, 90% 20%, 50% 80%); top: 29px; }
    .bikini-top.style-bandeau { height: 8px; top: 30px; clip-path: none; border-radius: 2px; }
    .bikini-top.style-circles-connected::before, .bikini-top.style-circles-connected::after { content: ''; position: absolute; width: 10px; height: 10px; background-color: inherit; border-radius: 50%; top: 0px; }
    .bikini-top.style-circles-connected::before { left: 2px; } .bikini-top.style-circles-connected::after { right: 2px; }
    .bikini-top.style-circles-connected { background-color: transparent; border-bottom: 2px solid; border-color: inherit; top: 29px; height: 0; }
    .bikini-top.style-balls::before, .bikini-top.style-balls::after { content: ''; position: absolute; width: 10px; height: 10px; background-color: inherit; border-radius: 50%; top: 2px; }
    .bikini-top.style-balls::before { left: 2px; } .bikini-top.style-balls::after { right: 2px; }
    .bikini-bottom { top: 49px; left: 8px; width: 26px; height: 9px; }
    .bikini-bottom.style-a { clip-path: polygon(10% 0, 90% 0, 85% 100%, 15% 100%); }
    .bikini-bottom.style-b { clip-path: polygon(15% 0, 85% 0, 100% 100%, 0% 100%); width: 28px; left: 6px;}
    .bikini-bottom.style-thong { background: transparent; }
    .bikini-bottom.style-thong::before { content: ''; position: absolute; top:0; left: -2px; width: 30px; height: 1px; background-color: inherit; }
    .bikini-bottom.style-thong::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: inherit; clip-path: polygon(40% 0, 60% 0, 55% 100%, 45% 100%); }
    
    .customer-figure.obese .torso { width: 38px; transform: scaleY(0.9); }
    .customer-figure.obese.man .torso { clip-path: polygon(0 0, 100% 0, 90% 100%, 10% 100%); }
    .customer-figure.obese.woman .torso { width: 34px; clip-path: polygon(15% 0, 85% 0, 100% 100%, 0% 100%); }
    .customer-figure.obese .leg { width: 11px; }
    .customer-figure.obese .arm { width: 10px; }
    .customer-figure.obese .shorts, .customer-figure.obese.woman .bikini-bottom { width: 30px; left: 5px; }
    .customer-figure.obese .one-piece-suit { width: 34px; left: 3px; clip-path: polygon(15% 0, 85% 0, 100% 85%, 85% 100%, 15% 100%, 0 85%); }

    .speech-bubble { visibility: hidden; position: absolute; background: white; border-radius: .4em; padding: 10px; min-width: 150px; max-width: 200px; bottom: 80px; left: 50%; transform: translateX(-50%); z-index: 20; border: 2px solid black; font-size: 14px; opacity: 0; transition: opacity 0.5s; }
    .speech-bubble.visible { visibility: visible; opacity: 1; }
    .speech-bubble:after { content: ''; position: absolute; bottom: 0; left: 50%; width: 0; height: 0; border: 15px solid transparent; border-top-color: black; border-bottom: 0; margin-left: -15px; margin-bottom: -15px; }
    .wait-timer-container { position: absolute; top: -15px; left: 0; width: 100%; height: 6px; background-color: #555; border: 1px solid #000; border-radius: 3px; visibility: hidden; }
    .wait-timer-bar { width: 100%; height: 100%; background-color: #32CD32; border-radius: 2px; transition: width 0.5s linear; }
    #ui-container { position: absolute; top: 10px; right: 10px; z-index: 100; color: white; text-shadow: 2px 2px 4px #000; }
    #stress-bar-container { width: 200px; height: 30px; background-color: #ccc; border: 2px solid black; }
    #stress-bar { width: 0%; height: 100%; background-color: red; transition: width 0.5s; }
    #timer { margin-top: 10px; font-size: 24px; }
    .sausage-stack-item, .cheese-stack-item, .plate-stack-item, .bread-stack-item { position: absolute; pointer-events: none; }
    .sausage-stack-item { width: 48px; height: 12px; background-color: #FFC0CB; border-radius: 6px; border: 1px solid #8B4513; }
    .cheese-stack-item { width: 30px; height: 30px; background-color: #F5F5DC; border-radius: 50%; border: 1px solid #8B4513; }
    .plate-stack-item { width: 60px; height: 72px; background-color: #f0f0f0; border-radius: 3px; border: 1px solid #ccc; }
    .bread-stack-item { width: 25px; height: 25px; background-color: #D2B48C; border: 1px solid #8B4513; border-radius: 3px; }
    .milan-bubble { position: absolute; background: white; padding: 5px 10px; border: 1px solid black; border-radius: 5px; z-index: 100; font-weight: bold; }
    .cigarette-visual { position: absolute; width: 40px; height: 6px; background: white; border: 1px solid #aaa; z-index: 11; border-radius: 2px; transform-origin: left center; }
    .cigarette-visual::after { content:''; position: absolute; right: 0; top: 0; height: 100%; width: 5px; background: orange; animation: burn 5s linear forwards; }
    @keyframes burn { from { width: 5px; } to { width: 40px; } }
    .supply-table-container, .silver-table-container { z-index: 3; position: absolute; }
    .supply-table-top { position: absolute; background-color: #A0522D; border: 3px solid #8B4513; border-radius: 4px; z-index: 2; }
    .supply-table-leg { position: absolute; background-color: #8B4513; width: 10px; height: 20px; z-index: 1; }
    .silver-table-top { position: absolute; background-color: #c0c0c0; border: 3px solid #555; border-radius: 4px; z-index: 2; }
    .silver-table-leg { position: absolute; background-color: #555; width: 10px; height: 20px; z-index: 1; }
    .poop-particle { position: absolute; width: 8px; height: 8px; background: #5C4033; border-radius: 50%; animation: fade-out-fast 2.5s forwards; opacity: 0.8; }
    @keyframes fade-out-fast { to { opacity: 0; transform: scale(0.2); } }
    .dirt-particle { position: absolute; width: 7px; height: 7px; background: #8B4513; border-radius: 2px; animation: kick-up 0.8s ease-out forwards; }
    @keyframes kick-up { from { transform: translateY(0) scale(1); opacity: 0.9; } to { transform: translateY(-40px) translateX(20px) scale(0) rotate(360deg); opacity: 0; } }
    .drunk-particle { position: absolute; width: 15px; height: 15px; border-radius: 50%; pointer-events: none; animation: float-up 2s ease-out forwards; z-index: 200; }
    @keyframes float-up { from { transform: translateY(0) scale(1); opacity: 0.7; } to { transform: translateY(-200px) scale(0); opacity: 0; } }
    .poop-stain { position: absolute; background-color: #5a4d36; opacity: 0.6; z-index: 1; }
</style>
</head>
<body>
<div id="start-screen" class="screen">
<div class="screen-bg"></div>
<h1></h1>
<p id="start-screen-subtitle"></p>
<div id="milan-start-art">
<div id="milan-start-img"></div>
</div>
<div class="button-container">
<button id="start-btn"></button>
<button id="lang-switch-btn"></button>
</div>
</div>
<div id="game-world">
    <div id="river"></div>
    <div id="stall">
         <div id="sauce-warning-sign">
            <p id="sauce-warning-cs"></p>
            <p id="sauce-warning-en"></p>
         </div>
         <div id="grill"></div>
         <div id="trash-can"></div>
    </div>
    <div id="outhouse"><div id="outhouse-roof"></div><div id="outhouse-heart"></div></div>
    <div id="milan"></div>
</div>
<div id="ui-container">
    <div><span id="stress-label"></span>:</div>
    <div id="stress-bar-container"><div id="stress-bar"></div></div>
    <div id="timer"></div>
</div>
<div id="game-over" class="screen">
    <div class="screen-bg"></div>
    <h1 id="game-over-title"></h1>
    <p id="end-reason"></p>
    <p id="end-score"></p>
    <p id="end-orders"></p>
    <div class="button-container">
        <button id="play-again-btn"></button>
    </div>
</div>

<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

<script>
    (function() {
        const firebaseConfig = {
            apiKey: "AIzaSyDNzjX6dmx2fGPhLW-ZIADhNigsfwMY3Ng",
            authDomain: "tom-fun.firebaseapp.com",
            databaseURL: "https://tom-fun-default-rtdb.firebaseio.com",
            projectId: "tom-fun",
            storageBucket: "tom-fun.appspot.com",
            messagingSenderId: "710857129785",
            appId: "1:710857129785:web:5f2cdebe736577ea0e72e8"
        };
        
        try {
            const app = firebase.apps.length ? firebase.app() : firebase.initializeApp(firebaseConfig, "presenceApp");
            const auth = firebase.auth(app);
            const rtdb = firebase.database(app);

            auth.onAuthStateChanged(user => {
                let uid;
                if (user) {
                    uid = user.uid;
                    setupPresence(uid, rtdb);
                } else {
                    auth.signInAnonymously().catch(err => console.error("Anonymous sign-in for presence failed:", err));
                }
            });

            function setupPresence(uid, rtdb) {
                const userStatusDatabaseRef = rtdb.ref('/status/' + uid);
                const isOfflineForDatabase = { state: 'offline', last_changed: firebase.database.ServerValue.TIMESTAMP };
                const isOnlineForDatabase = { state: 'online', last_changed: firebase.database.ServerValue.TIMESTAMP };
                
                rtdb.ref('.info/connected').on('value', function(snapshot) {
                    if (snapshot.val() == false) return;
                    userStatusDatabaseRef.onDisconnect().set(isOfflineForDatabase).then(function() {
                        userStatusDatabaseRef.set(isOnlineForDatabase);
                    });
                });
            }

        } catch (e) {
            console.error("Firebase presence initialization failed in game:", e);
        }
    })();
</script>

<script>
    const firebaseConfig = {
        apiKey: "AIzaSyDNzjX6dmx2fGPhLW-ZIADhNigsfwMY3Ng",
        authDomain: "tom-fun.firebaseapp.com",
        projectId: "tom-fun",
        storageBucket: "tom-fun.appspot.com",
        messagingSenderId: "710857129785",
        appId: "1:710857129785:web:5f2cdebe736577ea0e72e8",
        measurementId: "G-6MHP8FHQ87"
    };

let db, auth;
try {
    firebase.initializeApp(firebaseConfig);
    db = firebase.firestore();
    auth = firebase.auth();
} catch (e) {
    console.error("Firebase initialization failed:", e);
}

const gameWorld = document.getElementById('game-world');
const milan = document.getElementById('milan');
const river = document.getElementById('river');
const stall = document.getElementById('stall');
const stressBar = document.getElementById('stress-bar');
const timerDisplay = document.getElementById('timer');
const gameOverScreen = document.getElementById('game-over');
const outhouse = document.getElementById('outhouse');
const startScreen = document.getElementById('start-screen');

let heldItem = null, keys = {}, items = [], customers = [], seatingAreas = [], staticObjects = [];
let stress = 0, survivalTime = 0, gameRunning = false, controlsImpaired = false, isConsuming = false, baseStressRate = 0.045, ordersCompleted = 0;
let grill, trashCan, queueSlots = [], milanSwearCooldown = false;
let intoxicationLevel = 0, nicotineLevel = 0;
let customerSpawnInterval = 9000;
let maxQueueSize = 3;
const COOK_STATES = { RAW: 0, GOLDEN: 1, WELLDONE: 2, BURNT: 3 };
const COOK_TIMES = { SAUSAGE: 6.5, CHEESE: 5 };
const MILAN_SPEED = 400;

let lastTime = 0;
let animationFrameId;
let riverLanes = { left: false, center: false, right: false };

let currentLanguage = 'cs';
const translations = {
    cs: {
        title: "Milanovy klobásy",
        subtitle: "Připravujte výtečná jídla v očích prémiového kuchaře Milana. Používejte klávesy WASD a E a před doručením jídla jej nezapomeňte vyložit na papírový tácek.",
        startButton: "Vařit",
        langButton: "English",
        stressLabel: "Stres", timerLabel: "Přežíváš",
        gameOverTitle: "KONEC HRY", gameOverReasonCollapse: "Totální nervové zhroucení!", gameOverReasonAlcohol: "Otrava alkoholem.", gameOverScore: "Přežil jsi", gameOverSeconds: "sekund.", ordersCompleted: "Dokončené objednávky", playAgain: "Znovu hrát",
        sauceWarning: "Pozor, omáčka šplouchá!<br>Udržujte prosím odstup.",
        milanSwears: ["Do p*či!", "Hajzlové!", "Už nemůžu!", "K*nda!", "Zm*di!", "P*ča!", "Do pr*ele!", "K*rva!", "To je den na h*vno!", "Sakra práce!", "Zblázním se z toho!"], 
        milanRelief: ["K*rva!", "Do p*dele!", "Konečně chvilka klidu.", "Tohle jsem potřeboval.", "Ah, sladká úleva."], 
        milanDrop: "Dopr*ele!",
        withKetchup: "S kečupem.", withMustard: "S hořčicí.", withBoth: "S obojím.", withCranberries: "S brusinkama.", andBread: "A {count} chleba.",
        nice_man: ["Dobrý den, prosil bych ", "Můžu poprosit o ", "Dobrý den, dal bych si ", "Zdravím, měl bych chuť na ", "Dobrý den, vypadá to skvěle. Dám si ", "Prosím vás, připravte mi "], 
        nice_woman: ["Dobrý den, prosila bych ", "Můžu poprosit o ", "Dobrý den, dala bych si ", "Pěkný den, chtěla bych ochutnat ", "Vypadá to úžasně! Proсила bych ", "Můžete mi prosím udělat "], 
        neutral_man: ["Dám si ", "Chtěl bych ", "Připravte mi ", "Chci ", "Dám si ", "Objednávám "], 
        neutral_woman: ["Dám si ", "Chtěla bych ", "Připravte mi ", "Chci ", "Dám si ", "Objednávám "], 
        rude: ["Hej, dělej, chci ", "No tak, bude to? Chci ", "Čekám na ", "Hni sebou, mám hlad na ", "Doufám, že to nebude trvat věčnost. Chci ", "Hej ty! Chci "],
        customerCurses: ["Co to je za sra*ku?!", "Tohle si strč do pr*ele!", "Tohle se nedá žrát!", "Fuj, to je hnus!", "Čekal jsem kvalitu, ne tenhle bl*f!", "Zm*de!", "Si děláš k*zy?!", "Č*ráku!", "Dě*ko!", "P*čo!", "Jdi do h*jzlu!", "Ty dědku zas*anej!", "Tohle by nežral ani pes!", "Za tohle platit nebudu!"], 
        customerImpatient: "Na tohle se ti můžu vys*at!", 
        customerRudeComments: ["Nic moc teda.", "Čekal jsem víc.", "Už se nevrátím.", "Bylo to... jedlý.", "Hmm.", "No, aspoň jsem se najedl.", "Příště zkusím něco jiného.", "Za ty peníze nic extra."], 
        outhouseCurses: ["Ta kadibudka je peklo!", "Hrůza, ten smrad!", "Strašně to pálí!", "Už sem nikdy nepudu!", "Potřebuju doktora, hned!", "Proboha, co to bylo?!", "Moje útroby hoří!", "To je biologická zbraň!", "Okamžitě dezinfekci!", "Nikdy víc!"],
        sausage_adj: { singular: { [COOK_STATES.GOLDEN]: "zlatavou", [COOK_STATES.WELLDONE]: "propečenou" }, plural: { [COOK_STATES.GOLDEN]: "zlatavé", [COOK_STATES.WELLDONE]: "propečené" }, genitive: { [COOK_STATES.GOLDEN]: "zlatavých", [COOK_STATES.WELLDONE]: "propečených" } },
        cheese_adj: { singular: { [COOK_STATES.GOLDEN]: "zlatavý", [COOK_STATES.WELLDONE]: "propečený" }, plural: { [COOK_STATES.GOLDEN]: "zlatavé", [COOK_STATES.WELLDONE]: "propečené" }, genitive: { [COOK_STATES.GOLDEN]: "zlatavých", [COOK_STATES.WELLDONE]: "propečených" } },
        sausage_plural: { 1: "klobásu", 2: "klobásy", 5: "klobás" },
        cheese_plural: { 1: "hermelín", 2: "hermelíny", 5: "hermelínů" },
        numbers: { 1: "jednu", 2: "dvě", 3: "tři", 4: "čtyři", 5: "pět" },
        numbers_male: { 1: "jeden", 2: "dva", 3: "tři", 4: "čtyři", 5: "pět" }
    },
    en: {
        title: "Milan's Sausages",
        subtitle: "Prepare delicious meals under the watchful eye of premium chef Milan. Use WASD and E keys, and don't forget to place the food on a paper plate before delivery.",
        startButton: "Cook",
        langButton: "Česky",
        stressLabel: "Stress", timerLabel: "Surviving",
        gameOverTitle: "GAME OVER", gameOverReasonCollapse: "Total mental breakdown!", gameOverReasonAlcohol: "Alcohol poisoning.", gameOverScore: "You survived", gameOverSeconds: "seconds.", ordersCompleted: "Orders Completed", playAgain: "Play Again",
        sauceWarning: "Caution, sauce splashes!<br>Please keep your distance.",
        milanSwears: ["F**k!", "A**holes!", "I can't take it!", "Son of a b**ch!", "D*mn it!", "This day sucks!", "For f**k's sake!", "I'm losing my mind!"], 
        milanRelief: ["Ah, f**k it!", "Here we go...", "Finally, a moment of peace.", "I needed this.", "Ah, sweet relief."], 
        milanDrop: "Oh, sh*t!",
        withKetchup: "With ketchup.", withMustard: "With mustard.", withBoth: "With both.", withCranberries: "With cranberries.", andBread: "And {count} bread.",
        nice_man: ["Hello, I would like ", "Could I please have ", "Hi, I'll take ", "Greetings, I'm in the mood for ", "Hello, that looks delicious. I'll have ", "Could you prepare me "], 
        nice_woman: ["Hello, I would like ", "Could I please have ", "Hi, I'll take ", "Good day, I'd love to try ", "That looks amazing! I would like ", "Could you please make me "], 
        neutral_man: ["I'll have ", "I want ", "Get me ", "One of those.", "I'll take the usual.", "Just give me "], 
        neutral_woman: ["I'll have ", "I want ", "Get me ", "One of those.", "I'll take the usual.", "Just give me "], 
        rude: ["Hey, hurry up, I want ", "Come on, will ya? I want ", "I'm waiting for ", "Move it, I'm starving for ", "I hope this doesn't take all day. I want ", "Hey you! I want "],
        customerCurses: ["What is this crap?!", "You can shove this up your a**!", "This is inedible!", "Ugh, disgusting!", "I expected quality, not this garbage!", "You moron!", "You old fart!", "Even my dog wouldn't eat this!", "I'm not paying for this filth!"], 
        customerImpatient: "I'm not waiting for this sh*t!", 
        customerRudeComments: ["Not great.", "I expected more.", "I'm not coming back.", "It was... edible.", "Hmm.", "Well, at least it's food.", "I'll try something else next time.", "Not worth the money."], 
        outhouseCurses: ["That outhouse is hell!", "Horrible, the stench!", "God, it burns!", "I'm never coming here again!", "I need a doctor, now!", "Oh god, what was that?!", "My insides are on fire!", "That's a biological weapon!", "I need a shower, immediately!", "Never again!"],
        sausage_adj: { [COOK_STATES.GOLDEN]: "golden-brown", [COOK_STATES.WELLDONE]: "well-done" },
        cheese_adj: { [COOK_STATES.GOLDEN]: "golden-brown", [COOK_STATES.WELLDONE]: "well-done" },
        sausage_plural: { 1: "sausage", 2: "sausages" },
        cheese_plural: { 1: "camembert", 2: "camemberts" },
    }
};

function updateAllText() {
    const t = translations[currentLanguage];
    document.documentElement.lang = currentLanguage;
    document.getElementById('start-screen').querySelector('h1').textContent = t.title;
    document.getElementById('start-screen-subtitle').innerHTML = t.subtitle;
    document.getElementById('start-btn').textContent = t.startButton;
    document.getElementById('lang-switch-btn').textContent = t.langButton;
    document.getElementById('stress-label').textContent = t.stressLabel;
    document.getElementById('game-over-title').textContent = t.gameOverTitle;
    document.getElementById('play-again-btn').textContent = t.playAgain;
    
    const czechWarning = document.getElementById('sauce-warning-cs');
    const englishWarning = document.getElementById('sauce-warning-en');

    czechWarning.innerHTML = translations.cs.sauceWarning;
    englishWarning.innerHTML = translations.en.sauceWarning;

    if (currentLanguage === 'cs') {
        czechWarning.style.display = 'block';
        englishWarning.style.display = 'none';
    } else {
        czechWarning.style.display = 'none';
        englishWarning.style.display = 'block';
    }
}

document.addEventListener('keydown', e => { if (gameRunning) keys[e.key.toLowerCase()] = true; });
document.addEventListener('keyup', e => {
    if (!gameRunning) return;
    const key = e.key.toLowerCase();
    if (key === 'e') handleInteraction();
    delete keys[key];
});

function getDistance(e1,e2){const r1=e1.getBoundingClientRect(),r2=e2.getBoundingClientRect();return Math.sqrt(Math.pow(r1.left+r1.width/2-(r2.left+r2.width/2),2)+Math.pow(r1.top+r1.height/2-(r2.top+r2.height/2),2))}

function handleInteraction() {
    if (!gameRunning || isConsuming) return;
    if (heldItem) {
        if (heldItem.type === 'plate' && heldItem.contents.length > 0) {
            let interactedWithSauce = false;
            staticObjects.forEach(obj => {
                if (obj.isSauce && getDistance(milan, obj.element) < 120) {
                    const plate = heldItem;
                    plate.contents.forEach(food => {
                        if (obj.sauceType === 'ketchup' && food.type === 'sausage' && !plate.hasKetchup) { plate.hasKetchup = true; const s = document.createElement('div'); s.className = 'ketchup-splash'; food.element.appendChild(s); interactedWithSauce = true; }
                        else if (obj.sauceType === 'mustard' && food.type === 'sausage' && !plate.hasMustard) { plate.hasMustard = true; const s = document.createElement('div'); s.className = 'mustard-splash'; food.element.appendChild(s); interactedWithSauce = true; }
                        else if (obj.sauceType === 'cranberries' && food.type === 'cheese' && !plate.hasCranberries) { plate.hasCranberries = true; const s = document.createElement('div'); s.className = 'cranberries-splash'; food.element.appendChild(s); interactedWithSauce = true; }
                    });
                }
            });
            if (interactedWithSauce) return;
        }
        if (heldItem.type === 'plate' && heldItem.contents.length > 0) {
            let closestCustomer = null, minDistance = 150;
            customers.filter(c => c.state === 'waiting_in_queue').forEach(cust => {
                const dist = getDistance(milan, cust.figureElement);
                if (dist < minDistance) { minDistance = dist; closestCustomer = cust; }
            });
            if (closestCustomer) {
                if (checkOrder(heldItem, closestCustomer.order)) {
                    ordersCompleted++;
                    closestCustomer.state = 'walking_to_table';
                    closestCustomer.speechBubble.classList.remove('visible');
                    closestCustomer.waitTimerContainer.style.visibility = 'hidden';
                    moveCustomerToTable(closestCustomer, heldItem);
                } else {
                    updateStress(closestCustomer.personality === 'rude' ? 40 : 30);
                    customerCusses(closestCustomer);
                }
                while (heldItem.element.firstChild) { heldItem.element.removeChild(heldItem.element.firstChild); }
                heldItem.element.remove();
                items.splice(items.indexOf(heldItem), 1);
                heldItem = null;
                return;
            }
        }
        let placedOnPlate = false;
        if (['sausage', 'cheese', 'bread'].includes(heldItem.type)) {
            items.filter(i => i.type === 'plate').forEach(plate => {
                if (!placedOnPlate && isOverlapping(heldItem.element, plate.element)) {
                    if (heldItem.type === 'bread') {
                        if (plate.breadCount < 4) { plate.breadCount = (plate.breadCount || 0) + 1; heldItem.element.style.top = (5 + plate.breadCount * 12) + 'px'; } else return;
                    } else if (plate.contents.length < 2) {
                        plate.contents.push(heldItem);
                    } else return;
                    if(heldItem.type !== 'bread') {
                        heldItem.element.style.left = (plate.contents.length === 1 ? '5px' : '30px');
                        heldItem.element.style.top = (heldItem.type === 'sausage' ? '25px' : '20px');
                    } else {
                        heldItem.element.style.left = '5px';
                    }
                    heldItem.onPlate = plate; placedOnPlate = true; heldItem.isHeld = false; heldItem.element.style.zIndex = 6;
                    plate.element.appendChild(heldItem.element); 
                    items.splice(items.indexOf(heldItem), 1);
                    heldItem = null;
                }
            });
        }
        if (heldItem) { heldItem.isHeld = false; heldItem.element.style.zIndex = 5; heldItem = null; }
    } else {
        let closestItem = null, minDistance = 100;
        items.sort((a, b) => (a.type === 'plate' && a.contents.length > 0) ? -1 : 1);
        items.forEach(item => { 
            const distance = getDistance(milan, item.element); 
            if (distance < minDistance) { minDistance = distance; closestItem = item; } 
        });
        if (closestItem) {
            heldItem = closestItem; 
            heldItem.isHeld = true; 
            heldItem.element.style.zIndex = 11;
            return;
        }
        let closestStatic = null, minStaticDist = 120;
        staticObjects.forEach(obj => { const dist = getDistance(milan, obj.element); if (dist < minStaticDist) { minStaticDist = dist; closestStatic = obj; } });
        if (closestStatic) {
            if (closestStatic.isSupply) { const newItem = createItem(closestStatic.supplyType, milan.offsetLeft, milan.offsetTop); heldItem = newItem; heldItem.isHeld = true; heldItem.element.style.zIndex = 11; }
            else if (closestStatic.isRelief) { useStressRelief(closestStatic.reliefType); }
        }
    }
}
function isOverlapping(e1,e2){const r1=e1.getBoundingClientRect(),r2=e2.getBoundingClientRect();return!(r1.right<r2.left||r1.left>r2.right||r1.bottom<r2.top||r1.top>r2.bottom)}
function updateStress(c){stress+=c;if(stress<0)stress=0;if(stress>100)stress=100;stressBar.style.width=stress+'%';if(stress>=100)endGame(translations[currentLanguage].gameOverReasonCollapse)}
function createMilanBubble(t){const b=document.createElement('div');b.className='milan-bubble';b.textContent=t;b.style.left=milan.offsetLeft+milan.offsetWidth+'px';b.style.top=milan.offsetTop-20+'px';gameWorld.appendChild(b);setTimeout(()=>b.remove(),2000)}

function startSmoking(isInitial = false) {
    if (!isInitial) {
        if (isConsuming) return;
        updateStress(-15);
        nicotineLevel += 40;
        if (nicotineLevel > 100) nicotineLevel = 100;
    }
    isConsuming = true;
    const cig = document.createElement('div');
    cig.className = 'cigarette-visual';
    milan.appendChild(cig);
    cig.style.left = (milan.offsetWidth - 20) + 'px';
    cig.style.top = '25px';
    cig.style.transform = 'rotate(-20deg)';
    const smokeInterval = setInterval(() => {
        if (!gameRunning || !cig.parentElement) return;
        for(let i=0; i<3; i++) {
            const smoke = document.createElement('div');
            smoke.className = 'smoke';
            const cigRect = cig.getBoundingClientRect();
            smoke.style.left = cigRect.right - 10 + 'px';
            smoke.style.top = cigRect.top + 'px';
            smoke.style.animationDelay = `${Math.random() * 0.5}s`;
            smoke.style.animationDuration = `${Math.random() * 1 + 2}s`
            gameWorld.appendChild(smoke);
            setTimeout(() => smoke.remove(), 3000);
        }
    }, 500);
    setTimeout(() => {
        clearInterval(smokeInterval);
        if (cig.parentElement) cig.remove();
        isConsuming = false;
    }, 5000);
}

function useStressRelief(type) {
    if (isConsuming || !gameRunning) return;
    const t = translations[currentLanguage];
    createMilanBubble(t.milanRelief[Math.floor(Math.random()*t.milanRelief.length)]);
    if (type === 'vodka') {
        isConsuming = true;
        updateStress(-30); 
        intoxicationLevel += 40;
        if (intoxicationLevel > 100) intoxicationLevel = 100;
        for (let i = 0; i < 15; i++) {
            const p = document.createElement('div');
            p.className = 'drunk-particle';
            p.style.left = Math.random() * window.innerWidth + 'px';
            p.style.top = Math.random() * window.innerHeight + 'px';
            p.style.backgroundColor = `hsla(${Math.random() * 360}, 100%, 70%, 0.6)`;
            p.style.animationDelay = `${Math.random() * 0.5}s`;
            gameWorld.appendChild(p);
            setTimeout(() => p.remove(), 2000);
        }
        setTimeout(() => { isConsuming = false; }, 1500); 
        if (intoxicationLevel > 95) endGame(translations[currentLanguage].gameOverReasonAlcohol);
    } else if (type === 'cigarettes') {
        startSmoking();
    }
}

function customerLeaves(cust, isAngry) {
    if(cust.state === 'leaving') return;
    cust.state = 'leaving';
    if (cust.queueSlot) { cust.queueSlot.occupied = false; cust.queueSlot = null; }
    if (cust.figureElement) {
        cust.speechBubble.classList.remove('visible');
        cust.waitTimerContainer.style.visibility = 'hidden';
        if (!isAngry && cust.table && Math.random() < 0.35) {
            const rudeComments = translations[currentLanguage].customerRudeComments;
            cust.speechBubble.innerHTML = rudeComments[Math.floor(Math.random() * rudeComments.length)];
            cust.speechBubble.style.color = 'gray';
            cust.speechBubble.classList.add('visible');
            setTimeout(() => { if (cust.speechBubble) cust.speechBubble.classList.remove('visible'); }, 2500);
        }
        const fig = cust.figureElement;
        fig.style.top = gameWorld.clientHeight + 50 + 'px';
        fig.style.left = (Math.random() * (gameWorld.clientWidth / 2 - 100) + river.clientWidth + 50) + 'px';
        setTimeout(() => { 
            if(fig.parentElement) fig.remove(); 
            const index = customers.indexOf(cust);
            if (index > -1) customers.splice(index, 1);
        }, 3000);
    } else {
        const index = customers.indexOf(cust);
        if (index > -1) customers.splice(index, 1);
    }
}

function customerCusses(cust) {
    const curses = translations[currentLanguage].customerCurses;
    cust.speechBubble.innerHTML = curses[Math.floor(Math.random() * curses.length)];
    cust.speechBubble.style.color = 'red'; cust.speechBubble.classList.add('visible');
    setTimeout(() => { customerLeaves(cust, true); }, 2500);
}

function gameLoop(timestamp){
    if (!gameRunning) return;
    animationFrameId = requestAnimationFrame(gameLoop);
    
    if (!lastTime) lastTime = timestamp;
    const deltaTime = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    
    if (intoxicationLevel > 0) intoxicationLevel -= (1.5 * deltaTime); else intoxicationLevel = 0;
    if (nicotineLevel > 0) nicotineLevel -= (3 * deltaTime); else nicotineLevel = 0;

    const stressShake = stress > 70 ? (stress - 70) / 15 : 0;
    const drunkShake = intoxicationLevel / 8;
    const nicotineShake = nicotineLevel / 25;
    const totalShake = stressShake + drunkShake + nicotineShake;
    if (totalShake > 0) {
        const sX = (Math.random() - 0.5) * totalShake;
        const sY = (Math.random() - 0.5) * totalShake;
        gameWorld.style.transform = `translate(${sX}px, ${sY}px)`;
    } else {
        gameWorld.style.transform = 'none';
    }
    const stressBlur = stress > 85 ? (stress - 85) / 10 : 0;
    const drunkBlur = intoxicationLevel > 20 ? (intoxicationLevel - 20) / 10 : 0;
    const nicotineBlur = nicotineLevel > 40 ? (nicotineLevel - 40) / 50 : 0;
    const totalBlur = stressBlur + drunkBlur + nicotineBlur;
    const drunkHue = intoxicationLevel > 30 ? (intoxicationLevel - 30) / 3 : 0;
    const nicotineSaturation = 100 + (nicotineLevel > 20 ? (nicotineLevel - 20) / 2 : 0);
    gameWorld.style.filter = `blur(${totalBlur}px) hue-rotate(${drunkHue}deg) saturate(${nicotineSaturation}%)`;
    controlsImpaired = intoxicationLevel > 40;
    if (controlsImpaired && heldItem && Math.random() < (intoxicationLevel / 500 * deltaTime)) {
        createMilanBubble(translations[currentLanguage].milanDrop);
        heldItem.isHeld = false;
        heldItem.element.style.zIndex = 5;
        heldItem = null;
    }
    customers.forEach(cust => {
        if (cust.state === 'waiting_in_queue') {
            cust.waitTime += deltaTime; 
            const waitPercentage = (cust.waitTime / cust.maxWaitTime) * 100;
            cust.waitTimerBar.style.width = (100 - waitPercentage) + '%';
            if (waitPercentage < 40) cust.waitTimerBar.style.backgroundColor = '#32CD32';
            else if (waitPercentage < 75) cust.waitTimerBar.style.backgroundColor = '#FFD700';
            else cust.waitTimerBar.style.backgroundColor = '#DC143C';
            if (cust.waitTime >= cust.maxWaitTime) {
                updateStress(25);
                cust.speechBubble.innerHTML = translations[currentLanguage].customerImpatient;
                cust.speechBubble.style.color = 'orange';
                cust.speechBubble.classList.add('visible');
                customerLeaves(cust, true);
            }
        }
    });
    updateStress((baseStressRate+customers.filter(c=>c.state==='waiting_in_queue').length*0.1)*deltaTime);
    if(stress > 50 && !milanSwearCooldown) {
        const swears = translations[currentLanguage].milanSwears;
        createMilanBubble(swears[Math.floor(Math.random()*swears.length)]);
        milanSwearCooldown = true;
        setTimeout(() => { milanSwearCooldown = false }, 5000);
    }
    const slowDownFactor = 1 + (intoxicationLevel / 200) + (nicotineLevel / 400);
    const currentSpeed = MILAN_SPEED / slowDownFactor;
    let mX=0,mY=0;if(keys.w)mY-=1;if(keys.s)mY+=1;if(keys.a)mX-=1;if(keys.d)mX+=1;if(controlsImpaired)[mX,mY]=[-mY,mX];let cX=milan.offsetLeft+mX*currentSpeed*deltaTime,cY=milan.offsetTop+mY*currentSpeed*deltaTime;if(cX<0)cX=0;if(cX>gameWorld.clientWidth-milan.clientWidth)cX=gameWorld.clientWidth-milan.clientWidth;if(cY<0)cY=0;if(cY>gameWorld.clientHeight-milan.clientHeight)cY=gameWorld.clientHeight-milan.clientHeight;milan.style.left=cX+'px';milan.style.top=cY+'px';
    if(heldItem){ heldItem.element.style.left=milan.offsetLeft+milan.clientWidth/2-heldItem.element.clientWidth/2+'px'; heldItem.element.style.top=milan.offsetTop-heldItem.element.clientHeight+'px'; }
    items.forEach((item,index)=>{
        if (item.onPlate) return;
        if(!item.isHeld && ['sausage','cheese'].includes(item.type)){
            if(isOverlapping(item.element,grill)&&item.cookState<COOK_STATES.BURNT){
                item.cookTime += deltaTime;
                const tPS=item.type==='sausage'?COOK_TIMES.SAUSAGE:COOK_TIMES.CHEESE;
                const nS=Math.floor(item.cookTime/tPS);
                if(nS>item.cookState){ item.cookState=nS>3?3:nS; updateItemVisuals(item) }
                if(Math.random() > 0.98) createSmoke(item.element)
            }
        }
        if(!item.isHeld&&isOverlapping(item.element,trashCan)){
            while (item.element.firstChild) { item.element.removeChild(item.element.firstChild); }
            item.element.remove(); items.splice(index,1);
        }
    });
}
function updateItemVisuals(item){const t=item.type==='sausage'?'sausage':'cheese';item.element.className=`item ${t}`;switch(item.cookState){case COOK_STATES.RAW:item.element.classList.add(`raw-${t}`);break;case COOK_STATES.GOLDEN:item.element.classList.add(`golden-${t}`);break;case COOK_STATES.WELLDONE:item.element.classList.add(`welldone-${t}`);break;case COOK_STATES.BURNT:item.element.classList.add(`burnt-${t}`);break;}}
function checkOrder(plate, order) {
    if ((plate.breadCount || 0) !== order.bread) return false;
    if (order.ketchup !== plate.hasKetchup || order.mustard !== plate.hasMustard || order.cranberries !== plate.hasCranberries) return false;
    const plateContents = plate.contents.map(i => ({ type: i.type, cookState: i.cookState })).sort((a, b) => a.type.localeCompare(b.type));
    const orderItems = order.items.sort((a, b) => a.type.localeCompare(b.type));
    if (plateContents.length !== orderItems.length) return false;
    for (let i = 0; i < orderItems.length; i++) {
        if (plateContents[i].type !== orderItems[i].type || plateContents[i].cookState !== orderItems[i].cookState) return false;
    }
    return true;
}

function createPoopParticle(x, y) { const p = document.createElement('div'); p.className = 'poop-particle'; p.style.left = x + (Math.random() * 20 - 10) + 'px'; p.style.top = y + 60 + (Math.random() * 10 - 5) + 'px'; gameWorld.appendChild(p); setTimeout(() => p.remove(), 2500); }
function createDirtParticle(x, y) { const p = document.createElement('div'); p.className = 'dirt-particle'; p.style.left = x + 10 + (Math.random() * 20 - 10) + 'px'; p.style.top = y + 65 + (Math.random() * 10 - 5) + 'px'; p.style.animationDelay = `${Math.random() * 0.2}s`; gameWorld.appendChild(p); setTimeout(() => p.remove(), 800); }
function createSmoke(el){ const smoke = document.createElement('div'); smoke.className = 'smoke'; const rect = el.getBoundingClientRect(); smoke.style.left = rect.left + Math.random() * rect.width + 'px'; smoke.style.top = rect.top + 'px'; smoke.style.animationDelay = `${Math.random() * 0.5}s`; smoke.style.animationDuration = `${Math.random() * 1 + 2}s`; gameWorld.appendChild(smoke); setTimeout(() => smoke.remove(), 3000); }

function moveCustomerToTable(cust, plate) {
    const eT = seatingAreas.find(sa => !sa.occupied);
    if (eT) {
        eT.occupied = true; cust.table = eT;
        const fig = cust.figureElement, tR = eT.element.querySelector('.table').getBoundingClientRect();
        const bench = eT.element.querySelector(Math.random() > 0.5 ? '.bench.top' : '.bench.bottom');
        const bR = bench.getBoundingClientRect();
        fig.style.left = bR.left + 50 + 'px'; fig.style.top = bR.top - 50 + 'px';
        const tablePlate = plate.element.cloneNode(true);
        tablePlate.style.position = 'absolute'; tablePlate.style.left = tR.left + 30 + 'px'; tablePlate.style.top = tR.top - 10 + 'px'; tablePlate.style.zIndex = 5;
        gameWorld.appendChild(tablePlate);

        setTimeout(() => {
            tablePlate.remove();
            if (Math.random() < 0.4) { sendCustomerToOuthouse(cust); } 
            else { if (cust.table) cust.table.occupied = false; customerLeaves(cust, false); }
        }, 15000);
    } else { customerLeaves(cust, true); }
}

function sendCustomerToOuthouse(cust) {
    cust.state = 'walking_to_outhouse'; const fig = cust.figureElement;
    const outhouseRect = outhouse.getBoundingClientRect();
    fig.style.left = outhouseRect.left + 'px'; fig.style.top = outhouseRect.top + outhouseRect.height + 'px';
    setTimeout(() => {
        cust.state = 'using_outhouse'; fig.style.display = 'none'; outhouse.classList.add('shake');
        setTimeout(() => {
            outhouse.classList.remove('shake'); fig.style.display = 'block'; customerLeavesOuthouse(cust);
        }, 3000);
    }, 3000);
}

function customerLeavesOuthouse(cust) {
    cust.state = 'leaving_in_distress'; 
    const fig = cust.figureElement;
    const curses = translations[currentLanguage].outhouseCurses;
    cust.speechBubble.innerHTML = curses[Math.floor(Math.random() * curses.length)];
    cust.speechBubble.style.color = 'brown'; cust.speechBubble.classList.add('visible');
    const particleInterval = setInterval(() => {
        if (cust.state !== 'leaving_in_distress' || !fig.parentElement) {
            clearInterval(particleInterval);
            return;
        }
        createPoopParticle(fig.offsetLeft, fig.offsetTop);
        createDirtParticle(fig.offsetLeft, fig.offsetTop);
        createDirtParticle(fig.offsetLeft, fig.offsetTop);
        createDirtParticle(fig.offsetLeft, fig.offsetTop);
    }, 100);
    if (cust.table) cust.table.occupied = false;
    fig.style.transition = 'left 2.5s linear, top 2.5s linear';
    customerLeaves(cust, false);
    setTimeout(() => { 
        clearInterval(particleInterval); 
        fig.style.transition = 'left 3s ease-in-out, top 3s ease-in-out'; 
    }, 2600);
}

function createItem(type,x,y){const el=document.createElement('div');el.classList.add('item',type);if(type==='sausage')el.classList.add('raw-sausage');if(type==='cheese')el.classList.add('raw-cheese');el.style.left=x+'px';el.style.top=y+'px';const itemObj={element:el,type:type,isHeld:!1};if(['sausage','cheese'].includes(type)){itemObj.cookTime=0;itemObj.cookState=COOK_STATES.RAW;itemObj.onPlate=null}if(type==='plate'){itemObj.contents=[];itemObj.hasKetchup=!1;itemObj.hasMustard=!1;itemObj.hasCranberries=!1;itemObj.breadCount=0}items.push(itemObj);gameWorld.appendChild(el);return itemObj}

const hairColorPool = [
    '#3d2d1b', '#3d2d1b', '#111', '#111', '#e0b452', '#e0b452', '#e0b452', 
    '#c7864f', '#c7864f', '#dddddd', 
    '#af3333', '#4169e1' 
];
function getRandomHairColor() {
    return hairColorPool[Math.floor(Math.random() * hairColorPool.length)];
}

function createCustomer() {
    const occupiedSlots = queueSlots.filter(s => s.occupied).length;
    if (occupiedSlots >= maxQueueSize) return;
    const availableSlot = queueSlots.find(s => !s.occupied);
    if (!availableSlot) return;
    
    const g = Math.random() > 0.5 ? 'man' : 'woman';
    const f = document.createElement('div');
    f.className = `customer-figure ${g}`;

    if (Math.random() < 0.15) { f.classList.add('obese'); }

    const hairRoll = Math.random();
    let hairHTML = '';
    if ((g === 'woman' && hairRoll > 0.02) || (g === 'man' && hairRoll > 0.15)) {
        const availableStyles = (g === 'woman') ? ['style1', 'style2', 'style4'] : ['style1', 'style2', 'style4'];
        const hairStyle = availableStyles[Math.floor(Math.random() * availableStyles.length)];
        const hairColor = getRandomHairColor();
        hairHTML = `<div class="hair ${hairStyle}" style="color: ${hairColor}"></div>`;
    }

    let genderSpecificHTML = '';
    const clothingColor = ['#DC143C', '#008000', '#0000CD', '#FF69B4', '#FFA500'][Math.floor(Math.random()*5)];

    if (g === 'woman') {
        if (Math.random() < 0.3) { f.classList.add('curvy'); }
        
        const boobsRoll = Math.random();
        let boobsClass = 'boobs-medium';
        if (boobsRoll < 0.33) boobsClass = 'boobs-small';
        else if (boobsRoll > 0.66) boobsClass = 'boobs-large';
        
        let clothingHTML = '';
        if (Math.random() < 0.2) { 
            clothingHTML = `<div class="one-piece-suit" style="background-color: ${clothingColor}"></div>`;
        } else {
            const bikiniTopStyles = ['style-triangle', 'style-bandeau', 'style-circles-connected', 'style-balls'];
            const bikiniTopClass = bikiniTopStyles[Math.floor(Math.random() * bikiniTopStyles.length)];
            
            const bikiniBottomStyles = ['style-a', 'style-b', 'style-thong'];
            const bikiniBottomClass = bikiniBottomStyles[Math.floor(Math.random() * bikiniBottomStyles.length)];
            
            clothingHTML = `
                <div class="bikini-top ${bikiniTopClass}" style="background-color: ${clothingColor}; border-color: ${clothingColor}"></div>
                <div class="bikini-bottom ${bikiniBottomClass}" style="background-color: ${clothingColor}"></div>
            `;
        }

        genderSpecificHTML = `
            <div class="torso ${boobsClass}"></div>
            <div class="arm left"></div><div class="arm right"></div>
            ${clothingHTML}
            <div class="leg left"></div><div class="leg right"></div>`;

    } else {
        const shortsStyles = ['style-a', 'style-boardshorts', 'style-speedo'];
        const shortsClass = shortsStyles[Math.floor(Math.random() * shortsStyles.length)];
        genderSpecificHTML = `
            <div class="torso"></div>
            <div class="arm left"></div><div class="arm right"></div>
            <div class="shorts ${shortsClass}" style="background-color: ${clothingColor}"></div>
            <div class="leg left"></div><div class="leg right"></div>`;
    }

    f.innerHTML = `
        <div class="head">
            ${hairHTML}
            <div class="face"><div class="eye left"></div><div class="eye right"></div><div class="mouth"></div></div>
        </div>
        ${genderSpecificHTML}
        <div class="wait-timer-container"><div class="wait-timer-bar"></div></div>`;

    Array.from(f.children).forEach(child => { if(child.classList.contains('arm') || child.classList.contains('leg')) { child.style.backgroundColor = '#FFDAB9'; } });
    gameWorld.appendChild(f);
    
    f.style.top = gameWorld.clientHeight + 50 + 'px'; f.style.left = (Math.random() * (gameWorld.clientWidth / 2 - 100) + river.clientWidth + 50) + 'px';
    
    const o = generateOrder(); const b = document.createElement('div'); b.className = 'speech-bubble'; b.innerHTML = formatOrder(o, g);
    f.appendChild(b);
    const timerContainer = f.querySelector('.wait-timer-container');
    const timerBar = f.querySelector('.wait-timer-bar');
    const c = { figureElement: f, speechBubble: b, order: o, state: 'walking_to_queue', waitTime: 0, angry: !1, queueSlot: null, personality: o.personality, waitTimerContainer: timerContainer, waitTimerBar: timerBar, maxWaitTime: 90 + (o.personality === 'nice' ? 40 : (o.personality === 'rude' ? -40 : 0)) };
    customers.push(c);

    setTimeout(() => {
        const availableSlot = queueSlots.find(s => !s.occupied);
        if (availableSlot) {
            availableSlot.occupied = true;
            c.queueSlot = availableSlot;
            f.style.left = availableSlot.x + 'px'; f.style.top = availableSlot.y + 'px';
            setTimeout(() => { c.state = 'waiting_in_queue'; c.speechBubble.classList.add('visible'); c.waitTimerContainer.style.visibility = 'visible'; }, 3000);
        }
    }, 100);
}

function generateOrder() { const order = { items: [], ketchup: false, mustard: false, cranberries: false, bread: 0, personality: 'neutral' }; const p = Math.random(); if (p < 0.25) order.personality = 'rude'; else if (p < 0.6) order.personality = 'nice'; if (survivalTime < 45) { order.items.push({type: Math.random() > 0.5 ? 'sausage' : 'cheese', cookState: COOK_STATES.GOLDEN}); return order; } const mainItemCount = (survivalTime > 90 && Math.random() > 0.5) ? 2 : 1; for (let i = 0; i < mainItemCount; i++) { const item = { type: Math.random() > 0.5 ? 'sausage' : 'cheese', cookState: [COOK_STATES.GOLDEN, COOK_STATES.WELLDONE][Math.floor(Math.random() * 2)] }; if(i > 0 && item.type === 'cheese' && order.items.type === 'cheese') { item.type = 'sausage'; } order.items.push(item); } if (order.items.some(i => i.type === 'sausage')) { const s = Math.random(); if (s < 0.33) order.ketchup = true; else if (s < 0.66) order.mustard = true; else { order.ketchup = true; order.mustard = true; } } if (order.items.some(i => i.type === 'cheese')) { if (Math.random() > 0.5) order.cranberries = true; } order.bread = survivalTime > 45 ? Math.floor(Math.random() * 5) : Math.floor(Math.random() * 3); return order; }

function formatOrder(order, gender) {
    const t = translations[currentLanguage];
    let text = "";
    switch(order.personality) {
        case 'nice': text = (gender === 'woman' ? t.nice_woman : t.nice_man)[Math.floor(Math.random()*t.nice_man.length)]; break;
        case 'rude': text = t.rude[Math.floor(Math.random()*t.rude.length)]; break;
        default: text = (gender === 'woman' ? t.neutral_woman : t.neutral_man)[Math.floor(Math.random()*t.neutral_man.length)];
    }
    const itemCounts = order.items.reduce((acc, item) => {
        const key = `${item.type}-${item.cookState}`;
        acc[key] = (acc[key] || 0) + 1;
        return acc;
    }, {});
    const itemStrings = Object.entries(itemCounts).map(([key, count]) => {
        const [type, cookState] = key.split('-');
        if (currentLanguage === 'cs') {
            const adjKey = count === 1 ? 'singular' : (count >= 2 && count <= 4 ? 'plural' : 'genitive');
            const adj = type === 'sausage' ? t.sausage_adj[adjKey][cookState] : t.cheese_adj[adjKey][cookState];
            const nounKey = count === 1 ? 1 : (count >= 2 && count <= 4 ? 2 : 5);
            const noun = type === 'sausage' ? t.sausage_plural[nounKey] : t.cheese_plural[nounKey];
            const num = type === 'sausage' ? t.numbers[count] : t.numbers_male[count];
            if (count === 1) return `${adj} ${noun}`;
            return `${num} ${adj} ${noun}`;
        } else {
            const adj = type === 'sausage' ? t.sausage_adj[cookState] : t.cheese_adj[cookState];
            const nounKey = count === 1 ? 1 : 2;
            const noun = type === 'sausage' ? t.sausage_plural[nounKey] : t.cheese_plural[nounKey];
            if (count === 1) return `a ${adj} ${noun}`;
            return `${count} ${adj} ${noun}`;
        }
    });
    text += itemStrings.join(currentLanguage === 'cs' ? ' a ' : ' and ') + ". ";
    if (order.ketchup && order.mustard) text += t.withBoth + ' '; else if (order.ketchup) text += t.withKetchup + ' '; else if (order.mustard) text += t.withMustard + ' ';
    if (order.cranberries) text += t.withCranberries + ' ';
    if (order.bread > 0) text += t.andBread.replace('{count}', order.bread);
    return text;
}

function createStaticObject(config){ const o=document.createElement('div'); o.className='static-object'; o.style.left=config.x+'px'; o.style.top=config.y+'px'; o.style.width=(config.w||0)+'px'; o.style.height=(config.h||0)+'px'; if(config.visuals){config.visuals.forEach(vis=>{const e=document.createElement('div'); e.className=vis.class; e.style.left=(vis.x||0)+'px'; e.style.top=(vis.y||0)+'px'; if(vis.rot)e.style.transform=`rotate(${vis.rot}deg)`; if(vis.html)e.innerHTML=vis.html; o.appendChild(e)})} stall.appendChild(o); staticObjects.push({element:o,...config}); }
function createSupplyTable(config) { const container = document.createElement('div'); container.className = 'supply-table-container'; container.style.left = config.x + 'px'; container.style.top = config.y + 'px'; container.style.width = config.w + 'px'; container.style.height = config.h + 20 + 'px'; const top = document.createElement('div'); top.className = 'supply-table-top'; top.style.width = config.w + 'px'; top.style.height = config.h + 'px'; container.appendChild(top); const legPositions = [{top: config.h-3, left: 3}, {top: config.h-3, right: 3}, {top: 0, left: 3, zIndex: 0}, {top: 0, right: 3, zIndex: 0}]; legPositions.forEach(pos => { const leg = document.createElement('div'); leg.className = 'supply-table-leg'; leg.style.top = pos.top + 'px'; if (pos.left !== undefined) leg.style.left = pos.left + 'px'; if (pos.right !== undefined) leg.style.right = pos.right + 'px'; if (pos.zIndex !== undefined) leg.style.zIndex = 0; container.appendChild(leg); }); stall.appendChild(container); }
function createSilverTable(config) { const container = document.createElement('div'); container.className = 'silver-table-container'; container.style.left = config.x + 'px'; container.style.top = config.y + 'px'; container.style.width = config.w + 'px'; container.style.height = config.h + 20 + 'px'; const top = document.createElement('div'); top.className = 'silver-table-top'; top.style.width = config.w + 'px'; top.style.height = config.h + 'px'; container.appendChild(top); const legPositions = [{top: config.h-3, left: 3}, {top: 0, left: 3, zIndex: 0}, {top: config.h-3, right: 3}, {top: 0, right: 3, zIndex: 0}]; legPositions.forEach(pos => { const leg = document.createElement('div'); leg.className = 'silver-table-leg'; leg.style.top = pos.top + 'px'; if (pos.left !== undefined) leg.style.left = pos.left + 'px'; if (pos.right !== undefined) leg.style.right = pos.right + 'px'; if (pos.zIndex !== undefined) leg.style.zIndex = 0; container.appendChild(leg); }); stall.appendChild(container); }

function createDecorativeVessel() {
    if (!gameRunning) return;

    const spawnRoll = Math.random();
    let choice, lane;

    if (spawnRoll < 0.70) { 
        choice = { type: 'kayak', speedMin: 10, speedMax: 15, width: 50 };
        lane = Math.random() < 0.5 ? 'left' : 'right';
        if (riverLanes[lane]) { lane = lane === 'left' ? 'right' : 'left'; }
    } else if (spawnRoll < 0.90) {
        choice = { type: 'raft', speedMin: 18, speedMax: 25, width: 70 };
        lane = Math.random() < 0.5 ? 'left' : 'right';
         if (riverLanes[lane]) { lane = lane === 'left' ? 'right' : 'left'; }
    } else {
        choice = { type: 'big-ship', speedMin: 25, speedMax: 35, width: 100 };
        lane = 'center';
    }

    if (riverLanes[lane]) return; 

    riverLanes[lane] = true;

    const v = document.createElement('div');
    v.className = `deco-vessel ${choice.type}`;
    
    let contentHTML = '';
    if(choice.type === 'kayak') {
        v.classList.add(['red', 'green', 'blue'][Math.floor(Math.random() * 3)]);
        const numPeople = Math.floor(Math.random() * 3) + 2;
        const baseHeight = 100; const extraHeightPerPerson = 40;
        v.style.height = baseHeight + (numPeople - 1) * extraHeightPerPerson + 'px';
        let peopleHTML = '';
        for (let i = 0; i < numPeople; i++) {
            peopleHTML += `<div class="kayak-person" style="top: ${30 + i * 35}px; left: 15px;"></div>`;
        }
        contentHTML = `<div class="kayak-body">${peopleHTML}</div>`;
    } else if (choice.type === 'raft') {
        contentHTML = `<div class="raft-person"></div>`;
    }
    
    if (lane === 'left') v.style.left = '10px';
    else if (lane === 'center') v.style.left = (river.clientWidth / 2) - (choice.width / 2) + 'px';
    else if (lane === 'right') v.style.left = (river.clientWidth - choice.width - 10) + 'px';

    v.innerHTML = contentHTML;
    v.style.top = gameWorld.clientHeight + 50 + 'px';
    
    const duration = Math.random() * (choice.speedMax - choice.speedMin) + choice.speedMin;
    v.style.transitionDuration = `${duration}s`;
    
    river.appendChild(v);
    setTimeout(() => { v.style.top = -250 + 'px'; }, 100);
    setTimeout(() => { 
        if(v.parentElement) v.remove();
        riverLanes[lane] = false;
    }, (duration * 1000) + 1000);
}

function scheduleNextCustomer() { const nextSpawn = () => { if (gameRunning) { createCustomer(); setTimeout(nextSpawn, customerSpawnInterval); } }; nextSpawn(); }

function startGame(){
    startScreen.style.display = 'none';
    gameRunning = true;
    updateAllText();

    grill = document.getElementById('grill'); trashCan = document.getElementById('trash-can');
    grill.style.left='20px'; grill.style.top='20px';
    trashCan.style.left=stall.offsetWidth-70+'px'; trashCan.style.top=`${stall.offsetHeight-100}px`;
    const sauceWarningSign = document.getElementById('sauce-warning-sign');
    sauceWarningSign.style.left = (stall.offsetWidth - 170) + 'px';
    sauceWarningSign.style.top = '40px';
    const stallRect = stall.getBoundingClientRect();
    queueSlots = [ { x: stallRect.left + 150, y: stallRect.bottom + 20, occupied: false }, { x: stallRect.left + 250, y: stallRect.bottom + 20, occupied: false }, { x: stallRect.left + 350, y: stallRect.bottom + 20, occupied: false }, ];
    
    const treeData=[{x:350,y:20,s:1.1,type:'deciduous'},{x:950,y:30,s:1,type:'pine'},{x:480,y:850,s:0.9,type:'deciduous'},{x:330,y:500,s:1.2,type:'pine'},{x:600,y:20,s:1,type:'deciduous'},{x:1250,y:90,s:1.3,type:'deciduous'},{x:1150,y:800,s:1,type:'pine'},{x:1450,y:180,s:0.8,type:'pine'},{x:1380,y:790,s:1.1,type:'deciduous'},{x:1520,y:60,s:1.2,type:'deciduous'},{x:1600,y:620,s:1,type:'pine'},{x:1050,y:40,s:1.1,type:'deciduous'},{x:1180,y:820,s:0.9,type:'deciduous'},{x:1820,y:450,s:1.2,type:'pine'},{x:830,y:820,s:0.9,type:'pine'},{x:900,y:850,s:1.2,type:'deciduous'},{x:1850,y:80,s:1,type:'pine'},{x:1800,y:800,s:0.8,type:'deciduous'},{x:850,y:50,s:1.1,type:'pine'},{x:600,y:800,s:1,type:'deciduous'},{x:1000,y:790,s:0.9,type:'pine'}];
    treeData.forEach(d => { d.y += 120; });
    treeData.forEach(d=>{ const t=document.createElement('div'); t.className=`tree ${d.type}`; const crownStyle = `transform: scale(${d.s}); ${d.type === 'deciduous' ? 'background-color:hsl(120, 60%, ' + (Math.random()*15+25) + '%)' : ''}`; t.innerHTML=`<div class="trunk" style="height:${(d.type === 'pine' ? 120 : 80)*d.s}px;width:${(d.type === 'pine' ? 15 : 20)*d.s}px;"></div><div class="crown" style="${crownStyle}"></div>`; t.style.left=d.x+'px'; t.style.top=d.y+'px'; gameWorld.insertBefore(t,stall) });
    for(let i=0;i<50;i++){const s=document.createElement('div');s.className='stone';const z=Math.random()*50+20;s.style.width=z+'px';s.style.height=z*(Math.random()*.4+.8)+'px';s.style.left=Math.random() > 0.5 ? river.clientWidth+5+Math.random()*20+'px' : Math.random() * (gameWorld.clientWidth - river.clientWidth - z) + river.clientWidth + 'px'; s.style.top=Math.random()*(gameWorld.clientHeight-z)+'px'; s.style.backgroundColor = `hsl(0, 0%, ${Math.random()*20+40}%)`; gameWorld.appendChild(s);}
    for(let i=0; i<30; i++) { const g = document.createElement('div'); g.className='grass-patch'; const z = Math.random()*80+40; g.style.width=z+'px'; g.style.height=z*(Math.random()*.5+.5)+'px'; g.style.left = Math.random() * (gameWorld.clientWidth - river.clientWidth - z) + river.clientWidth + 'px'; g.style.top = Math.random()*(gameWorld.clientHeight-z)+'px'; g.style.transform = `rotate(${Math.random()*180}deg)`; gameWorld.appendChild(g); }
    for(let i=0; i<25; i++) { const f = document.createElement('div'); f.className='flower'; const flowerColor = ['#ffc0cb', '#ffffff', '#e6e6fa', '#add8e6'][Math.floor(Math.random()*4)]; f.innerHTML = `<div class="flower-petal p1" style="background-color:${flowerColor}"></div><div class="flower-petal p2" style="background-color:${flowerColor}"></div><div class="flower-petal p3" style="background-color:${flowerColor}"></div><div class="flower-petal p4" style="background-color:${flowerColor}"></div><div class="flower-center"></div>`; f.style.left = Math.random() * (gameWorld.clientWidth - river.clientWidth - 20) + river.clientWidth + 'px'; f.style.top = Math.random()*(gameWorld.clientHeight-20)+'px'; gameWorld.appendChild(f); }
    for(let i=0;i<40;i++){const w=document.createElement('div');w.className='wave';w.style.left=Math.random()*(river.clientWidth-10)+'px';w.style.animationDelay=Math.random()*5+'s';river.appendChild(w);}
    for(let i=0;i<3;i++){for(let j=0;j<2;j++){const a=document.createElement('div');a.className='seating-area';a.innerHTML=`<div class="table"></div><div class="bench top"></div><div class="bench bottom"></div>`;a.style.right=(80+j*220)+'px';a.style.top=(100+i*180)+'px';gameWorld.appendChild(a);seatingAreas.push({element:a,occupied:!1});}}
    const outhouseRect = outhouse.getBoundingClientRect();
    for (let i = 0; i < 5; i++) { const stain = document.createElement('div'); stain.className = 'poop-stain'; const size = Math.random() * 25 + 10; stain.style.width = size + 'px'; stain.style.height = size * (Math.random() * 0.5 + 0.7) + 'px'; stain.style.borderRadius = `${Math.random()*50}% ${Math.random()*50}% ${Math.random()*50}% ${Math.random()*50}%`; stain.style.left = outhouseRect.left - 20 + (Math.random() * (outhouseRect.width + 40)) + 'px'; stain.style.top = outhouseRect.bottom - 20 + (Math.random() * 40) + 'px'; gameWorld.insertBefore(stain, outhouse); }
    for (let i = 0; i < 30; i++) { const p = document.createElement('div'); p.className='path-stone'; const s = Math.random() * 15 + 10; p.style.width=s+'px'; p.style.height=s*0.7+'px'; p.style.transform=`rotate(${Math.random()*180}deg)`; p.style.left=outhouse.offsetLeft - 60 + Math.random() * 80 + 'px'; p.style.top=outhouse.offsetTop + 120 + Math.random() * 100 + 'px'; gameWorld.insertBefore(p, stall); }
    for (let i = 0; i < 60; i++) { const p = document.createElement('div'); p.className='path-stone'; const s = Math.random() * 25 + 15; p.style.width=s+'px'; p.style.height=s*(Math.random()*0.3 + 0.6)+'px'; p.style.transform=`rotate(${Math.random()*180}deg)`; p.style.left=stallRect.left + stallRect.width/2 - 125 + Math.random() * 250 + 'px'; p.style.top=stallRect.bottom + Math.random() * (window.innerHeight - stallRect.bottom - s) + 'px'; gameWorld.insertBefore(p, stall); }
    createSupplyTable({x:280,y:90,w:100,h:40}); createStaticObject({x:290,y:80,w:80,h:50,isSupply:true,supplyType:'sausage',visuals:[{class:'sausage-stack-item',x:0,y:0,rot:10},{class:'sausage-stack-item',x:5,y:10,rot:-5},{class:'sausage-stack-item',x:-5,y:20,rot:5}]});
    createSupplyTable({x:410,y:90,w:100,h:40}); createStaticObject({x:430,y:75,w:50,h:50,isSupply:true,supplyType:'cheese',visuals:[{class:'cheese-stack-item',x:0,y:0},{class:'cheese-stack-item',x:8,y:8},{class:'cheese-stack-item',x:-4,y:16}]});
    createSupplyTable({x:360, y:300, w:100, h:40}); createStaticObject({x:380,y:285,w:60,h:50,isSupply:true,supplyType:'bread',visuals:[{class:'bread-stack-item',x:0,y:0},{class:'bread-stack-item',x:20,y:5},{class:'bread-stack-item',x:5,y:20}]});
    createSupplyTable({x:stall.offsetWidth-140, y:stall.offsetHeight-240, w:100, h:60}); createStaticObject({x:stall.offsetWidth-130,y:stall.offsetHeight-270,w:60,h:80,isSupply:true,supplyType:'plate',visuals:[{class:'plate-stack-item',x:0,y:0},{class:'plate-stack-item',x:0,y:4},{class:'plate-stack-item',x:0,y:8}]});
    createSilverTable({x:stall.offsetWidth-165,y:100,w:120,h:40}); createStaticObject({x:stall.offsetWidth-155,y:90,w:20,h:40,isSauce:true,sauceType:'ketchup',visuals:[{class:'ketchup-bottle'}]});
    createStaticObject({x:stall.offsetWidth-120,y:90,w:20,h:40,isSauce:true,sauceType:'mustard',visuals:[{class:'mustard-bottle'}]});
    createStaticObject({x:stall.offsetWidth-80,y:105,w:28,h:20,isSauce:true,sauceType:'cranberries',visuals:[{class:'cranberries-pot'}]});
    createSupplyTable({x: 20, y: 320, w: 80, h: 30});
    createStaticObject({x:25,y:280,w:30,h:75,isRelief:true,reliefType:'vodka',visuals:[{class:'vodka-bottle',html:'<div class="vodka-label">VODKA</div>'}]});
    createStaticObject({x:65,y:295,w:35,h:45,isRelief:true,reliefType:'cigarettes',visuals:[{class:'cigarettes-box'}]});
    
    const chair = document.createElement('div'); chair.className = 'chair';
    chair.innerHTML = '<div class="back"></div><div class="seat"></div><div class="leg front-left"></div><div class="leg front-right"></div><div class="leg back-left"></div><div class="leg back-right"></div>';
    
    chair.style.left = '20px'; 
    chair.style.top = (stall.offsetHeight - 90) + 'px';
    stall.appendChild(chair);

    milan.style.left = stall.offsetLeft + chair.offsetLeft + (chair.offsetWidth / 2) - (milan.offsetWidth / 2) - 365 + 'px';
    milan.style.top = stall.offsetTop + chair.offsetTop + (chair.offsetHeight / 2) - (milan.offsetHeight / 2) - 223 + 'px';
    startSmoking(true);

    setInterval(()=>{
        if(!gameRunning) return;
        survivalTime += 1;
        const t = translations[currentLanguage];
        timerDisplay.textContent=`${t.timerLabel}: ${Math.floor(survivalTime)}s`;
        if(Math.floor(survivalTime) > 0 && Math.floor(survivalTime) % 12 === 0) { if(customerSpawnInterval > 4000) customerSpawnInterval -= 600; baseStressRate += 0.012; }
    },1000);
    setInterval(() => { if(gameRunning) createDecorativeVessel(); }, 4000);
    
    scheduleNextCustomer();
    animationFrameId = requestAnimationFrame(gameLoop);
}

async function saveScore(gameId, newScoreData) {
    if (typeof auth === 'undefined' || typeof db === 'undefined') {
        console.log("Firebase not ready.");
        return;
    }
    const user = auth.currentUser;
    if (!user || !user.displayName) {
        console.log("User not logged in. Score not saved.");
        return;
    }

    const userName = user.displayName;
    const gameConfigs = {
        'milan': {
            collection: 'milan_leaderboard',
            isBetter: (newS, oldS) => newS.orders > oldS.orders || (newS.orders === oldS.orders && newS.time > oldS.time)
        }
    };

    const config = gameConfigs[gameId];
    if (!config) {
        console.error("Invalid gameId for saving score:", gameId);
        return;
    }

    const scoreDocRef = db.collection(config.collection).doc(userName);

    try {
        const doc = await scoreDocRef.get();
        if (!doc.exists || config.isBetter(newScoreData, doc.data())) {
            await scoreDocRef.set({ user: userName, ...newScoreData });
            console.log("High score saved for:", userName);
        } else {
            console.log("Score was not better. Not updating.");
        }
    } catch (error) {
        console.error("Error saving score: ", error);
    }
}


function endGame(reason) {
    gameRunning = false;
    cancelAnimationFrame(animationFrameId);
    
    saveScore('milan', { orders: ordersCompleted, time: Math.floor(survivalTime) });

    const t = translations[currentLanguage];
    document.getElementById('end-reason').textContent = reason;
    document.getElementById('end-score').textContent = `${t.gameOverScore} ${Math.floor(survivalTime)} ${t.gameOverSeconds}`;
    document.getElementById('end-orders').textContent = `${t.ordersCompleted}: ${ordersCompleted}`;
    gameOverScreen.style.display='flex'; 
}

window.onload = () => {
    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('lang-switch-btn').addEventListener('click', () => { currentLanguage = currentLanguage === 'cs' ? 'en' : 'cs'; updateAllText(); });
    document.getElementById('play-again-btn').addEventListener('click', () => window.location.reload());
    updateAllText();
};
</script>
</body>
</html>